module.exports = {".eslintrc.yml":"rules:\n    internal-no-invalid-meta: \"error\"\n    internal-consistent-docs-description: \"error\"\n","accessor-pairs.js":"/**\n * @fileoverview Rule to flag wrapping non-iife in parens\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is an `Identifier` node which was named a given name.\n * @param {ASTNode} node - A node to check.\n * @param {string} name - An expected name of the node.\n * @returns {boolean} `true` if the node is an `Identifier` node which was named as expected.\n */\nfunction isIdentifier(node, name) {\n    return node.type === \"Identifier\" && node.name === name;\n}\n\n/**\n * Checks whether or not a given node is an argument of a specified method call.\n * @param {ASTNode} node - A node to check.\n * @param {number} index - An expected index of the node in arguments.\n * @param {string} object - An expected name of the object of the method.\n * @param {string} property - An expected name of the method.\n * @returns {boolean} `true` if the node is an argument of the specified method call.\n */\nfunction isArgumentOfMethodCall(node, index, object, property) {\n    const parent = node.parent;\n\n    return (\n        parent.type === \"CallExpression\" &&\n        parent.callee.type === \"MemberExpression\" &&\n        parent.callee.computed === false &&\n        isIdentifier(parent.callee.object, object) &&\n        isIdentifier(parent.callee.property, property) &&\n        parent.arguments[index] === node\n    );\n}\n\n/**\n * Checks whether or not a given node is a property descriptor.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is a property descriptor.\n */\nfunction isPropertyDescriptor(node) {\n\n    // Object.defineProperty(obj, \"foo\", {set: ...})\n    if (isArgumentOfMethodCall(node, 2, \"Object\", \"defineProperty\") ||\n        isArgumentOfMethodCall(node, 2, \"Reflect\", \"defineProperty\")\n    ) {\n        return true;\n    }\n\n    /*\n     * Object.defineProperties(obj, {foo: {set: ...}})\n     * Object.create(proto, {foo: {set: ...}})\n     */\n    node = node.parent.parent;\n\n    return node.type === \"ObjectExpression\" && (\n        isArgumentOfMethodCall(node, 1, \"Object\", \"create\") ||\n        isArgumentOfMethodCall(node, 1, \"Object\", \"defineProperties\")\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce getter and setter pairs in objects\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n        schema: [{\n            type: \"object\",\n            properties: {\n                getWithoutSet: {\n                    type: \"boolean\"\n                },\n                setWithoutGet: {\n                    type: \"boolean\"\n                }\n            },\n            additionalProperties: false\n        }]\n    },\n    create(context) {\n        const config = context.options[0] || {};\n        const checkGetWithoutSet = config.getWithoutSet === true;\n        const checkSetWithoutGet = config.setWithoutGet !== false;\n\n        /**\n         * Checks a object expression to see if it has setter and getter both present or none.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkLonelySetGet(node) {\n            let isSetPresent = false;\n            let isGetPresent = false;\n            const isDescriptor = isPropertyDescriptor(node);\n\n            for (let i = 0, end = node.properties.length; i < end; i++) {\n                const property = node.properties[i];\n\n                let propToCheck = \"\";\n\n                if (property.kind === \"init\") {\n                    if (isDescriptor && !property.computed) {\n                        propToCheck = property.key.name;\n                    }\n                } else {\n                    propToCheck = property.kind;\n                }\n\n                switch (propToCheck) {\n                    case \"set\":\n                        isSetPresent = true;\n                        break;\n\n                    case \"get\":\n                        isGetPresent = true;\n                        break;\n\n                    default:\n\n                        // Do nothing\n                }\n\n                if (isSetPresent && isGetPresent) {\n                    break;\n                }\n            }\n\n            if (checkSetWithoutGet && isSetPresent && !isGetPresent) {\n                context.report({ node, message: \"Getter is not present.\" });\n            } else if (checkGetWithoutSet && isGetPresent && !isSetPresent) {\n                context.report({ node, message: \"Setter is not present.\" });\n            }\n        }\n\n        return {\n            ObjectExpression(node) {\n                if (checkSetWithoutGet || checkGetWithoutSet) {\n                    checkLonelySetGet(node);\n                }\n            }\n        };\n    }\n};\n","array-bracket-newline.js":"/**\n * @fileoverview Rule to enforce linebreaks after open and before close array brackets\n * @author Jan Peer StÃ¶cklmair <https://github.com/JPeer264>\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce linebreaks after opening and before closing array brackets\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        fixable: \"whitespace\",\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            multiline: {\n                                type: \"boolean\"\n                            },\n                            minItems: {\n                                type: [\"integer\", \"null\"],\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Normalizes a given option value.\n         *\n         * @param {string|Object|undefined} option - An option value to parse.\n         * @returns {{multiline: boolean, minItems: number}} Normalized option object.\n         */\n        function normalizeOptionValue(option) {\n            let multiline = false;\n            let minItems = 0;\n\n            if (option) {\n                if (option === \"always\" || option.minItems === 0) {\n                    minItems = 0;\n                } else if (option === \"never\") {\n                    minItems = Number.POSITIVE_INFINITY;\n                } else {\n                    multiline = Boolean(option.multiline);\n                    minItems = option.minItems || Number.POSITIVE_INFINITY;\n                }\n            } else {\n                multiline = true;\n                minItems = Number.POSITIVE_INFINITY;\n            }\n\n            return { multiline, minItems };\n        }\n\n        /**\n         * Normalizes a given option value.\n         *\n         * @param {string|Object|undefined} options - An option value to parse.\n         * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.\n         */\n        function normalizeOptions(options) {\n            const value = normalizeOptionValue(options);\n\n            return { ArrayExpression: value, ArrayPattern: value };\n        }\n\n        /**\n        * Reports that there shouldn't be a linebreak after the first token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @returns {void}\n        */\n        function reportNoBeginningLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                message: \"There should be no linebreak after '['.\",\n                fix(fixer) {\n                    const nextToken = sourceCode.getTokenAfter(token, { includeComments: true });\n\n                    if (astUtils.isCommentToken(nextToken)) {\n                        return null;\n                    }\n\n                    return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                }\n            });\n        }\n\n        /**\n        * Reports that there shouldn't be a linebreak before the last token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @returns {void}\n        */\n        function reportNoEndingLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                message: \"There should be no linebreak before ']'.\",\n                fix(fixer) {\n                    const previousToken = sourceCode.getTokenBefore(token, { includeComments: true });\n\n                    if (astUtils.isCommentToken(previousToken)) {\n                        return null;\n                    }\n\n                    return fixer.removeRange([previousToken.range[1], token.range[0]]);\n                }\n            });\n        }\n\n        /**\n        * Reports that there should be a linebreak after the first token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @returns {void}\n        */\n        function reportRequiredBeginningLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                message: \"A linebreak is required after '['.\",\n                fix(fixer) {\n                    return fixer.insertTextAfter(token, \"\\n\");\n                }\n            });\n        }\n\n        /**\n        * Reports that there should be a linebreak before the last token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @returns {void}\n        */\n        function reportRequiredEndingLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                message: \"A linebreak is required before ']'.\",\n                fix(fixer) {\n                    return fixer.insertTextBefore(token, \"\\n\");\n                }\n            });\n        }\n\n        /**\n         * Reports a given node if it violated this rule.\n         *\n         * @param {ASTNode} node - A node to check. This is an ObjectExpression node or an ObjectPattern node.\n         * @param {{multiline: boolean, minItems: number}} options - An option object.\n         * @returns {void}\n         */\n        function check(node) {\n            const elements = node.elements;\n            const normalizedOptions = normalizeOptions(context.options[0]);\n            const options = normalizedOptions[node.type];\n            const openBracket = sourceCode.getFirstToken(node);\n            const closeBracket = sourceCode.getLastToken(node);\n            const firstIncComment = sourceCode.getTokenAfter(openBracket, { includeComments: true });\n            const lastIncComment = sourceCode.getTokenBefore(closeBracket, { includeComments: true });\n            const first = sourceCode.getTokenAfter(openBracket);\n            const last = sourceCode.getTokenBefore(closeBracket);\n\n            const needsLinebreaks = (\n                elements.length >= options.minItems ||\n                (\n                    options.multiline &&\n                    elements.length > 0 &&\n                    firstIncComment.loc.start.line !== lastIncComment.loc.end.line\n                )\n            );\n\n            /*\n             * Use tokens or comments to check multiline or not.\n             * But use only tokens to check whether linebreaks are needed.\n             * This allows:\n             *     var arr = [ // eslint-disable-line foo\n             *         'a'\n             *     ]\n             */\n\n            if (needsLinebreaks) {\n                if (astUtils.isTokenOnSameLine(openBracket, first)) {\n                    reportRequiredBeginningLinebreak(node, openBracket);\n                }\n                if (astUtils.isTokenOnSameLine(last, closeBracket)) {\n                    reportRequiredEndingLinebreak(node, closeBracket);\n                }\n            } else {\n                if (!astUtils.isTokenOnSameLine(openBracket, first)) {\n                    reportNoBeginningLinebreak(node, openBracket);\n                }\n                if (!astUtils.isTokenOnSameLine(last, closeBracket)) {\n                    reportNoEndingLinebreak(node, closeBracket);\n                }\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            ArrayPattern: check,\n            ArrayExpression: check\n        };\n    }\n};\n","array-bracket-spacing.js":"/**\n * @fileoverview Disallows or enforces spaces inside of array brackets.\n * @author Jamund Ferguson\n */\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing inside array brackets\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        fixable: \"whitespace\",\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    singleValue: {\n                        type: \"boolean\"\n                    },\n                    objectsInArrays: {\n                        type: \"boolean\"\n                    },\n                    arraysInArrays: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n    create(context) {\n        const spaced = context.options[0] === \"always\",\n            sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether an option is set, relative to the spacing option.\n         * If spaced is \"always\", then check whether option is set to false.\n         * If spaced is \"never\", then check whether option is set to true.\n         * @param {Object} option - The option to exclude.\n         * @returns {boolean} Whether or not the property is excluded.\n         */\n        function isOptionSet(option) {\n            return context.options[1] ? context.options[1][option] === !spaced : false;\n        }\n\n        const options = {\n            spaced,\n            singleElementException: isOptionSet(\"singleValue\"),\n            objectsInArraysException: isOptionSet(\"objectsInArrays\"),\n            arraysInArraysException: isOptionSet(\"arraysInArrays\")\n        };\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n        * Reports that there shouldn't be a space after the first token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @returns {void}\n        */\n        function reportNoBeginningSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"There should be no space after '{{tokenValue}}'.\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    const nextToken = sourceCode.getTokenAfter(token);\n\n                    return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                }\n            });\n        }\n\n        /**\n        * Reports that there shouldn't be a space before the last token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @returns {void}\n        */\n        function reportNoEndingSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"There should be no space before '{{tokenValue}}'.\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    const previousToken = sourceCode.getTokenBefore(token);\n\n                    return fixer.removeRange([previousToken.range[1], token.range[0]]);\n                }\n            });\n        }\n\n        /**\n        * Reports that there should be a space after the first token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @returns {void}\n        */\n        function reportRequiredBeginningSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"A space is required after '{{tokenValue}}'.\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    return fixer.insertTextAfter(token, \" \");\n                }\n            });\n        }\n\n        /**\n        * Reports that there should be a space before the last token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @returns {void}\n        */\n        function reportRequiredEndingSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"A space is required before '{{tokenValue}}'.\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    return fixer.insertTextBefore(token, \" \");\n                }\n            });\n        }\n\n        /**\n        * Determines if a node is an object type\n        * @param {ASTNode} node - The node to check.\n        * @returns {boolean} Whether or not the node is an object type.\n        */\n        function isObjectType(node) {\n            return node && (node.type === \"ObjectExpression\" || node.type === \"ObjectPattern\");\n        }\n\n        /**\n        * Determines if a node is an array type\n        * @param {ASTNode} node - The node to check.\n        * @returns {boolean} Whether or not the node is an array type.\n        */\n        function isArrayType(node) {\n            return node && (node.type === \"ArrayExpression\" || node.type === \"ArrayPattern\");\n        }\n\n        /**\n         * Validates the spacing around array brackets\n         * @param {ASTNode} node - The node we're checking for spacing\n         * @returns {void}\n         */\n        function validateArraySpacing(node) {\n            if (options.spaced && node.elements.length === 0) {\n                return;\n            }\n\n            const first = sourceCode.getFirstToken(node),\n                second = sourceCode.getFirstToken(node, 1),\n                last = node.typeAnnotation\n                    ? sourceCode.getTokenBefore(node.typeAnnotation)\n                    : sourceCode.getLastToken(node),\n                penultimate = sourceCode.getTokenBefore(last),\n                firstElement = node.elements[0],\n                lastElement = node.elements[node.elements.length - 1];\n\n            const openingBracketMustBeSpaced =\n                options.objectsInArraysException && isObjectType(firstElement) ||\n                options.arraysInArraysException && isArrayType(firstElement) ||\n                options.singleElementException && node.elements.length === 1\n                    ? !options.spaced : options.spaced;\n\n            const closingBracketMustBeSpaced =\n                options.objectsInArraysException && isObjectType(lastElement) ||\n                options.arraysInArraysException && isArrayType(lastElement) ||\n                options.singleElementException && node.elements.length === 1\n                    ? !options.spaced : options.spaced;\n\n            if (astUtils.isTokenOnSameLine(first, second)) {\n                if (openingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(first, second)) {\n                    reportRequiredBeginningSpace(node, first);\n                }\n                if (!openingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(first, second)) {\n                    reportNoBeginningSpace(node, first);\n                }\n            }\n\n            if (first !== penultimate && astUtils.isTokenOnSameLine(penultimate, last)) {\n                if (closingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(penultimate, last)) {\n                    reportRequiredEndingSpace(node, last);\n                }\n                if (!closingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(penultimate, last)) {\n                    reportNoEndingSpace(node, last);\n                }\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ArrayPattern: validateArraySpacing,\n            ArrayExpression: validateArraySpacing\n        };\n    }\n};\n","array-callback-return.js":"/**\n * @fileoverview Rule to enforce return statements in callbacks of array's methods\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/;\nconst TARGET_METHODS = /^(?:every|filter|find(?:Index)?|map|reduce(?:Right)?|some|sort)$/;\n\n/**\n * Checks a given code path segment is reachable.\n *\n * @param {CodePathSegment} segment - A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Gets a readable location.\n *\n * - FunctionExpression -> the function name or `function` keyword.\n * - ArrowFunctionExpression -> `=>` token.\n *\n * @param {ASTNode} node - A function node to get.\n * @param {SourceCode} sourceCode - A source code to get tokens.\n * @returns {ASTNode|Token} The node or the token of a location.\n */\nfunction getLocation(node, sourceCode) {\n    if (node.type === \"ArrowFunctionExpression\") {\n        return sourceCode.getTokenBefore(node.body);\n    }\n    return node.id || node;\n}\n\n/**\n * Checks a given node is a MemberExpression node which has the specified name's\n * property.\n *\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is a MemberExpression node which has\n *      the specified name's property\n */\nfunction isTargetMethod(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        TARGET_METHODS.test(astUtils.getStaticPropertyName(node) || \"\")\n    );\n}\n\n/**\n * Checks whether or not a given node is a function expression which is the\n * callback of an array method.\n *\n * @param {ASTNode} node - A node to check. This is one of\n *      FunctionExpression or ArrowFunctionExpression.\n * @returns {boolean} `true` if the node is the callback of an array method.\n */\nfunction isCallbackOfArrayMethod(node) {\n    while (node) {\n        const parent = node.parent;\n\n        switch (parent.type) {\n\n            /*\n             * Looks up the destination. e.g.,\n             * foo.every(nativeFoo || function foo() { ... });\n             */\n            case \"LogicalExpression\":\n            case \"ConditionalExpression\":\n                node = parent;\n                break;\n\n            // If the upper function is IIFE, checks the destination of the return value.\n            // e.g.\n            //   foo.every((function() {\n            //     // setup...\n            //     return function callback() { ... };\n            //   })());\n            case \"ReturnStatement\": {\n                const func = astUtils.getUpperFunction(parent);\n\n                if (func === null || !astUtils.isCallee(func)) {\n                    return false;\n                }\n                node = func.parent;\n                break;\n            }\n\n            // e.g.\n            //   Array.from([], function() {});\n            //   list.every(function() {});\n            case \"CallExpression\":\n                if (astUtils.isArrayFromMethod(parent.callee)) {\n                    return (\n                        parent.arguments.length >= 2 &&\n                        parent.arguments[1] === node\n                    );\n                }\n                if (isTargetMethod(parent.callee)) {\n                    return (\n                        parent.arguments.length >= 1 &&\n                        parent.arguments[0] === node\n                    );\n                }\n                return false;\n\n            // Otherwise this node is not target.\n            default:\n                return false;\n        }\n    }\n\n    /* istanbul ignore next: unreachable */\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce `return` statements in callbacks of array methods\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        let funcInfo = {\n            upper: null,\n            codePath: null,\n            hasReturn: false,\n            shouldCheck: false,\n            node: null\n        };\n\n        /**\n         * Checks whether or not the last code path segment is reachable.\n         * Then reports this function if the segment is reachable.\n         *\n         * If the last code path segment is reachable, there are paths which are not\n         * returned or thrown.\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {void}\n         */\n        function checkLastSegment(node) {\n            if (funcInfo.shouldCheck &&\n                funcInfo.codePath.currentSegments.some(isReachable)\n            ) {\n                context.report({\n                    node,\n                    loc: getLocation(node, context.getSourceCode()).loc.start,\n                    message: funcInfo.hasReturn\n                        ? \"Expected to return a value at the end of {{name}}.\"\n                        : \"Expected to return a value in {{name}}.\",\n                    data: {\n                        name: astUtils.getFunctionNameWithKind(funcInfo.node)\n                    }\n                });\n            }\n        }\n\n        return {\n\n            // Stacks this function's information.\n            onCodePathStart(codePath, node) {\n                funcInfo = {\n                    upper: funcInfo,\n                    codePath,\n                    hasReturn: false,\n                    shouldCheck:\n                        TARGET_NODE_TYPE.test(node.type) &&\n                        node.body.type === \"BlockStatement\" &&\n                        isCallbackOfArrayMethod(node) &&\n                        !node.async &&\n                        !node.generator,\n                    node\n                };\n            },\n\n            // Pops this function's information.\n            onCodePathEnd() {\n                funcInfo = funcInfo.upper;\n            },\n\n            // Checks the return statement is valid.\n            ReturnStatement(node) {\n                if (funcInfo.shouldCheck) {\n                    funcInfo.hasReturn = true;\n\n                    if (!node.argument) {\n                        context.report({\n                            node,\n                            message: \"{{name}} expected a return value.\",\n                            data: {\n                                name: lodash.upperFirst(astUtils.getFunctionNameWithKind(funcInfo.node))\n                            }\n                        });\n                    }\n                }\n            },\n\n            // Reports a given function if the last path is reachable.\n            \"FunctionExpression:exit\": checkLastSegment,\n            \"ArrowFunctionExpression:exit\": checkLastSegment\n        };\n    }\n};\n","array-element-newline.js":"/**\n * @fileoverview Rule to enforce line breaks after each array element\n * @author Jan Peer StÃ¶cklmair <https://github.com/JPeer264>\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce line breaks after each array element\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        fixable: \"whitespace\",\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            multiline: {\n                                type: \"boolean\"\n                            },\n                            minItems: {\n                                type: [\"integer\", \"null\"],\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Normalizes a given option value.\n         *\n         * @param {string|Object|undefined} option - An option value to parse.\n         * @returns {{multiline: boolean, minItems: number}} Normalized option object.\n         */\n        function normalizeOptionValue(option) {\n            let multiline = false;\n            let minItems;\n\n            option = option || \"always\";\n\n            if (option === \"always\" || option.minItems === 0) {\n                minItems = 0;\n            } else if (option === \"never\") {\n                minItems = Number.POSITIVE_INFINITY;\n            } else {\n                multiline = Boolean(option.multiline);\n                minItems = option.minItems || Number.POSITIVE_INFINITY;\n            }\n\n            return { multiline, minItems };\n        }\n\n        /**\n         * Normalizes a given option value.\n         *\n         * @param {string|Object|undefined} options - An option value to parse.\n         * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.\n         */\n        function normalizeOptions(options) {\n            const value = normalizeOptionValue(options);\n\n            return { ArrayExpression: value, ArrayPattern: value };\n        }\n\n        /**\n        * Reports that there shouldn't be a line break after the first token\n        * @param {Token} token - The token to use for the report.\n        * @returns {void}\n        */\n        function reportNoLineBreak(token) {\n            const tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true });\n\n            context.report({\n                loc: {\n                    start: tokenBefore.loc.end,\n                    end: token.loc.start\n                },\n                message: \"There should be no linebreak here.\",\n                fix(fixer) {\n                    if (astUtils.isCommentToken(tokenBefore)) {\n                        return null;\n                    }\n\n                    if (!astUtils.isTokenOnSameLine(tokenBefore, token)) {\n                        return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \" \");\n                    }\n\n                    /*\n                     * This will check if the comma is on the same line as the next element\n                     * Following array:\n                     * [\n                     *     1\n                     *     , 2\n                     *     , 3\n                     * ]\n                     *\n                     * will be fixed to:\n                     * [\n                     *     1, 2, 3\n                     * ]\n                     */\n                    const twoTokensBefore = sourceCode.getTokenBefore(tokenBefore, { includeComments: true });\n\n                    if (astUtils.isCommentToken(twoTokensBefore)) {\n                        return null;\n                    }\n\n                    return fixer.replaceTextRange([twoTokensBefore.range[1], tokenBefore.range[0]], \"\");\n\n                }\n            });\n        }\n\n        /**\n        * Reports that there should be a line break after the first token\n        * @param {Token} token - The token to use for the report.\n        * @returns {void}\n        */\n        function reportRequiredLineBreak(token) {\n            const tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true });\n\n            context.report({\n                loc: {\n                    start: tokenBefore.loc.end,\n                    end: token.loc.start\n                },\n                message: \"There should be a linebreak after this element.\",\n                fix(fixer) {\n                    return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \"\\n\");\n                }\n            });\n        }\n\n        /**\n         * Reports a given node if it violated this rule.\n         *\n         * @param {ASTNode} node - A node to check. This is an ObjectExpression node or an ObjectPattern node.\n         * @param {{multiline: boolean, minItems: number}} options - An option object.\n         * @returns {void}\n         */\n        function check(node) {\n            const elements = node.elements;\n            const normalizedOptions = normalizeOptions(context.options[0]);\n            const options = normalizedOptions[node.type];\n\n            let elementBreak = false;\n\n            /*\n             * MULTILINE: true\n             * loop through every element and check\n             * if at least one element has linebreaks inside\n             * this ensures that following is not valid (due to elements are on the same line):\n             *\n             * [\n             *      1,\n             *      2,\n             *      3\n             * ]\n             */\n            if (options.multiline) {\n                elementBreak = elements\n                    .filter(element => element !== null)\n                    .some(element => element.loc.start.line !== element.loc.end.line);\n            }\n\n            const needsLinebreaks = (\n                elements.length >= options.minItems ||\n                (\n                    options.multiline &&\n                    elementBreak\n                )\n            );\n\n            elements.forEach((element, i) => {\n                const previousElement = elements[i - 1];\n\n                if (i === 0 || element === null || previousElement === null) {\n                    return;\n                }\n\n                const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);\n                const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);\n                const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);\n\n                if (needsLinebreaks) {\n                    if (astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {\n                        reportRequiredLineBreak(firstTokenOfCurrentElement);\n                    }\n                } else {\n                    if (!astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {\n                        reportNoLineBreak(firstTokenOfCurrentElement);\n                    }\n                }\n            });\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            ArrayPattern: check,\n            ArrayExpression: check\n        };\n    }\n};\n","arrow-body-style.js":"/**\n * @fileoverview Rule to require braces in arrow function body.\n * @author Alberto RodrÃ­guez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require braces around arrow function bodies\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"never\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"as-needed\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                requireReturnForObjectLiteral: { type: \"boolean\" }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const options = context.options;\n        const always = options[0] === \"always\";\n        const asNeeded = !options[0] || options[0] === \"as-needed\";\n        const never = options[0] === \"never\";\n        const requireReturnForObjectLiteral = options[1] && options[1].requireReturnForObjectLiteral;\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Checks whether the given node has ASI problem or not.\n         * @param {Token} token The token to check.\n         * @returns {boolean} `true` if it changes semantics if `;` or `}` followed by the token are removed.\n         */\n        function hasASIProblem(token) {\n            return token && token.type === \"Punctuator\" && /^[([/`+-]/.test(token.value);\n        }\n\n        /**\n         * Gets the closing parenthesis which is the pair of the given opening parenthesis.\n         * @param {Token} token The opening parenthesis token to get.\n         * @returns {Token} The found closing parenthesis token.\n         */\n        function findClosingParen(token) {\n            let node = sourceCode.getNodeByRangeIndex(token.range[1]);\n\n            while (!astUtils.isParenthesised(sourceCode, node)) {\n                node = node.parent;\n            }\n            return sourceCode.getTokenAfter(node);\n        }\n\n        /**\n         * Determines whether a arrow function body needs braces\n         * @param {ASTNode} node The arrow function node.\n         * @returns {void}\n         */\n        function validate(node) {\n            const arrowBody = node.body;\n\n            if (arrowBody.type === \"BlockStatement\") {\n                const blockBody = arrowBody.body;\n\n                if (blockBody.length !== 1 && !never) {\n                    return;\n                }\n\n                if (asNeeded && requireReturnForObjectLiteral && blockBody[0].type === \"ReturnStatement\" &&\n                    blockBody[0].argument && blockBody[0].argument.type === \"ObjectExpression\") {\n                    return;\n                }\n\n                if (never || asNeeded && blockBody[0].type === \"ReturnStatement\") {\n                    context.report({\n                        node,\n                        loc: arrowBody.loc.start,\n                        message: \"Unexpected block statement surrounding arrow body.\",\n                        fix(fixer) {\n                            const fixes = [];\n\n                            if (blockBody.length !== 1 ||\n                                blockBody[0].type !== \"ReturnStatement\" ||\n                                !blockBody[0].argument ||\n                                hasASIProblem(sourceCode.getTokenAfter(arrowBody))\n                            ) {\n                                return fixes;\n                            }\n\n                            const openingBrace = sourceCode.getFirstToken(arrowBody);\n                            const closingBrace = sourceCode.getLastToken(arrowBody);\n                            const firstValueToken = sourceCode.getFirstToken(blockBody[0], 1);\n                            const lastValueToken = sourceCode.getLastToken(blockBody[0]);\n                            const commentsExist =\n                                sourceCode.commentsExistBetween(openingBrace, firstValueToken) ||\n                                sourceCode.commentsExistBetween(lastValueToken, closingBrace);\n\n                            // Remove tokens around the return value.\n                            // If comments don't exist, remove extra spaces as well.\n                            if (commentsExist) {\n                                fixes.push(\n                                    fixer.remove(openingBrace),\n                                    fixer.remove(closingBrace),\n                                    fixer.remove(sourceCode.getTokenAfter(openingBrace)) // return keyword\n                                );\n                            } else {\n                                fixes.push(\n                                    fixer.removeRange([openingBrace.range[0], firstValueToken.range[0]]),\n                                    fixer.removeRange([lastValueToken.range[1], closingBrace.range[1]])\n                                );\n                            }\n\n                            // If the first token of the reutrn value is `{`,\n                            // enclose the return value by parentheses to avoid syntax error.\n                            if (astUtils.isOpeningBraceToken(firstValueToken)) {\n                                fixes.push(\n                                    fixer.insertTextBefore(firstValueToken, \"(\"),\n                                    fixer.insertTextAfter(lastValueToken, \")\")\n                                );\n                            }\n\n                            // If the last token of the return statement is semicolon, remove it.\n                            // Non-block arrow body is an expression, not a statement.\n                            if (astUtils.isSemicolonToken(lastValueToken)) {\n                                fixes.push(fixer.remove(lastValueToken));\n                            }\n\n                            return fixes;\n                        }\n                    });\n                }\n            } else {\n                if (always || (asNeeded && requireReturnForObjectLiteral && arrowBody.type === \"ObjectExpression\")) {\n                    context.report({\n                        node,\n                        loc: arrowBody.loc.start,\n                        message: \"Expected block statement surrounding arrow body.\",\n                        fix(fixer) {\n                            const fixes = [];\n                            const arrowToken = sourceCode.getTokenBefore(arrowBody, astUtils.isArrowToken);\n                            const firstBodyToken = sourceCode.getTokenAfter(arrowToken);\n                            const lastBodyToken = sourceCode.getLastToken(node);\n                            const isParenthesisedObjectLiteral =\n                                astUtils.isOpeningParenToken(firstBodyToken) &&\n                                astUtils.isOpeningBraceToken(sourceCode.getTokenAfter(firstBodyToken));\n\n                            // Wrap the value by a block and a return statement.\n                            fixes.push(\n                                fixer.insertTextBefore(firstBodyToken, \"{return \"),\n                                fixer.insertTextAfter(lastBodyToken, \"}\")\n                            );\n\n                            // If the value is object literal, remove parentheses which were forced by syntax.\n                            if (isParenthesisedObjectLiteral) {\n                                fixes.push(\n                                    fixer.remove(firstBodyToken),\n                                    fixer.remove(findClosingParen(firstBodyToken))\n                                );\n                            }\n\n                            return fixes;\n                        }\n                    });\n                }\n            }\n        }\n\n        return {\n            \"ArrowFunctionExpression:exit\": validate\n        };\n    }\n};\n","arrow-parens.js":"/**\n * @fileoverview Rule to require parens in arrow function arguments.\n * @author Jxck\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require parentheses around arrow function arguments\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                enum: [\"always\", \"as-needed\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    requireForBlockBody: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const message = \"Expected parentheses around arrow function argument.\";\n        const asNeededMessage = \"Unexpected parentheses around single function argument.\";\n        const asNeeded = context.options[0] === \"as-needed\";\n        const requireForBlockBodyMessage = \"Unexpected parentheses around single function argument having a body with no curly braces\";\n        const requireForBlockBodyNoParensMessage = \"Expected parentheses around arrow function argument having a body with curly braces.\";\n        const requireForBlockBody = asNeeded && context.options[1] && context.options[1].requireForBlockBody === true;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether a arrow function argument end with `)`\n         * @param {ASTNode} node The arrow function node.\n         * @returns {void}\n         */\n        function parens(node) {\n            const isAsync = node.async;\n            const firstTokenOfParam = sourceCode.getFirstToken(node, isAsync ? 1 : 0);\n\n            /**\n             * Remove the parenthesis around a parameter\n             * @param {Fixer} fixer Fixer\n             * @returns {string} fixed parameter\n             */\n            function fixParamsWithParenthesis(fixer) {\n                const paramToken = sourceCode.getTokenAfter(firstTokenOfParam);\n\n                // ES8 allows Trailing commas in function parameter lists and calls\n                // https://github.com/eslint/eslint/issues/8834\n                const closingParenToken = sourceCode.getTokenAfter(paramToken, astUtils.isClosingParenToken);\n                const asyncToken = isAsync ? sourceCode.getTokenBefore(firstTokenOfParam) : null;\n                const shouldAddSpaceForAsync = asyncToken && (asyncToken.range[1] === firstTokenOfParam.range[0]);\n\n                return fixer.replaceTextRange([\n                    firstTokenOfParam.range[0],\n                    closingParenToken.range[1]\n                ], `${shouldAddSpaceForAsync ? \" \" : \"\"}${paramToken.value}`);\n            }\n\n            // \"as-needed\", { \"requireForBlockBody\": true }: x => x\n            if (\n                requireForBlockBody &&\n                node.params.length === 1 &&\n                node.params[0].type === \"Identifier\" &&\n                !node.params[0].typeAnnotation &&\n                node.body.type !== \"BlockStatement\" &&\n                !node.returnType\n            ) {\n                if (astUtils.isOpeningParenToken(firstTokenOfParam)) {\n                    context.report({\n                        node,\n                        message: requireForBlockBodyMessage,\n                        fix: fixParamsWithParenthesis\n                    });\n                }\n                return;\n            }\n\n            if (\n                requireForBlockBody &&\n                node.body.type === \"BlockStatement\"\n            ) {\n                if (!astUtils.isOpeningParenToken(firstTokenOfParam)) {\n                    context.report({\n                        node,\n                        message: requireForBlockBodyNoParensMessage,\n                        fix(fixer) {\n                            return fixer.replaceText(firstTokenOfParam, `(${firstTokenOfParam.value})`);\n                        }\n                    });\n                }\n                return;\n            }\n\n            // \"as-needed\": x => x\n            if (asNeeded &&\n                node.params.length === 1 &&\n                node.params[0].type === \"Identifier\" &&\n                !node.params[0].typeAnnotation &&\n                !node.returnType\n            ) {\n                if (astUtils.isOpeningParenToken(firstTokenOfParam)) {\n                    context.report({\n                        node,\n                        message: asNeededMessage,\n                        fix: fixParamsWithParenthesis\n                    });\n                }\n                return;\n            }\n\n            if (firstTokenOfParam.type === \"Identifier\") {\n                const after = sourceCode.getTokenAfter(firstTokenOfParam);\n\n                // (x) => x\n                if (after.value !== \")\") {\n                    context.report({\n                        node,\n                        message,\n                        fix(fixer) {\n                            return fixer.replaceText(firstTokenOfParam, `(${firstTokenOfParam.value})`);\n                        }\n                    });\n                }\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: parens\n        };\n    }\n};\n","arrow-spacing.js":"/**\n * @fileoverview Rule to define spacing before/after arrow function's arrow.\n * @author Jxck\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing before and after the arrow in arrow functions\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: {\n                        type: \"boolean\"\n                    },\n                    after: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        // merge rules with default\n        const rule = { before: true, after: true },\n            option = context.options[0] || {};\n\n        rule.before = option.before !== false;\n        rule.after = option.after !== false;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Get tokens of arrow(`=>`) and before/after arrow.\n         * @param {ASTNode} node The arrow function node.\n         * @returns {Object} Tokens of arrow and before/after arrow.\n         */\n        function getTokens(node) {\n            const arrow = sourceCode.getTokenBefore(node.body, astUtils.isArrowToken);\n\n            return {\n                before: sourceCode.getTokenBefore(arrow),\n                arrow,\n                after: sourceCode.getTokenAfter(arrow)\n            };\n        }\n\n        /**\n         * Count spaces before/after arrow(`=>`) token.\n         * @param {Object} tokens Tokens before/after arrow.\n         * @returns {Object} count of space before/after arrow.\n         */\n        function countSpaces(tokens) {\n            const before = tokens.arrow.range[0] - tokens.before.range[1];\n            const after = tokens.after.range[0] - tokens.arrow.range[1];\n\n            return { before, after };\n        }\n\n        /**\n         * Determines whether space(s) before after arrow(`=>`) is satisfy rule.\n         * if before/after value is `true`, there should be space(s).\n         * if before/after value is `false`, there should be no space.\n         * @param {ASTNode} node The arrow function node.\n         * @returns {void}\n         */\n        function spaces(node) {\n            const tokens = getTokens(node);\n            const countSpace = countSpaces(tokens);\n\n            if (rule.before) {\n\n                // should be space(s) before arrow\n                if (countSpace.before === 0) {\n                    context.report({\n                        node: tokens.before,\n                        message: \"Missing space before =>.\",\n                        fix(fixer) {\n                            return fixer.insertTextBefore(tokens.arrow, \" \");\n                        }\n                    });\n                }\n            } else {\n\n                // should be no space before arrow\n                if (countSpace.before > 0) {\n                    context.report({\n                        node: tokens.before,\n                        message: \"Unexpected space before =>.\",\n                        fix(fixer) {\n                            return fixer.removeRange([tokens.before.range[1], tokens.arrow.range[0]]);\n                        }\n                    });\n                }\n            }\n\n            if (rule.after) {\n\n                // should be space(s) after arrow\n                if (countSpace.after === 0) {\n                    context.report({\n                        node: tokens.after,\n                        message: \"Missing space after =>.\",\n                        fix(fixer) {\n                            return fixer.insertTextAfter(tokens.arrow, \" \");\n                        }\n                    });\n                }\n            } else {\n\n                // should be no space after arrow\n                if (countSpace.after > 0) {\n                    context.report({\n                        node: tokens.after,\n                        message: \"Unexpected space after =>.\",\n                        fix(fixer) {\n                            return fixer.removeRange([tokens.arrow.range[1], tokens.after.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: spaces\n        };\n    }\n};\n","block-scoped-var.js":"/**\n * @fileoverview Rule to check for \"block scoped\" variables by binding context\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce the use of variables within the scope they are defined\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        let stack = [];\n\n        /**\n         * Makes a block scope.\n         * @param {ASTNode} node - A node of a scope.\n         * @returns {void}\n         */\n        function enterScope(node) {\n            stack.push(node.range);\n        }\n\n        /**\n         * Pops the last block scope.\n         * @returns {void}\n         */\n        function exitScope() {\n            stack.pop();\n        }\n\n        /**\n         * Reports a given reference.\n         * @param {eslint-scope.Reference} reference - A reference to report.\n         * @returns {void}\n         */\n        function report(reference) {\n            const identifier = reference.identifier;\n\n            context.report({ node: identifier, message: \"'{{name}}' used outside of binding context.\", data: { name: identifier.name } });\n        }\n\n        /**\n         * Finds and reports references which are outside of valid scopes.\n         * @param {ASTNode} node - A node to get variables.\n         * @returns {void}\n         */\n        function checkForVariables(node) {\n            if (node.kind !== \"var\") {\n                return;\n            }\n\n            // Defines a predicate to check whether or not a given reference is outside of valid scope.\n            const scopeRange = stack[stack.length - 1];\n\n            /**\n             * Check if a reference is out of scope\n             * @param {ASTNode} reference node to examine\n             * @returns {boolean} True is its outside the scope\n             * @private\n             */\n            function isOutsideOfScope(reference) {\n                const idRange = reference.identifier.range;\n\n                return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];\n            }\n\n            // Gets declared variables, and checks its references.\n            const variables = context.getDeclaredVariables(node);\n\n            for (let i = 0; i < variables.length; ++i) {\n\n                // Reports.\n                variables[i]\n                    .references\n                    .filter(isOutsideOfScope)\n                    .forEach(report);\n            }\n        }\n\n        return {\n            Program(node) {\n                stack = [node.range];\n            },\n\n            // Manages scopes.\n            BlockStatement: enterScope,\n            \"BlockStatement:exit\": exitScope,\n            ForStatement: enterScope,\n            \"ForStatement:exit\": exitScope,\n            ForInStatement: enterScope,\n            \"ForInStatement:exit\": exitScope,\n            ForOfStatement: enterScope,\n            \"ForOfStatement:exit\": exitScope,\n            SwitchStatement: enterScope,\n            \"SwitchStatement:exit\": exitScope,\n            CatchClause: enterScope,\n            \"CatchClause:exit\": exitScope,\n\n            // Finds and reports references which are outside of valid scope.\n            VariableDeclaration: checkForVariables\n        };\n\n    }\n};\n","block-spacing.js":"/**\n * @fileoverview A rule to disallow or enforce spaces inside of single line blocks.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst util = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing inside single-line blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            { enum: [\"always\", \"never\"] }\n        ]\n    },\n\n    create(context) {\n        const always = (context.options[0] !== \"never\"),\n            message = always ? \"Requires a space\" : \"Unexpected space(s)\",\n            sourceCode = context.getSourceCode();\n\n        /**\n         * Gets the open brace token from a given node.\n         * @param {ASTNode} node - A BlockStatement/SwitchStatement node to get.\n         * @returns {Token} The token of the open brace.\n         */\n        function getOpenBrace(node) {\n            if (node.type === \"SwitchStatement\") {\n                if (node.cases.length > 0) {\n                    return sourceCode.getTokenBefore(node.cases[0]);\n                }\n                return sourceCode.getLastToken(node, 1);\n            }\n            return sourceCode.getFirstToken(node);\n        }\n\n        /**\n         * Checks whether or not:\n         *   - given tokens are on same line.\n         *   - there is/isn't a space between given tokens.\n         * @param {Token} left - A token to check.\n         * @param {Token} right - The token which is next to `left`.\n         * @returns {boolean}\n         *    When the option is `\"always\"`, `true` if there are one or more spaces between given tokens.\n         *    When the option is `\"never\"`, `true` if there are not any spaces between given tokens.\n         *    If given tokens are not on same line, it's always `true`.\n         */\n        function isValid(left, right) {\n            return (\n                !util.isTokenOnSameLine(left, right) ||\n                sourceCode.isSpaceBetweenTokens(left, right) === always\n            );\n        }\n\n        /**\n         * Reports invalid spacing style inside braces.\n         * @param {ASTNode} node - A BlockStatement/SwitchStatement node to get.\n         * @returns {void}\n         */\n        function checkSpacingInsideBraces(node) {\n\n            // Gets braces and the first/last token of content.\n            const openBrace = getOpenBrace(node);\n            const closeBrace = sourceCode.getLastToken(node);\n            const firstToken = sourceCode.getTokenAfter(openBrace, { includeComments: true });\n            const lastToken = sourceCode.getTokenBefore(closeBrace, { includeComments: true });\n\n            // Skip if the node is invalid or empty.\n            if (openBrace.type !== \"Punctuator\" ||\n                openBrace.value !== \"{\" ||\n                closeBrace.type !== \"Punctuator\" ||\n                closeBrace.value !== \"}\" ||\n                firstToken === closeBrace\n            ) {\n                return;\n            }\n\n            // Skip line comments for option never\n            if (!always && firstToken.type === \"Line\") {\n                return;\n            }\n\n            // Check.\n            if (!isValid(openBrace, firstToken)) {\n                context.report({\n                    node,\n                    loc: openBrace.loc.start,\n                    message: \"{{message}} after '{'.\",\n                    data: {\n                        message\n                    },\n                    fix(fixer) {\n                        if (always) {\n                            return fixer.insertTextBefore(firstToken, \" \");\n                        }\n\n                        return fixer.removeRange([openBrace.range[1], firstToken.range[0]]);\n                    }\n                });\n            }\n            if (!isValid(lastToken, closeBrace)) {\n                context.report({\n                    node,\n                    loc: closeBrace.loc.start,\n                    message: \"{{message}} before '}'.\",\n                    data: {\n                        message\n                    },\n                    fix(fixer) {\n                        if (always) {\n                            return fixer.insertTextAfter(lastToken, \" \");\n                        }\n\n                        return fixer.removeRange([lastToken.range[1], closeBrace.range[0]]);\n                    }\n                });\n            }\n        }\n\n        return {\n            BlockStatement: checkSpacingInsideBraces,\n            SwitchStatement: checkSpacingInsideBraces\n        };\n    }\n};\n","brace-style.js":"/**\n * @fileoverview Rule to flag block statements that do not use the one true brace style\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent brace style for blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"1tbs\", \"stroustrup\", \"allman\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    allowSingleLine: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"whitespace\"\n    },\n\n    create(context) {\n        const style = context.options[0] || \"1tbs\",\n            params = context.options[1] || {},\n            sourceCode = context.getSourceCode();\n\n        const OPEN_MESSAGE = \"Opening curly brace does not appear on the same line as controlling statement.\",\n            OPEN_MESSAGE_ALLMAN = \"Opening curly brace appears on the same line as controlling statement.\",\n            BODY_MESSAGE = \"Statement inside of curly braces should be on next line.\",\n            CLOSE_MESSAGE = \"Closing curly brace does not appear on the same line as the subsequent block.\",\n            CLOSE_MESSAGE_SINGLE = \"Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.\",\n            CLOSE_MESSAGE_STROUSTRUP_ALLMAN = \"Closing curly brace appears on the same line as the subsequent block.\";\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n        * Fixes a place where a newline unexpectedly appears\n        * @param {Token} firstToken The token before the unexpected newline\n        * @param {Token} secondToken The token after the unexpected newline\n        * @returns {Function} A fixer function to remove the newlines between the tokens\n        */\n        function removeNewlineBetween(firstToken, secondToken) {\n            const textRange = [firstToken.range[1], secondToken.range[0]];\n            const textBetween = sourceCode.text.slice(textRange[0], textRange[1]);\n\n            // Don't do a fix if there is a comment between the tokens\n            if (textBetween.trim()) {\n                return null;\n            }\n            return fixer => fixer.replaceTextRange(textRange, \" \");\n        }\n\n        /**\n        * Validates a pair of curly brackets based on the user's config\n        * @param {Token} openingCurly The opening curly bracket\n        * @param {Token} closingCurly The closing curly bracket\n        * @returns {void}\n        */\n        function validateCurlyPair(openingCurly, closingCurly) {\n            const tokenBeforeOpeningCurly = sourceCode.getTokenBefore(openingCurly);\n            const tokenAfterOpeningCurly = sourceCode.getTokenAfter(openingCurly);\n            const tokenBeforeClosingCurly = sourceCode.getTokenBefore(closingCurly);\n            const singleLineException = params.allowSingleLine && astUtils.isTokenOnSameLine(openingCurly, closingCurly);\n\n            if (style !== \"allman\" && !astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly)) {\n                context.report({\n                    node: openingCurly,\n                    message: OPEN_MESSAGE,\n                    fix: removeNewlineBetween(tokenBeforeOpeningCurly, openingCurly)\n                });\n            }\n\n            if (style === \"allman\" && astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly) && !singleLineException) {\n                context.report({\n                    node: openingCurly,\n                    message: OPEN_MESSAGE_ALLMAN,\n                    fix: fixer => fixer.insertTextBefore(openingCurly, \"\\n\")\n                });\n            }\n\n            if (astUtils.isTokenOnSameLine(openingCurly, tokenAfterOpeningCurly) && tokenAfterOpeningCurly !== closingCurly && !singleLineException) {\n                context.report({\n                    node: openingCurly,\n                    message: BODY_MESSAGE,\n                    fix: fixer => fixer.insertTextAfter(openingCurly, \"\\n\")\n                });\n            }\n\n            if (tokenBeforeClosingCurly !== openingCurly && !singleLineException && astUtils.isTokenOnSameLine(tokenBeforeClosingCurly, closingCurly)) {\n                context.report({\n                    node: closingCurly,\n                    message: CLOSE_MESSAGE_SINGLE,\n                    fix: fixer => fixer.insertTextBefore(closingCurly, \"\\n\")\n                });\n            }\n        }\n\n        /**\n        * Validates the location of a token that appears before a keyword (e.g. a newline before `else`)\n        * @param {Token} curlyToken The closing curly token. This is assumed to precede a keyword token (such as `else` or `finally`).\n        * @returns {void}\n        */\n        function validateCurlyBeforeKeyword(curlyToken) {\n            const keywordToken = sourceCode.getTokenAfter(curlyToken);\n\n            if (style === \"1tbs\" && !astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n                context.report({\n                    node: curlyToken,\n                    message: CLOSE_MESSAGE,\n                    fix: removeNewlineBetween(curlyToken, keywordToken)\n                });\n            }\n\n            if (style !== \"1tbs\" && astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n                context.report({\n                    node: curlyToken,\n                    message: CLOSE_MESSAGE_STROUSTRUP_ALLMAN,\n                    fix: fixer => fixer.insertTextAfter(curlyToken, \"\\n\")\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            BlockStatement(node) {\n                if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\n                    validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n                }\n            },\n            ClassBody(node) {\n                validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n            },\n            SwitchStatement(node) {\n                const closingCurly = sourceCode.getLastToken(node);\n                const openingCurly = sourceCode.getTokenBefore(node.cases.length ? node.cases[0] : closingCurly);\n\n                validateCurlyPair(openingCurly, closingCurly);\n            },\n            IfStatement(node) {\n                if (node.consequent.type === \"BlockStatement\" && node.alternate) {\n\n                    // Handle the keyword after the `if` block (before `else`)\n                    validateCurlyBeforeKeyword(sourceCode.getLastToken(node.consequent));\n                }\n            },\n            TryStatement(node) {\n\n                // Handle the keyword after the `try` block (before `catch` or `finally`)\n                validateCurlyBeforeKeyword(sourceCode.getLastToken(node.block));\n\n                if (node.handler && node.finalizer) {\n\n                    // Handle the keyword after the `catch` block (before `finally`)\n                    validateCurlyBeforeKeyword(sourceCode.getLastToken(node.handler.body));\n                }\n            }\n        };\n    }\n};\n","callback-return.js":"/**\n * @fileoverview Enforce return after a callback.\n * @author Jamund Ferguson\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require `return` statements after callbacks\",\n            category: \"Node.js and CommonJS\",\n            recommended: false\n        },\n\n        schema: [{\n            type: \"array\",\n            items: { type: \"string\" }\n        }]\n    },\n\n    create(context) {\n\n        const callbacks = context.options[0] || [\"callback\", \"cb\", \"next\"],\n            sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Find the closest parent matching a list of types.\n         * @param {ASTNode} node The node whose parents we are searching\n         * @param {Array} types The node types to match\n         * @returns {ASTNode} The matched node or undefined.\n         */\n        function findClosestParentOfType(node, types) {\n            if (!node.parent) {\n                return null;\n            }\n            if (types.indexOf(node.parent.type) === -1) {\n                return findClosestParentOfType(node.parent, types);\n            }\n            return node.parent;\n        }\n\n        /**\n         * Check to see if a node contains only identifers\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} Whether or not the node contains only identifers\n         */\n        function containsOnlyIdentifiers(node) {\n            if (node.type === \"Identifier\") {\n                return true;\n            }\n\n            if (node.type === \"MemberExpression\") {\n                if (node.object.type === \"Identifier\") {\n                    return true;\n                } else if (node.object.type === \"MemberExpression\") {\n                    return containsOnlyIdentifiers(node.object);\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Check to see if a CallExpression is in our callback list.\n         * @param {ASTNode} node The node to check against our callback names list.\n         * @returns {boolean} Whether or not this function matches our callback name.\n         */\n        function isCallback(node) {\n            return containsOnlyIdentifiers(node.callee) && callbacks.indexOf(sourceCode.getText(node.callee)) > -1;\n        }\n\n        /**\n         * Determines whether or not the callback is part of a callback expression.\n         * @param {ASTNode} node The callback node\n         * @param {ASTNode} parentNode The expression node\n         * @returns {boolean} Whether or not this is part of a callback expression\n         */\n        function isCallbackExpression(node, parentNode) {\n\n            // ensure the parent node exists and is an expression\n            if (!parentNode || parentNode.type !== \"ExpressionStatement\") {\n                return false;\n            }\n\n            // cb()\n            if (parentNode.expression === node) {\n                return true;\n            }\n\n            // special case for cb && cb() and similar\n            if (parentNode.expression.type === \"BinaryExpression\" || parentNode.expression.type === \"LogicalExpression\") {\n                if (parentNode.expression.right === node) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            CallExpression(node) {\n\n                // if we're not a callback we can return\n                if (!isCallback(node)) {\n                    return;\n                }\n\n                // find the closest block, return or loop\n                const closestBlock = findClosestParentOfType(node, [\"BlockStatement\", \"ReturnStatement\", \"ArrowFunctionExpression\"]) || {};\n\n                // if our parent is a return we know we're ok\n                if (closestBlock.type === \"ReturnStatement\") {\n                    return;\n                }\n\n                // arrow functions don't always have blocks and implicitly return\n                if (closestBlock.type === \"ArrowFunctionExpression\") {\n                    return;\n                }\n\n                // block statements are part of functions and most if statements\n                if (closestBlock.type === \"BlockStatement\") {\n\n                    // find the last item in the block\n                    const lastItem = closestBlock.body[closestBlock.body.length - 1];\n\n                    // if the callback is the last thing in a block that might be ok\n                    if (isCallbackExpression(node, lastItem)) {\n\n                        const parentType = closestBlock.parent.type;\n\n                        // but only if the block is part of a function\n                        if (parentType === \"FunctionExpression\" ||\n                            parentType === \"FunctionDeclaration\" ||\n                            parentType === \"ArrowFunctionExpression\"\n                        ) {\n                            return;\n                        }\n\n                    }\n\n                    // ending a block with a return is also ok\n                    if (lastItem.type === \"ReturnStatement\") {\n\n                        // but only if the callback is immediately before\n                        if (isCallbackExpression(node, closestBlock.body[closestBlock.body.length - 2])) {\n                            return;\n                        }\n                    }\n\n                }\n\n                // as long as you're the child of a function at this point you should be asked to return\n                if (findClosestParentOfType(node, [\"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\"])) {\n                    context.report({ node, message: \"Expected return with your callback function.\" });\n                }\n\n            }\n\n        };\n    }\n};\n","camelcase.js":"/**\n * @fileoverview Rule to flag non-camelcased identifiers\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce camelcase naming convention\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    properties: {\n                        enum: [\"always\", \"never\"]\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // contains reported nodes to avoid reporting twice on destructuring with shorthand notation\n        const reported = [];\n        const ALLOWED_PARENT_TYPES = new Set([\"CallExpression\", \"NewExpression\"]);\n\n        /**\n         * Checks if a string contains an underscore and isn't all upper-case\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is underscored\n         * @private\n         */\n        function isUnderscored(name) {\n\n            // if there's an underscore, it might be A_CONSTANT, which is okay\n            return name.indexOf(\"_\") > -1 && name !== name.toUpperCase();\n        }\n\n        /**\n         * Reports an AST node as a rule violation.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            if (reported.indexOf(node) < 0) {\n                reported.push(node);\n                context.report({ node, message: \"Identifier '{{name}}' is not in camel case.\", data: { name: node.name } });\n            }\n        }\n\n        const options = context.options[0] || {};\n        let properties = options.properties || \"\";\n\n        if (properties !== \"always\" && properties !== \"never\") {\n            properties = \"always\";\n        }\n\n        return {\n\n            Identifier(node) {\n\n                /*\n                 * Leading and trailing underscores are commonly used to flag\n                 * private/protected identifiers, strip them\n                 */\n                const name = node.name.replace(/^_+|_+$/g, \"\"),\n                    effectiveParent = (node.parent.type === \"MemberExpression\") ? node.parent.parent : node.parent;\n\n                // MemberExpressions get special rules\n                if (node.parent.type === \"MemberExpression\") {\n\n                    // \"never\" check properties\n                    if (properties === \"never\") {\n                        return;\n                    }\n\n                    // Always report underscored object names\n                    if (node.parent.object.type === \"Identifier\" &&\n                            node.parent.object.name === node.name &&\n                            isUnderscored(name)) {\n                        report(node);\n\n                    // Report AssignmentExpressions only if they are the left side of the assignment\n                    } else if (effectiveParent.type === \"AssignmentExpression\" &&\n                            isUnderscored(name) &&\n                            (effectiveParent.right.type !== \"MemberExpression\" ||\n                            effectiveParent.left.type === \"MemberExpression\" &&\n                            effectiveParent.left.property.name === node.name)) {\n                        report(node);\n                    }\n\n                // Properties have their own rules\n                } else if (node.parent.type === \"Property\") {\n\n                    // \"never\" check properties\n                    if (properties === \"never\") {\n                        return;\n                    }\n\n                    if (node.parent.parent && node.parent.parent.type === \"ObjectPattern\" &&\n                            node.parent.key === node && node.parent.value !== node) {\n                        return;\n                    }\n\n                    if (isUnderscored(name) && !ALLOWED_PARENT_TYPES.has(effectiveParent.type)) {\n                        report(node);\n                    }\n\n                // Check if it's an import specifier\n                } else if ([\"ImportSpecifier\", \"ImportNamespaceSpecifier\", \"ImportDefaultSpecifier\"].indexOf(node.parent.type) >= 0) {\n\n                    // Report only if the local imported identifier is underscored\n                    if (node.parent.local && node.parent.local.name === node.name && isUnderscored(name)) {\n                        report(node);\n                    }\n\n                // Report anything that is underscored that isn't a CallExpression\n                } else if (isUnderscored(name) && !ALLOWED_PARENT_TYPES.has(effectiveParent.type)) {\n                    report(node);\n                }\n            }\n\n        };\n\n    }\n};\n","capitalized-comments.js":"/**\n * @fileoverview enforce or disallow capitalization of the first letter of a comment\n * @author Kevin Partington\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst LETTER_PATTERN = require(\"../util/patterns/letters\");\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst ALWAYS_MESSAGE = \"Comments should not begin with a lowercase character\",\n    NEVER_MESSAGE = \"Comments should not begin with an uppercase character\",\n    DEFAULT_IGNORE_PATTERN = astUtils.COMMENTS_IGNORE_PATTERN,\n    WHITESPACE = /\\s/g,\n    MAYBE_URL = /^\\s*[^:/?#\\s]+:\\/\\/[^?#]/, // TODO: Combine w/ max-len pattern?\n    DEFAULTS = {\n        ignorePattern: null,\n        ignoreInlineComments: false,\n        ignoreConsecutiveComments: false\n    };\n\n/*\n * Base schema body for defining the basic capitalization rule, ignorePattern,\n * and ignoreInlineComments values.\n * This can be used in a few different ways in the actual schema.\n */\nconst SCHEMA_BODY = {\n    type: \"object\",\n    properties: {\n        ignorePattern: {\n            type: \"string\"\n        },\n        ignoreInlineComments: {\n            type: \"boolean\"\n        },\n        ignoreConsecutiveComments: {\n            type: \"boolean\"\n        }\n    },\n    additionalProperties: false\n};\n\n/**\n * Get normalized options for either block or line comments from the given\n * user-provided options.\n * - If the user-provided options is just a string, returns a normalized\n *   set of options using default values for all other options.\n * - If the user-provided options is an object, then a normalized option\n *   set is returned. Options specified in overrides will take priority\n *   over options specified in the main options object, which will in\n *   turn take priority over the rule's defaults.\n *\n * @param {Object|string} rawOptions The user-provided options.\n * @param {string} which Either \"line\" or \"block\".\n * @returns {Object} The normalized options.\n */\nfunction getNormalizedOptions(rawOptions, which) {\n    if (!rawOptions) {\n        return Object.assign({}, DEFAULTS);\n    }\n\n    return Object.assign({}, DEFAULTS, rawOptions[which] || rawOptions);\n}\n\n/**\n * Get normalized options for block and line comments.\n *\n * @param {Object|string} rawOptions The user-provided options.\n * @returns {Object} An object with \"Line\" and \"Block\" keys and corresponding\n * normalized options objects.\n */\nfunction getAllNormalizedOptions(rawOptions) {\n    return {\n        Line: getNormalizedOptions(rawOptions, \"line\"),\n        Block: getNormalizedOptions(rawOptions, \"block\")\n    };\n}\n\n/**\n * Creates a regular expression for each ignorePattern defined in the rule\n * options.\n *\n * This is done in order to avoid invoking the RegExp constructor repeatedly.\n *\n * @param {Object} normalizedOptions The normalized rule options.\n * @returns {void}\n */\nfunction createRegExpForIgnorePatterns(normalizedOptions) {\n    Object.keys(normalizedOptions).forEach(key => {\n        const ignorePatternStr = normalizedOptions[key].ignorePattern;\n\n        if (ignorePatternStr) {\n            const regExp = RegExp(`^\\\\s*(?:${ignorePatternStr})`);\n\n            normalizedOptions[key].ignorePatternRegExp = regExp;\n        }\n    });\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce or disallow capitalization of the first letter of a comment\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        fixable: \"code\",\n        schema: [\n            { enum: [\"always\", \"never\"] },\n            {\n                oneOf: [\n                    SCHEMA_BODY,\n                    {\n                        type: \"object\",\n                        properties: {\n                            line: SCHEMA_BODY,\n                            block: SCHEMA_BODY\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n\n        const capitalize = context.options[0] || \"always\",\n            normalizedOptions = getAllNormalizedOptions(context.options[1]),\n            sourceCode = context.getSourceCode();\n\n        createRegExpForIgnorePatterns(normalizedOptions);\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Checks whether a comment is an inline comment.\n         *\n         * For the purpose of this rule, a comment is inline if:\n         * 1. The comment is preceded by a token on the same line; and\n         * 2. The command is followed by a token on the same line.\n         *\n         * Note that the comment itself need not be single-line!\n         *\n         * Also, it follows from this definition that only block comments can\n         * be considered as possibly inline. This is because line comments\n         * would consume any following tokens on the same line as the comment.\n         *\n         * @param {ASTNode} comment The comment node to check.\n         * @returns {boolean} True if the comment is an inline comment, false\n         * otherwise.\n         */\n        function isInlineComment(comment) {\n            const previousToken = sourceCode.getTokenBefore(comment, { includeComments: true }),\n                nextToken = sourceCode.getTokenAfter(comment, { includeComments: true });\n\n            return Boolean(\n                previousToken &&\n                nextToken &&\n                comment.loc.start.line === previousToken.loc.end.line &&\n                comment.loc.end.line === nextToken.loc.start.line\n            );\n        }\n\n        /**\n         * Determine if a comment follows another comment.\n         *\n         * @param {ASTNode} comment The comment to check.\n         * @returns {boolean} True if the comment follows a valid comment.\n         */\n        function isConsecutiveComment(comment) {\n            const previousTokenOrComment = sourceCode.getTokenBefore(comment, { includeComments: true });\n\n            return Boolean(\n                previousTokenOrComment &&\n                [\"Block\", \"Line\"].indexOf(previousTokenOrComment.type) !== -1\n            );\n        }\n\n        /**\n         * Check a comment to determine if it is valid for this rule.\n         *\n         * @param {ASTNode} comment The comment node to process.\n         * @param {Object} options The options for checking this comment.\n         * @returns {boolean} True if the comment is valid, false otherwise.\n         */\n        function isCommentValid(comment, options) {\n\n            // 1. Check for default ignore pattern.\n            if (DEFAULT_IGNORE_PATTERN.test(comment.value)) {\n                return true;\n            }\n\n            // 2. Check for custom ignore pattern.\n            const commentWithoutAsterisks = comment.value\n                .replace(/\\*/g, \"\");\n\n            if (options.ignorePatternRegExp && options.ignorePatternRegExp.test(commentWithoutAsterisks)) {\n                return true;\n            }\n\n            // 3. Check for inline comments.\n            if (options.ignoreInlineComments && isInlineComment(comment)) {\n                return true;\n            }\n\n            // 4. Is this a consecutive comment (and are we tolerating those)?\n            if (options.ignoreConsecutiveComments && isConsecutiveComment(comment)) {\n                return true;\n            }\n\n            // 5. Does the comment start with a possible URL?\n            if (MAYBE_URL.test(commentWithoutAsterisks)) {\n                return true;\n            }\n\n            // 6. Is the initial word character a letter?\n            const commentWordCharsOnly = commentWithoutAsterisks\n                .replace(WHITESPACE, \"\");\n\n            if (commentWordCharsOnly.length === 0) {\n                return true;\n            }\n\n            const firstWordChar = commentWordCharsOnly[0];\n\n            if (!LETTER_PATTERN.test(firstWordChar)) {\n                return true;\n            }\n\n            // 7. Check the case of the initial word character.\n            const isUppercase = firstWordChar !== firstWordChar.toLocaleLowerCase(),\n                isLowercase = firstWordChar !== firstWordChar.toLocaleUpperCase();\n\n            if (capitalize === \"always\" && isLowercase) {\n                return false;\n            } else if (capitalize === \"never\" && isUppercase) {\n                return false;\n            }\n\n            return true;\n        }\n\n        /**\n         * Process a comment to determine if it needs to be reported.\n         *\n         * @param {ASTNode} comment The comment node to process.\n         * @returns {void}\n         */\n        function processComment(comment) {\n            const options = normalizedOptions[comment.type],\n                commentValid = isCommentValid(comment, options);\n\n            if (!commentValid) {\n                const message = capitalize === \"always\"\n                    ? ALWAYS_MESSAGE\n                    : NEVER_MESSAGE;\n\n                context.report({\n                    node: null, // Intentionally using loc instead\n                    loc: comment.loc,\n                    message,\n                    fix(fixer) {\n                        const match = comment.value.match(LETTER_PATTERN);\n\n                        return fixer.replaceTextRange(\n\n                            // Offset match.index by 2 to account for the first 2 characters that start the comment (// or /*)\n                            [comment.range[0] + match.index + 2, comment.range[0] + match.index + 3],\n                            capitalize === \"always\" ? match[0].toLocaleUpperCase() : match[0].toLocaleLowerCase()\n                        );\n                    }\n                });\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments.filter(token => token.type !== \"Shebang\").forEach(processComment);\n            }\n        };\n    }\n};\n","class-methods-use-this.js":"/**\n * @fileoverview Rule to enforce that all class methods use 'this'.\n * @author Patrick Williams\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce that class methods utilize `this`\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n        schema: [{\n            type: \"object\",\n            properties: {\n                exceptMethods: {\n                    type: \"array\",\n                    items: {\n                        type: \"string\"\n                    }\n                }\n            },\n            additionalProperties: false\n        }]\n    },\n    create(context) {\n        const config = context.options[0] ? Object.assign({}, context.options[0]) : {};\n        const exceptMethods = new Set(config.exceptMethods || []);\n\n        const stack = [];\n\n        /**\n         * Initializes the current context to false and pushes it onto the stack.\n         * These booleans represent whether 'this' has been used in the context.\n         * @returns {void}\n         * @private\n         */\n        function enterFunction() {\n            stack.push(false);\n        }\n\n        /**\n         * Check if the node is an instance method\n         * @param {ASTNode} node - node to check\n         * @returns {boolean} True if its an instance method\n         * @private\n         */\n        function isInstanceMethod(node) {\n            return !node.static && node.kind !== \"constructor\" && node.type === \"MethodDefinition\";\n        }\n\n        /**\n         * Check if the node is an instance method not excluded by config\n         * @param {ASTNode} node - node to check\n         * @returns {boolean} True if it is an instance method, and not excluded by config\n         * @private\n         */\n        function isIncludedInstanceMethod(node) {\n            return isInstanceMethod(node) && !exceptMethods.has(node.key.name);\n        }\n\n        /**\n         * Checks if we are leaving a function that is a method, and reports if 'this' has not been used.\n         * Static methods and the constructor are exempt.\n         * Then pops the context off the stack.\n         * @param {ASTNode} node - A function node that was entered.\n         * @returns {void}\n         * @private\n         */\n        function exitFunction(node) {\n            const methodUsesThis = stack.pop();\n\n            if (isIncludedInstanceMethod(node.parent) && !methodUsesThis) {\n                context.report({\n                    node,\n                    message: \"Expected 'this' to be used by class method '{{classMethod}}'.\",\n                    data: {\n                        classMethod: node.parent.key.name\n                    }\n                });\n            }\n        }\n\n        /**\n         * Mark the current context as having used 'this'.\n         * @returns {void}\n         * @private\n         */\n        function markThisUsed() {\n            if (stack.length) {\n                stack[stack.length - 1] = true;\n            }\n        }\n\n        return {\n            FunctionDeclaration: enterFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            FunctionExpression: enterFunction,\n            \"FunctionExpression:exit\": exitFunction,\n            ThisExpression: markThisUsed,\n            Super: markThisUsed\n        };\n    }\n};\n","comma-dangle.js":"/**\n * @fileoverview Rule to forbid or enforce dangling commas.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_OPTIONS = Object.freeze({\n    arrays: \"never\",\n    objects: \"never\",\n    imports: \"never\",\n    exports: \"never\",\n    functions: \"ignore\"\n});\n\n/**\n * Checks whether or not a trailing comma is allowed in a given node.\n * If the `lastItem` is `RestElement` or `RestProperty`, it disallows trailing commas.\n *\n * @param {ASTNode} lastItem - The node of the last element in the given node.\n * @returns {boolean} `true` if a trailing comma is allowed.\n */\nfunction isTrailingCommaAllowed(lastItem) {\n    return !(\n        lastItem.type === \"RestElement\" ||\n        lastItem.type === \"RestProperty\" ||\n        lastItem.type === \"ExperimentalRestProperty\"\n    );\n}\n\n/**\n * Normalize option value.\n *\n * @param {string|Object|undefined} optionValue - The 1st option value to normalize.\n * @returns {Object} The normalized option value.\n */\nfunction normalizeOptions(optionValue) {\n    if (typeof optionValue === \"string\") {\n        return {\n            arrays: optionValue,\n            objects: optionValue,\n            imports: optionValue,\n            exports: optionValue,\n\n            // For backward compatibility, always ignore functions.\n            functions: \"ignore\"\n        };\n    }\n    if (typeof optionValue === \"object\" && optionValue !== null) {\n        return {\n            arrays: optionValue.arrays || DEFAULT_OPTIONS.arrays,\n            objects: optionValue.objects || DEFAULT_OPTIONS.objects,\n            imports: optionValue.imports || DEFAULT_OPTIONS.imports,\n            exports: optionValue.exports || DEFAULT_OPTIONS.exports,\n            functions: optionValue.functions || DEFAULT_OPTIONS.functions\n        };\n    }\n\n    return DEFAULT_OPTIONS;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow trailing commas\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        fixable: \"code\",\n        schema: {\n            definitions: {\n                value: {\n                    enum: [\n                        \"always-multiline\",\n                        \"always\",\n                        \"never\",\n                        \"only-multiline\"\n                    ]\n                },\n                valueWithIgnore: {\n                    enum: [\n                        \"always-multiline\",\n                        \"always\",\n                        \"ignore\",\n                        \"never\",\n                        \"only-multiline\"\n                    ]\n                }\n            },\n            type: \"array\",\n            items: [\n                {\n                    oneOf: [\n                        {\n                            $ref: \"#/definitions/value\"\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                arrays: { $ref: \"#/definitions/valueWithIgnore\" },\n                                objects: { $ref: \"#/definitions/valueWithIgnore\" },\n                                imports: { $ref: \"#/definitions/valueWithIgnore\" },\n                                exports: { $ref: \"#/definitions/valueWithIgnore\" },\n                                functions: { $ref: \"#/definitions/valueWithIgnore\" }\n                            },\n                            additionalProperties: false\n                        }\n                    ]\n                }\n            ]\n        }\n    },\n\n    create(context) {\n        const options = normalizeOptions(context.options[0]);\n        const sourceCode = context.getSourceCode();\n        const UNEXPECTED_MESSAGE = \"Unexpected trailing comma.\";\n        const MISSING_MESSAGE = \"Missing trailing comma.\";\n\n        /**\n         * Gets the last item of the given node.\n         * @param {ASTNode} node - The node to get.\n         * @returns {ASTNode|null} The last node or null.\n         */\n        function getLastItem(node) {\n            switch (node.type) {\n                case \"ObjectExpression\":\n                case \"ObjectPattern\":\n                    return lodash.last(node.properties);\n                case \"ArrayExpression\":\n                case \"ArrayPattern\":\n                    return lodash.last(node.elements);\n                case \"ImportDeclaration\":\n                case \"ExportNamedDeclaration\":\n                    return lodash.last(node.specifiers);\n                case \"FunctionDeclaration\":\n                case \"FunctionExpression\":\n                case \"ArrowFunctionExpression\":\n                    return lodash.last(node.params);\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return lodash.last(node.arguments);\n                default:\n                    return null;\n            }\n        }\n\n        /**\n         * Gets the trailing comma token of the given node.\n         * If the trailing comma does not exist, this returns the token which is\n         * the insertion point of the trailing comma token.\n         *\n         * @param {ASTNode} node - The node to get.\n         * @param {ASTNode} lastItem - The last item of the node.\n         * @returns {Token} The trailing comma token or the insertion point.\n         */\n        function getTrailingToken(node, lastItem) {\n            switch (node.type) {\n                case \"ObjectExpression\":\n                case \"ArrayExpression\":\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return sourceCode.getLastToken(node, 1);\n                default: {\n                    const nextToken = sourceCode.getTokenAfter(lastItem);\n\n                    if (astUtils.isCommaToken(nextToken)) {\n                        return nextToken;\n                    }\n                    return sourceCode.getLastToken(lastItem);\n                }\n            }\n        }\n\n        /**\n         * Checks whether or not a given node is multiline.\n         * This rule handles a given node as multiline when the closing parenthesis\n         * and the last element are not on the same line.\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {boolean} `true` if the node is multiline.\n         */\n        function isMultiline(node) {\n            const lastItem = getLastItem(node);\n\n            if (!lastItem) {\n                return false;\n            }\n\n            const penultimateToken = getTrailingToken(node, lastItem);\n            const lastToken = sourceCode.getTokenAfter(penultimateToken);\n\n            return lastToken.loc.end.line !== penultimateToken.loc.end.line;\n        }\n\n        /**\n         * Reports a trailing comma if it exists.\n         *\n         * @param {ASTNode} node - A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forbidTrailingComma(node) {\n            const lastItem = getLastItem(node);\n\n            if (!lastItem || (node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\")) {\n                return;\n            }\n\n            const trailingToken = getTrailingToken(node, lastItem);\n\n            if (astUtils.isCommaToken(trailingToken)) {\n                context.report({\n                    node: lastItem,\n                    loc: trailingToken.loc.start,\n                    message: UNEXPECTED_MESSAGE,\n                    fix(fixer) {\n                        return fixer.remove(trailingToken);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports the last element of a given node if it does not have a trailing\n         * comma.\n         *\n         * If a given node is `ArrayPattern` which has `RestElement`, the trailing\n         * comma is disallowed, so report if it exists.\n         *\n         * @param {ASTNode} node - A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forceTrailingComma(node) {\n            const lastItem = getLastItem(node);\n\n            if (!lastItem || (node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\")) {\n                return;\n            }\n            if (!isTrailingCommaAllowed(lastItem)) {\n                forbidTrailingComma(node);\n                return;\n            }\n\n            const trailingToken = getTrailingToken(node, lastItem);\n\n            if (trailingToken.value !== \",\") {\n                context.report({\n                    node: lastItem,\n                    loc: trailingToken.loc.end,\n                    message: MISSING_MESSAGE,\n                    fix(fixer) {\n                        return fixer.insertTextAfter(trailingToken, \",\");\n                    }\n                });\n            }\n        }\n\n        /**\n         * If a given node is multiline, reports the last element of a given node\n         * when it does not have a trailing comma.\n         * Otherwise, reports a trailing comma if it exists.\n         *\n         * @param {ASTNode} node - A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forceTrailingCommaIfMultiline(node) {\n            if (isMultiline(node)) {\n                forceTrailingComma(node);\n            } else {\n                forbidTrailingComma(node);\n            }\n        }\n\n        /**\n         * Only if a given node is not multiline, reports the last element of a given node\n         * when it does not have a trailing comma.\n         * Otherwise, reports a trailing comma if it exists.\n         *\n         * @param {ASTNode} node - A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function allowTrailingCommaIfMultiline(node) {\n            if (!isMultiline(node)) {\n                forbidTrailingComma(node);\n            }\n        }\n\n        const predicate = {\n            always: forceTrailingComma,\n            \"always-multiline\": forceTrailingCommaIfMultiline,\n            \"only-multiline\": allowTrailingCommaIfMultiline,\n            never: forbidTrailingComma,\n            ignore: lodash.noop\n        };\n\n        return {\n            ObjectExpression: predicate[options.objects],\n            ObjectPattern: predicate[options.objects],\n\n            ArrayExpression: predicate[options.arrays],\n            ArrayPattern: predicate[options.arrays],\n\n            ImportDeclaration: predicate[options.imports],\n\n            ExportNamedDeclaration: predicate[options.exports],\n\n            FunctionDeclaration: predicate[options.functions],\n            FunctionExpression: predicate[options.functions],\n            ArrowFunctionExpression: predicate[options.functions],\n            CallExpression: predicate[options.functions],\n            NewExpression: predicate[options.functions]\n        };\n    }\n};\n","comma-spacing.js":"/**\n * @fileoverview Comma spacing - validates spacing before and after comma\n * @author Vignesh Anand aka vegetableman.\n */\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing before and after commas\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: {\n                        type: \"boolean\"\n                    },\n                    after: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n        const tokensAndComments = sourceCode.tokensAndComments;\n\n        const options = {\n            before: context.options[0] ? !!context.options[0].before : false,\n            after: context.options[0] ? !!context.options[0].after : true\n        };\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // list of comma tokens to ignore for the check of leading whitespace\n        const commaTokensToIgnore = [];\n\n        /**\n         * Reports a spacing error with an appropriate message.\n         * @param {ASTNode} node The binary expression node to report.\n         * @param {string} dir Is the error \"before\" or \"after\" the comma?\n         * @param {ASTNode} otherNode The node at the left or right of `node`\n         * @returns {void}\n         * @private\n         */\n        function report(node, dir, otherNode) {\n            context.report({\n                node,\n                fix(fixer) {\n                    if (options[dir]) {\n                        if (dir === \"before\") {\n                            return fixer.insertTextBefore(node, \" \");\n                        }\n                        return fixer.insertTextAfter(node, \" \");\n\n                    }\n                    let start, end;\n                    const newText = \"\";\n\n                    if (dir === \"before\") {\n                        start = otherNode.range[1];\n                        end = node.range[0];\n                    } else {\n                        start = node.range[1];\n                        end = otherNode.range[0];\n                    }\n\n                    return fixer.replaceTextRange([start, end], newText);\n\n                },\n                message: options[dir]\n                    ? \"A space is required {{dir}} ','.\"\n                    : \"There should be no space {{dir}} ','.\",\n                data: {\n                    dir\n                }\n            });\n        }\n\n        /**\n         * Validates the spacing around a comma token.\n         * @param {Object} tokens - The tokens to be validated.\n         * @param {Token} tokens.comma The token representing the comma.\n         * @param {Token} [tokens.left] The last token before the comma.\n         * @param {Token} [tokens.right] The first token after the comma.\n         * @param {Token|ASTNode} reportItem The item to use when reporting an error.\n         * @returns {void}\n         * @private\n         */\n        function validateCommaItemSpacing(tokens, reportItem) {\n            if (tokens.left && astUtils.isTokenOnSameLine(tokens.left, tokens.comma) &&\n                    (options.before !== sourceCode.isSpaceBetweenTokens(tokens.left, tokens.comma))\n            ) {\n                report(reportItem, \"before\", tokens.left);\n            }\n\n            if (tokens.right && !options.after && tokens.right.type === \"Line\") {\n                return;\n            }\n\n            if (tokens.right && astUtils.isTokenOnSameLine(tokens.comma, tokens.right) &&\n                    (options.after !== sourceCode.isSpaceBetweenTokens(tokens.comma, tokens.right))\n            ) {\n                report(reportItem, \"after\", tokens.right);\n            }\n        }\n\n        /**\n         * Adds null elements of the given ArrayExpression or ArrayPattern node to the ignore list.\n         * @param {ASTNode} node An ArrayExpression or ArrayPattern node.\n         * @returns {void}\n         */\n        function addNullElementsToIgnoreList(node) {\n            let previousToken = sourceCode.getFirstToken(node);\n\n            node.elements.forEach(element => {\n                let token;\n\n                if (element === null) {\n                    token = sourceCode.getTokenAfter(previousToken);\n\n                    if (astUtils.isCommaToken(token)) {\n                        commaTokensToIgnore.push(token);\n                    }\n                } else {\n                    token = sourceCode.getTokenAfter(element);\n                }\n\n                previousToken = token;\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            \"Program:exit\"() {\n                tokensAndComments.forEach((token, i) => {\n\n                    if (!astUtils.isCommaToken(token)) {\n                        return;\n                    }\n\n                    if (token && token.type === \"JSXText\") {\n                        return;\n                    }\n\n                    const previousToken = tokensAndComments[i - 1];\n                    const nextToken = tokensAndComments[i + 1];\n\n                    validateCommaItemSpacing({\n                        comma: token,\n                        left: astUtils.isCommaToken(previousToken) || commaTokensToIgnore.indexOf(token) > -1 ? null : previousToken,\n                        right: astUtils.isCommaToken(nextToken) ? null : nextToken\n                    }, token);\n                });\n            },\n            ArrayExpression: addNullElementsToIgnoreList,\n            ArrayPattern: addNullElementsToIgnoreList\n\n        };\n\n    }\n};\n","comma-style.js":"/**\n * @fileoverview Comma style - enforces comma styles of two types: last and first\n * @author Vignesh Anand aka vegetableman\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent comma style\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        fixable: \"code\",\n        schema: [\n            {\n                enum: [\"first\", \"last\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"boolean\"\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const style = context.options[0] || \"last\",\n            sourceCode = context.getSourceCode();\n        const exceptions = {\n            ArrayPattern: true,\n            ArrowFunctionExpression: true,\n            CallExpression: true,\n            FunctionDeclaration: true,\n            FunctionExpression: true,\n            ImportDeclaration: true,\n            ObjectPattern: true\n        };\n\n        if (context.options.length === 2 && context.options[1].hasOwnProperty(\"exceptions\")) {\n            const keys = Object.keys(context.options[1].exceptions);\n\n            for (let i = 0; i < keys.length; i++) {\n                exceptions[keys[i]] = context.options[1].exceptions[keys[i]];\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Modified text based on the style\n         * @param {string} styleType Style type\n         * @param {string} text Source code text\n         * @returns {string} modified text\n         * @private\n         */\n        function getReplacedText(styleType, text) {\n            switch (styleType) {\n                case \"between\":\n                    return `,${text.replace(\"\\n\", \"\")}`;\n\n                case \"first\":\n                    return `${text},`;\n\n                case \"last\":\n                    return `,${text}`;\n\n                default:\n                    return \"\";\n            }\n        }\n\n        /**\n         * Determines the fixer function for a given style.\n         * @param {string} styleType comma style\n         * @param {ASTNode} previousItemToken The token to check.\n         * @param {ASTNode} commaToken The token to check.\n         * @param {ASTNode} currentItemToken The token to check.\n         * @returns {Function} Fixer function\n         * @private\n         */\n        function getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken) {\n            const text =\n                sourceCode.text.slice(previousItemToken.range[1], commaToken.range[0]) +\n                sourceCode.text.slice(commaToken.range[1], currentItemToken.range[0]);\n            const range = [previousItemToken.range[1], currentItemToken.range[0]];\n\n            return function(fixer) {\n                return fixer.replaceTextRange(range, getReplacedText(styleType, text));\n            };\n        }\n\n        /**\n         * Validates the spacing around single items in lists.\n         * @param {Token} previousItemToken The last token from the previous item.\n         * @param {Token} commaToken The token representing the comma.\n         * @param {Token} currentItemToken The first token of the current item.\n         * @param {Token} reportItem The item to use when reporting an error.\n         * @returns {void}\n         * @private\n         */\n        function validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem) {\n\n            // if single line\n            if (astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&\n                    astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {\n\n                // do nothing.\n\n            } else if (!astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&\n                    !astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {\n\n                // lone comma\n                context.report({\n                    node: reportItem,\n                    loc: {\n                        line: commaToken.loc.end.line,\n                        column: commaToken.loc.start.column\n                    },\n                    message: \"Bad line breaking before and after ','.\",\n                    fix: getFixerFunction(\"between\", previousItemToken, commaToken, currentItemToken)\n                });\n\n            } else if (style === \"first\" && !astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\n\n                context.report({\n                    node: reportItem,\n                    message: \"',' should be placed first.\",\n                    fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\n                });\n\n            } else if (style === \"last\" && astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\n\n                context.report({\n                    node: reportItem,\n                    loc: {\n                        line: commaToken.loc.end.line,\n                        column: commaToken.loc.end.column\n                    },\n                    message: \"',' should be placed last.\",\n                    fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\n                });\n            }\n        }\n\n        /**\n         * Checks the comma placement with regards to a declaration/property/element\n         * @param {ASTNode} node The binary expression node to check\n         * @param {string} property The property of the node containing child nodes.\n         * @private\n         * @returns {void}\n         */\n        function validateComma(node, property) {\n            const items = node[property],\n                arrayLiteral = (node.type === \"ArrayExpression\" || node.type === \"ArrayPattern\");\n\n            if (items.length > 1 || arrayLiteral) {\n\n                // seed as opening [\n                let previousItemToken = sourceCode.getFirstToken(node);\n\n                items.forEach(item => {\n                    const commaToken = item ? sourceCode.getTokenBefore(item) : previousItemToken,\n                        currentItemToken = item ? sourceCode.getFirstToken(item) : sourceCode.getTokenAfter(commaToken),\n                        reportItem = item || currentItemToken,\n                        tokenBeforeComma = sourceCode.getTokenBefore(commaToken);\n\n                    // Check if previous token is wrapped in parentheses\n                    if (tokenBeforeComma && astUtils.isClosingParenToken(tokenBeforeComma)) {\n                        previousItemToken = tokenBeforeComma;\n                    }\n\n                    /*\n                     * This works by comparing three token locations:\n                     * - previousItemToken is the last token of the previous item\n                     * - commaToken is the location of the comma before the current item\n                     * - currentItemToken is the first token of the current item\n                     *\n                     * These values get switched around if item is undefined.\n                     * previousItemToken will refer to the last token not belonging\n                     * to the current item, which could be a comma or an opening\n                     * square bracket. currentItemToken could be a comma.\n                     *\n                     * All comparisons are done based on these tokens directly, so\n                     * they are always valid regardless of an undefined item.\n                     */\n                    if (astUtils.isCommaToken(commaToken)) {\n                        validateCommaItemSpacing(previousItemToken, commaToken,\n                            currentItemToken, reportItem);\n                    }\n\n                    if (item) {\n                        const tokenAfterItem = sourceCode.getTokenAfter(item, astUtils.isNotClosingParenToken);\n\n                        previousItemToken = tokenAfterItem ? sourceCode.getTokenBefore(tokenAfterItem) : sourceCode.ast.tokens[sourceCode.ast.tokens.length - 1];\n                    }\n                });\n\n                /*\n                 * Special case for array literals that have empty last items, such\n                 * as [ 1, 2, ]. These arrays only have two items show up in the\n                 * AST, so we need to look at the token to verify that there's no\n                 * dangling comma.\n                 */\n                if (arrayLiteral) {\n\n                    const lastToken = sourceCode.getLastToken(node),\n                        nextToLastToken = sourceCode.getTokenBefore(lastToken);\n\n                    if (astUtils.isCommaToken(nextToLastToken)) {\n                        validateCommaItemSpacing(\n                            sourceCode.getTokenBefore(nextToLastToken),\n                            nextToLastToken,\n                            lastToken,\n                            lastToken\n                        );\n                    }\n                }\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        const nodes = {};\n\n        if (!exceptions.VariableDeclaration) {\n            nodes.VariableDeclaration = function(node) {\n                validateComma(node, \"declarations\");\n            };\n        }\n        if (!exceptions.ObjectExpression) {\n            nodes.ObjectExpression = function(node) {\n                validateComma(node, \"properties\");\n            };\n        }\n        if (!exceptions.ObjectPattern) {\n            nodes.ObjectPattern = function(node) {\n                validateComma(node, \"properties\");\n            };\n        }\n        if (!exceptions.ArrayExpression) {\n            nodes.ArrayExpression = function(node) {\n                validateComma(node, \"elements\");\n            };\n        }\n        if (!exceptions.ArrayPattern) {\n            nodes.ArrayPattern = function(node) {\n                validateComma(node, \"elements\");\n            };\n        }\n        if (!exceptions.FunctionDeclaration) {\n            nodes.FunctionDeclaration = function(node) {\n                validateComma(node, \"params\");\n            };\n        }\n        if (!exceptions.FunctionExpression) {\n            nodes.FunctionExpression = function(node) {\n                validateComma(node, \"params\");\n            };\n        }\n        if (!exceptions.ArrowFunctionExpression) {\n            nodes.ArrowFunctionExpression = function(node) {\n                validateComma(node, \"params\");\n            };\n        }\n        if (!exceptions.CallExpression) {\n            nodes.CallExpression = function(node) {\n                validateComma(node, \"arguments\");\n            };\n        }\n        if (!exceptions.ImportDeclaration) {\n            nodes.ImportDeclaration = function(node) {\n                validateComma(node, \"specifiers\");\n            };\n        }\n\n        return nodes;\n    }\n};\n","complexity.js":"/**\n * @fileoverview Counts the cyclomatic complexity of each function of the script. See http://en.wikipedia.org/wiki/Cyclomatic_complexity.\n * Counts the number of if, conditional, for, whilte, try, switch/case,\n * @author Patrick Brosset\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce a maximum cyclomatic complexity allowed in a program\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            maximum: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const option = context.options[0];\n        let THRESHOLD = 20;\n\n        if (typeof option === \"object\" && option.hasOwnProperty(\"maximum\") && typeof option.maximum === \"number\") {\n            THRESHOLD = option.maximum;\n        }\n        if (typeof option === \"object\" && option.hasOwnProperty(\"max\") && typeof option.max === \"number\") {\n            THRESHOLD = option.max;\n        }\n        if (typeof option === \"number\") {\n            THRESHOLD = option;\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // Using a stack to store complexity (handling nested functions)\n        const fns = [];\n\n        /**\n         * When parsing a new function, store it in our function stack\n         * @returns {void}\n         * @private\n         */\n        function startFunction() {\n            fns.push(1);\n        }\n\n        /**\n         * Evaluate the node at the end of function\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function endFunction(node) {\n            const name = lodash.upperFirst(astUtils.getFunctionNameWithKind(node));\n            const complexity = fns.pop();\n\n            if (complexity > THRESHOLD) {\n                context.report({\n                    node,\n                    message: \"{{name}} has a complexity of {{complexity}}.\",\n                    data: { name, complexity }\n                });\n            }\n        }\n\n        /**\n         * Increase the complexity of the function in context\n         * @returns {void}\n         * @private\n         */\n        function increaseComplexity() {\n            if (fns.length) {\n                fns[fns.length - 1]++;\n            }\n        }\n\n        /**\n         * Increase the switch complexity in context\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function increaseSwitchComplexity(node) {\n\n            // Avoiding `default`\n            if (node.test) {\n                increaseComplexity();\n            }\n        }\n\n        /**\n         * Increase the logical path complexity in context\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function increaseLogicalComplexity(node) {\n\n            // Avoiding &&\n            if (node.operator === \"||\") {\n                increaseComplexity();\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            FunctionDeclaration: startFunction,\n            FunctionExpression: startFunction,\n            ArrowFunctionExpression: startFunction,\n            \"FunctionDeclaration:exit\": endFunction,\n            \"FunctionExpression:exit\": endFunction,\n            \"ArrowFunctionExpression:exit\": endFunction,\n\n            CatchClause: increaseComplexity,\n            ConditionalExpression: increaseComplexity,\n            LogicalExpression: increaseLogicalComplexity,\n            ForStatement: increaseComplexity,\n            ForInStatement: increaseComplexity,\n            ForOfStatement: increaseComplexity,\n            IfStatement: increaseComplexity,\n            SwitchCase: increaseSwitchComplexity,\n            WhileStatement: increaseComplexity,\n            DoWhileStatement: increaseComplexity\n        };\n\n    }\n};\n","computed-property-spacing.js":"/**\n * @fileoverview Disallows or enforces spaces inside computed properties.\n * @author Jamund Ferguson\n */\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing inside computed property brackets\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const propertyNameMustBeSpaced = context.options[0] === \"always\"; // default is \"never\"\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n        * Reports that there shouldn't be a space after the first token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @param {Token} tokenAfter - The token after `token`.\n        * @returns {void}\n        */\n        function reportNoBeginningSpace(node, token, tokenAfter) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"There should be no space after '{{tokenValue}}'.\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    return fixer.removeRange([token.range[1], tokenAfter.range[0]]);\n                }\n            });\n        }\n\n        /**\n        * Reports that there shouldn't be a space before the last token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @param {Token} tokenBefore - The token before `token`.\n        * @returns {void}\n        */\n        function reportNoEndingSpace(node, token, tokenBefore) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"There should be no space before '{{tokenValue}}'.\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    return fixer.removeRange([tokenBefore.range[1], token.range[0]]);\n                }\n            });\n        }\n\n        /**\n        * Reports that there should be a space after the first token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @returns {void}\n        */\n        function reportRequiredBeginningSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"A space is required after '{{tokenValue}}'.\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    return fixer.insertTextAfter(token, \" \");\n                }\n            });\n        }\n\n        /**\n        * Reports that there should be a space before the last token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @returns {void}\n        */\n        function reportRequiredEndingSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"A space is required before '{{tokenValue}}'.\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    return fixer.insertTextBefore(token, \" \");\n                }\n            });\n        }\n\n        /**\n         * Returns a function that checks the spacing of a node on the property name\n         * that was passed in.\n         * @param {string} propertyName The property on the node to check for spacing\n         * @returns {Function} A function that will check spacing on a node\n         */\n        function checkSpacing(propertyName) {\n            return function(node) {\n                if (!node.computed) {\n                    return;\n                }\n\n                const property = node[propertyName];\n\n                const before = sourceCode.getTokenBefore(property),\n                    first = sourceCode.getFirstToken(property),\n                    last = sourceCode.getLastToken(property),\n                    after = sourceCode.getTokenAfter(property);\n\n                if (astUtils.isTokenOnSameLine(before, first)) {\n                    if (propertyNameMustBeSpaced) {\n                        if (!sourceCode.isSpaceBetweenTokens(before, first) && astUtils.isTokenOnSameLine(before, first)) {\n                            reportRequiredBeginningSpace(node, before);\n                        }\n                    } else {\n                        if (sourceCode.isSpaceBetweenTokens(before, first)) {\n                            reportNoBeginningSpace(node, before, first);\n                        }\n                    }\n                }\n\n                if (astUtils.isTokenOnSameLine(last, after)) {\n                    if (propertyNameMustBeSpaced) {\n                        if (!sourceCode.isSpaceBetweenTokens(last, after) && astUtils.isTokenOnSameLine(last, after)) {\n                            reportRequiredEndingSpace(node, after);\n                        }\n                    } else {\n                        if (sourceCode.isSpaceBetweenTokens(last, after)) {\n                            reportNoEndingSpace(node, after, last);\n                        }\n                    }\n                }\n            };\n        }\n\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Property: checkSpacing(\"key\"),\n            MemberExpression: checkSpacing(\"property\")\n        };\n\n    }\n};\n","consistent-return.js":"/**\n * @fileoverview Rule to flag consistent return values\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is an `Identifier` node which was named a given name.\n * @param {ASTNode} node - A node to check.\n * @param {string} name - An expected name of the node.\n * @returns {boolean} `true` if the node is an `Identifier` node which was named as expected.\n */\nfunction isIdentifier(node, name) {\n    return node.type === \"Identifier\" && node.name === name;\n}\n\n/**\n * Checks whether or not a given code path segment is unreachable.\n * @param {CodePathSegment} segment - A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is unreachable.\n */\nfunction isUnreachable(segment) {\n    return !segment.reachable;\n}\n\n/**\n* Checks whether a given node is a `constructor` method in an ES6 class\n* @param {ASTNode} node A node to check\n* @returns {boolean} `true` if the node is a `constructor` method\n*/\nfunction isClassConstructor(node) {\n    return node.type === \"FunctionExpression\" &&\n        node.parent &&\n        node.parent.type === \"MethodDefinition\" &&\n        node.parent.kind === \"constructor\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require `return` statements to either always or never specify values\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                treatUndefinedAsUnspecified: {\n                    type: \"boolean\"\n                }\n            },\n            additionalProperties: false\n        }]\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const treatUndefinedAsUnspecified = options.treatUndefinedAsUnspecified === true;\n        let funcInfo = null;\n\n        /**\n         * Checks whether of not the implicit returning is consistent if the last\n         * code path segment is reachable.\n         *\n         * @param {ASTNode} node - A program/function node to check.\n         * @returns {void}\n         */\n        function checkLastSegment(node) {\n            let loc, name;\n\n            /*\n             * Skip if it expected no return value or unreachable.\n             * When unreachable, all paths are returned or thrown.\n             */\n            if (!funcInfo.hasReturnValue ||\n                funcInfo.codePath.currentSegments.every(isUnreachable) ||\n                astUtils.isES5Constructor(node) ||\n                isClassConstructor(node)\n            ) {\n                return;\n            }\n\n            // Adjust a location and a message.\n            if (node.type === \"Program\") {\n\n                // The head of program.\n                loc = { line: 1, column: 0 };\n                name = \"program\";\n            } else if (node.type === \"ArrowFunctionExpression\") {\n\n                // `=>` token\n                loc = context.getSourceCode().getTokenBefore(node.body, astUtils.isArrowToken).loc.start;\n            } else if (\n                node.parent.type === \"MethodDefinition\" ||\n                (node.parent.type === \"Property\" && node.parent.method)\n            ) {\n\n                // Method name.\n                loc = node.parent.key.loc.start;\n            } else {\n\n                // Function name or `function` keyword.\n                loc = (node.id || node).loc.start;\n            }\n\n            if (!name) {\n                name = astUtils.getFunctionNameWithKind(node);\n            }\n\n            // Reports.\n            context.report({\n                node,\n                loc,\n                message: \"Expected to return a value at the end of {{name}}.\",\n                data: { name }\n            });\n        }\n\n        return {\n\n            // Initializes/Disposes state of each code path.\n            onCodePathStart(codePath, node) {\n                funcInfo = {\n                    upper: funcInfo,\n                    codePath,\n                    hasReturn: false,\n                    hasReturnValue: false,\n                    message: \"\",\n                    node\n                };\n            },\n            onCodePathEnd() {\n                funcInfo = funcInfo.upper;\n            },\n\n            // Reports a given return statement if it's inconsistent.\n            ReturnStatement(node) {\n                const argument = node.argument;\n                let hasReturnValue = Boolean(argument);\n\n                if (treatUndefinedAsUnspecified && hasReturnValue) {\n                    hasReturnValue = !isIdentifier(argument, \"undefined\") && argument.operator !== \"void\";\n                }\n\n                if (!funcInfo.hasReturn) {\n                    funcInfo.hasReturn = true;\n                    funcInfo.hasReturnValue = hasReturnValue;\n                    funcInfo.message = \"{{name}} expected {{which}} return value.\";\n                    funcInfo.data = {\n                        name: funcInfo.node.type === \"Program\"\n                            ? \"Program\"\n                            : lodash.upperFirst(astUtils.getFunctionNameWithKind(funcInfo.node)),\n                        which: hasReturnValue ? \"a\" : \"no\"\n                    };\n                } else if (funcInfo.hasReturnValue !== hasReturnValue) {\n                    context.report({\n                        node,\n                        message: funcInfo.message,\n                        data: funcInfo.data\n                    });\n                }\n            },\n\n            // Reports a given program/function if the implicit returning is not consistent.\n            \"Program:exit\": checkLastSegment,\n            \"FunctionDeclaration:exit\": checkLastSegment,\n            \"FunctionExpression:exit\": checkLastSegment,\n            \"ArrowFunctionExpression:exit\": checkLastSegment\n        };\n    }\n};\n","consistent-this.js":"/**\n * @fileoverview Rule to enforce consistent naming of \"this\" context variables\n * @author Raphael Pigulla\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent naming when capturing the current execution context\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: {\n            type: \"array\",\n            items: {\n                type: \"string\",\n                minLength: 1\n            },\n            uniqueItems: true\n        }\n    },\n\n    create(context) {\n        let aliases = [];\n\n        if (context.options.length === 0) {\n            aliases.push(\"that\");\n        } else {\n            aliases = context.options;\n        }\n\n        /**\n         * Reports that a variable declarator or assignment expression is assigning\n         * a non-'this' value to the specified alias.\n         * @param {ASTNode} node - The assigning node.\n         * @param {string} alias - the name of the alias that was incorrectly used.\n         * @returns {void}\n         */\n        function reportBadAssignment(node, alias) {\n            context.report({ node, message: \"Designated alias '{{alias}}' is not assigned to 'this'.\", data: { alias } });\n        }\n\n        /**\n         * Checks that an assignment to an identifier only assigns 'this' to the\n         * appropriate alias, and the alias is only assigned to 'this'.\n         * @param {ASTNode} node - The assigning node.\n         * @param {Identifier} name - The name of the variable assigned to.\n         * @param {Expression} value - The value of the assignment.\n         * @returns {void}\n         */\n        function checkAssignment(node, name, value) {\n            const isThis = value.type === \"ThisExpression\";\n\n            if (aliases.indexOf(name) !== -1) {\n                if (!isThis || node.operator && node.operator !== \"=\") {\n                    reportBadAssignment(node, name);\n                }\n            } else if (isThis) {\n                context.report({ node, message: \"Unexpected alias '{{name}}' for 'this'.\", data: { name } });\n            }\n        }\n\n        /**\n         * Ensures that a variable declaration of the alias in a program or function\n         * is assigned to the correct value.\n         * @param {string} alias alias the check the assignment of.\n         * @param {Object} scope scope of the current code we are checking.\n         * @private\n         * @returns {void}\n         */\n        function checkWasAssigned(alias, scope) {\n            const variable = scope.set.get(alias);\n\n            if (!variable) {\n                return;\n            }\n\n            if (variable.defs.some(def => def.node.type === \"VariableDeclarator\" &&\n                def.node.init !== null)) {\n                return;\n            }\n\n            // The alias has been declared and not assigned: check it was\n            // assigned later in the same scope.\n            if (!variable.references.some(reference => {\n                const write = reference.writeExpr;\n\n                return (\n                    reference.from === scope &&\n                    write && write.type === \"ThisExpression\" &&\n                    write.parent.operator === \"=\"\n                );\n            })) {\n                variable.defs.map(def => def.node).forEach(node => {\n                    reportBadAssignment(node, alias);\n                });\n            }\n        }\n\n        /**\n         * Check each alias to ensure that is was assinged to the correct value.\n         * @returns {void}\n         */\n        function ensureWasAssigned() {\n            const scope = context.getScope();\n\n            aliases.forEach(alias => {\n                checkWasAssigned(alias, scope);\n            });\n        }\n\n        return {\n            \"Program:exit\": ensureWasAssigned,\n            \"FunctionExpression:exit\": ensureWasAssigned,\n            \"FunctionDeclaration:exit\": ensureWasAssigned,\n\n            VariableDeclarator(node) {\n                const id = node.id;\n                const isDestructuring =\n                    id.type === \"ArrayPattern\" || id.type === \"ObjectPattern\";\n\n                if (node.init !== null && !isDestructuring) {\n                    checkAssignment(node, id.name, node.init);\n                }\n            },\n\n            AssignmentExpression(node) {\n                if (node.left.type === \"Identifier\") {\n                    checkAssignment(node, node.left.name, node.right);\n                }\n            }\n        };\n\n    }\n};\n","constructor-super.js":"/**\n * @fileoverview A rule to verify `super()` callings in constructor.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a given code path segment is reachable or not.\n *\n * @param {CodePathSegment} segment - A code path segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Checks whether or not a given node is a constructor.\n * @param {ASTNode} node - A node to check. This node type is one of\n *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and\n *   `ArrowFunctionExpression`.\n * @returns {boolean} `true` if the node is a constructor.\n */\nfunction isConstructorFunction(node) {\n    return (\n        node.type === \"FunctionExpression\" &&\n        node.parent.type === \"MethodDefinition\" &&\n        node.parent.kind === \"constructor\"\n    );\n}\n\n/**\n * Checks whether a given node can be a constructor or not.\n *\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node can be a constructor.\n */\nfunction isPossibleConstructor(node) {\n    if (!node) {\n        return false;\n    }\n\n    switch (node.type) {\n        case \"ClassExpression\":\n        case \"FunctionExpression\":\n        case \"ThisExpression\":\n        case \"MemberExpression\":\n        case \"CallExpression\":\n        case \"NewExpression\":\n        case \"YieldExpression\":\n        case \"TaggedTemplateExpression\":\n        case \"MetaProperty\":\n            return true;\n\n        case \"Identifier\":\n            return node.name !== \"undefined\";\n\n        case \"AssignmentExpression\":\n            return isPossibleConstructor(node.right);\n\n        case \"LogicalExpression\":\n            return (\n                isPossibleConstructor(node.left) ||\n                isPossibleConstructor(node.right)\n            );\n\n        case \"ConditionalExpression\":\n            return (\n                isPossibleConstructor(node.alternate) ||\n                isPossibleConstructor(node.consequent)\n            );\n\n        case \"SequenceExpression\": {\n            const lastExpression = node.expressions[node.expressions.length - 1];\n\n            return isPossibleConstructor(lastExpression);\n        }\n\n        default:\n            return false;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require `super()` calls in constructors\",\n            category: \"ECMAScript 6\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /*\n         * {{hasExtends: boolean, scope: Scope, codePath: CodePath}[]}\n         * Information for each constructor.\n         * - upper:      Information of the upper constructor.\n         * - hasExtends: A flag which shows whether own class has a valid `extends`\n         *               part.\n         * - scope:      The scope of own class.\n         * - codePath:   The code path object of the constructor.\n         */\n        let funcInfo = null;\n\n        /*\n         * {Map<string, {calledInSomePaths: boolean, calledInEveryPaths: boolean}>}\n         * Information for each code path segment.\n         * - calledInSomePaths:  A flag of be called `super()` in some code paths.\n         * - calledInEveryPaths: A flag of be called `super()` in all code paths.\n         * - validNodes:\n         */\n        let segInfoMap = Object.create(null);\n\n        /**\n         * Gets the flag which shows `super()` is called in some paths.\n         * @param {CodePathSegment} segment - A code path segment to get.\n         * @returns {boolean} The flag which shows `super()` is called in some paths\n         */\n        function isCalledInSomePath(segment) {\n            return segment.reachable && segInfoMap[segment.id].calledInSomePaths;\n        }\n\n        /**\n         * Gets the flag which shows `super()` is called in all paths.\n         * @param {CodePathSegment} segment - A code path segment to get.\n         * @returns {boolean} The flag which shows `super()` is called in all paths.\n         */\n        function isCalledInEveryPath(segment) {\n\n            /*\n             * If specific segment is the looped segment of the current segment,\n             * skip the segment.\n             * If not skipped, this never becomes true after a loop.\n             */\n            if (segment.nextSegments.length === 1 &&\n                segment.nextSegments[0].isLoopedPrevSegment(segment)\n            ) {\n                return true;\n            }\n            return segment.reachable && segInfoMap[segment.id].calledInEveryPaths;\n        }\n\n        return {\n\n            /**\n             * Stacks a constructor information.\n             * @param {CodePath} codePath - A code path which was started.\n             * @param {ASTNode} node - The current node.\n             * @returns {void}\n             */\n            onCodePathStart(codePath, node) {\n                if (isConstructorFunction(node)) {\n\n                    // Class > ClassBody > MethodDefinition > FunctionExpression\n                    const classNode = node.parent.parent.parent;\n                    const superClass = classNode.superClass;\n\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: true,\n                        hasExtends: Boolean(superClass),\n                        superIsConstructor: isPossibleConstructor(superClass),\n                        codePath\n                    };\n                } else {\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: false,\n                        hasExtends: false,\n                        superIsConstructor: false,\n                        codePath\n                    };\n                }\n            },\n\n            /**\n             * Pops a constructor information.\n             * And reports if `super()` lacked.\n             * @param {CodePath} codePath - A code path which was ended.\n             * @param {ASTNode} node - The current node.\n             * @returns {void}\n             */\n            onCodePathEnd(codePath, node) {\n                const hasExtends = funcInfo.hasExtends;\n\n                // Pop.\n                funcInfo = funcInfo.upper;\n\n                if (!hasExtends) {\n                    return;\n                }\n\n                // Reports if `super()` lacked.\n                const segments = codePath.returnedSegments;\n                const calledInEveryPaths = segments.every(isCalledInEveryPath);\n                const calledInSomePaths = segments.some(isCalledInSomePath);\n\n                if (!calledInEveryPaths) {\n                    context.report({\n                        message: calledInSomePaths\n                            ? \"Lacked a call of 'super()' in some code paths.\"\n                            : \"Expected to call 'super()'.\",\n                        node: node.parent\n                    });\n                }\n            },\n\n            /**\n             * Initialize information of a given code path segment.\n             * @param {CodePathSegment} segment - A code path segment to initialize.\n             * @returns {void}\n             */\n            onCodePathSegmentStart(segment) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Initialize info.\n                const info = segInfoMap[segment.id] = {\n                    calledInSomePaths: false,\n                    calledInEveryPaths: false,\n                    validNodes: []\n                };\n\n                // When there are previous segments, aggregates these.\n                const prevSegments = segment.prevSegments;\n\n                if (prevSegments.length > 0) {\n                    info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n                    info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\n                }\n            },\n\n            /**\n             * Update information of the code path segment when a code path was\n             * looped.\n             * @param {CodePathSegment} fromSegment - The code path segment of the\n             *      end of a loop.\n             * @param {CodePathSegment} toSegment - A code path segment of the head\n             *      of a loop.\n             * @returns {void}\n             */\n            onCodePathSegmentLoop(fromSegment, toSegment) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Update information inside of the loop.\n                const isRealLoop = toSegment.prevSegments.length >= 2;\n\n                funcInfo.codePath.traverseSegments(\n                    { first: toSegment, last: fromSegment },\n                    segment => {\n                        const info = segInfoMap[segment.id];\n                        const prevSegments = segment.prevSegments;\n\n                        // Updates flags.\n                        info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n                        info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\n\n                        // If flags become true anew, reports the valid nodes.\n                        if (info.calledInSomePaths || isRealLoop) {\n                            const nodes = info.validNodes;\n\n                            info.validNodes = [];\n\n                            for (let i = 0; i < nodes.length; ++i) {\n                                const node = nodes[i];\n\n                                context.report({\n                                    message: \"Unexpected duplicate 'super()'.\",\n                                    node\n                                });\n                            }\n                        }\n                    }\n                );\n            },\n\n            /**\n             * Checks for a call of `super()`.\n             * @param {ASTNode} node - A CallExpression node to check.\n             * @returns {void}\n             */\n            \"CallExpression:exit\"(node) {\n                if (!(funcInfo && funcInfo.isConstructor)) {\n                    return;\n                }\n\n                // Skips except `super()`.\n                if (node.callee.type !== \"Super\") {\n                    return;\n                }\n\n                // Reports if needed.\n                if (funcInfo.hasExtends) {\n                    const segments = funcInfo.codePath.currentSegments;\n                    let duplicate = false;\n                    let info = null;\n\n                    for (let i = 0; i < segments.length; ++i) {\n                        const segment = segments[i];\n\n                        if (segment.reachable) {\n                            info = segInfoMap[segment.id];\n\n                            duplicate = duplicate || info.calledInSomePaths;\n                            info.calledInSomePaths = info.calledInEveryPaths = true;\n                        }\n                    }\n\n                    if (info) {\n                        if (duplicate) {\n                            context.report({\n                                message: \"Unexpected duplicate 'super()'.\",\n                                node\n                            });\n                        } else if (!funcInfo.superIsConstructor) {\n                            context.report({\n                                message: \"Unexpected 'super()' because 'super' is not a constructor.\",\n                                node\n                            });\n                        } else {\n                            info.validNodes.push(node);\n                        }\n                    }\n                } else if (funcInfo.codePath.currentSegments.some(isReachable)) {\n                    context.report({\n                        message: \"Unexpected 'super()'.\",\n                        node\n                    });\n                }\n            },\n\n            /**\n             * Set the mark to the returned path as `super()` was called.\n             * @param {ASTNode} node - A ReturnStatement node to check.\n             * @returns {void}\n             */\n            ReturnStatement(node) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Skips if no argument.\n                if (!node.argument) {\n                    return;\n                }\n\n                // Returning argument is a substitute of 'super()'.\n                const segments = funcInfo.codePath.currentSegments;\n\n                for (let i = 0; i < segments.length; ++i) {\n                    const segment = segments[i];\n\n                    if (segment.reachable) {\n                        const info = segInfoMap[segment.id];\n\n                        info.calledInSomePaths = info.calledInEveryPaths = true;\n                    }\n                }\n            },\n\n            /**\n             * Resets state.\n             * @returns {void}\n             */\n            \"Program:exit\"() {\n                segInfoMap = Object.create(null);\n            }\n        };\n    }\n};\n","curly.js":"/**\n * @fileoverview Rule to flag statements without curly braces\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent brace style for all control statements\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"all\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"multi\", \"multi-line\", \"multi-or-nest\"]\n                        },\n                        {\n                            enum: [\"consistent\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        const multiOnly = (context.options[0] === \"multi\");\n        const multiLine = (context.options[0] === \"multi-line\");\n        const multiOrNest = (context.options[0] === \"multi-or-nest\");\n        const consistent = (context.options[1] === \"consistent\");\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Determines if a given node is a one-liner that's on the same line as it's preceding code.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node is a one-liner that's on the same line as it's preceding code.\n         * @private\n         */\n        function isCollapsedOneLiner(node) {\n            const before = sourceCode.getTokenBefore(node);\n            const last = sourceCode.getLastToken(node);\n            const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;\n\n            return before.loc.start.line === lastExcludingSemicolon.loc.end.line;\n        }\n\n        /**\n         * Determines if a given node is a one-liner.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node is a one-liner.\n         * @private\n         */\n        function isOneLiner(node) {\n            const first = sourceCode.getFirstToken(node),\n                last = sourceCode.getLastToken(node);\n\n            return first.loc.start.line === last.loc.end.line;\n        }\n\n        /**\n         * Checks if the given token is an `else` token or not.\n         *\n         * @param {Token} token - The token to check.\n         * @returns {boolean} `true` if the token is an `else` token.\n         */\n        function isElseKeywordToken(token) {\n            return token.value === \"else\" && token.type === \"Keyword\";\n        }\n\n        /**\n         * Gets the `else` keyword token of a given `IfStatement` node.\n         * @param {ASTNode} node - A `IfStatement` node to get.\n         * @returns {Token} The `else` keyword token.\n         */\n        function getElseKeyword(node) {\n            return node.alternate && sourceCode.getFirstTokenBetween(node.consequent, node.alternate, isElseKeywordToken);\n        }\n\n        /**\n         * Checks a given IfStatement node requires braces of the consequent chunk.\n         * This returns `true` when below:\n         *\n         * 1. The given node has the `alternate` node.\n         * 2. There is a `IfStatement` which doesn't have `alternate` node in the\n         *    trailing statement chain of the `consequent` node.\n         *\n         * @param {ASTNode} node - A IfStatement node to check.\n         * @returns {boolean} `true` if the node requires braces of the consequent chunk.\n         */\n        function requiresBraceOfConsequent(node) {\n            if (node.alternate && node.consequent.type === \"BlockStatement\") {\n                if (node.consequent.body.length >= 2) {\n                    return true;\n                }\n\n                node = node.consequent.body[0];\n                while (node) {\n                    if (node.type === \"IfStatement\" && !node.alternate) {\n                        return true;\n                    }\n                    node = astUtils.getTrailingStatement(node);\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Reports \"Expected { after ...\" error\n         * @param {ASTNode} node The node to report.\n         * @param {ASTNode} bodyNode The body node that is incorrectly missing curly brackets\n         * @param {string} name The name to report.\n         * @param {string} suffix Additional string to add to the end of a report.\n         * @returns {void}\n         * @private\n         */\n        function reportExpectedBraceError(node, bodyNode, name, suffix) {\n            context.report({\n                node,\n                loc: (name !== \"else\" ? node : getElseKeyword(node)).loc.start,\n                message: \"Expected { after '{{name}}'{{suffix}}.\",\n                data: {\n                    name,\n                    suffix: (suffix ? ` ${suffix}` : \"\")\n                },\n                fix: fixer => fixer.replaceText(bodyNode, `{${sourceCode.getText(bodyNode)}}`)\n            });\n        }\n\n        /**\n        * Determines if a semicolon needs to be inserted after removing a set of curly brackets, in order to avoid a SyntaxError.\n        * @param {Token} closingBracket The } token\n        * @returns {boolean} `true` if a semicolon needs to be inserted after the last statement in the block.\n        */\n        function needsSemicolon(closingBracket) {\n            const tokenBefore = sourceCode.getTokenBefore(closingBracket);\n            const tokenAfter = sourceCode.getTokenAfter(closingBracket);\n            const lastBlockNode = sourceCode.getNodeByRangeIndex(tokenBefore.range[0]);\n\n            if (astUtils.isSemicolonToken(tokenBefore)) {\n\n                // If the last statement already has a semicolon, don't add another one.\n                return false;\n            }\n\n            if (!tokenAfter) {\n\n                // If there are no statements after this block, there is no need to add a semicolon.\n                return false;\n            }\n\n            if (lastBlockNode.type === \"BlockStatement\" && lastBlockNode.parent.type !== \"FunctionExpression\" && lastBlockNode.parent.type !== \"ArrowFunctionExpression\") {\n\n                // If the last node surrounded by curly brackets is a BlockStatement (other than a FunctionExpression or an ArrowFunctionExpression),\n                // don't insert a semicolon. Otherwise, the semicolon would be parsed as a separate statement, which would cause\n                // a SyntaxError if it was followed by `else`.\n                return false;\n            }\n\n            if (tokenBefore.loc.end.line === tokenAfter.loc.start.line) {\n\n                // If the next token is on the same line, insert a semicolon.\n                return true;\n            }\n\n            if (/^[([/`+-]/.test(tokenAfter.value)) {\n\n                // If the next token starts with a character that would disrupt ASI, insert a semicolon.\n                return true;\n            }\n\n            if (tokenBefore.type === \"Punctuator\" && (tokenBefore.value === \"++\" || tokenBefore.value === \"--\")) {\n\n                // If the last token is ++ or --, insert a semicolon to avoid disrupting ASI.\n                return true;\n            }\n\n            // Otherwise, do not insert a semicolon.\n            return false;\n        }\n\n        /**\n         * Reports \"Unnecessary { after ...\" error\n         * @param {ASTNode} node The node to report.\n         * @param {ASTNode} bodyNode The block statement that is incorrectly surrounded by parens\n         * @param {string} name The name to report.\n         * @param {string} suffix Additional string to add to the end of a report.\n         * @returns {void}\n         * @private\n         */\n        function reportUnnecessaryBraceError(node, bodyNode, name, suffix) {\n            context.report({\n                node,\n                loc: (name !== \"else\" ? node : getElseKeyword(node)).loc.start,\n                message: \"Unnecessary { after '{{name}}'{{suffix}}.\",\n                data: {\n                    name,\n                    suffix: (suffix ? ` ${suffix}` : \"\")\n                },\n                fix(fixer) {\n\n                    // `do while` expressions sometimes need a space to be inserted after `do`.\n                    // e.g. `do{foo()} while (bar)` should be corrected to `do foo() while (bar)`\n                    const needsPrecedingSpace = node.type === \"DoWhileStatement\" &&\n                        sourceCode.getTokenBefore(bodyNode).range[1] === bodyNode.range[0] &&\n                        !astUtils.canTokensBeAdjacent(\"do\", sourceCode.getFirstToken(bodyNode, { skip: 1 }));\n\n                    const openingBracket = sourceCode.getFirstToken(bodyNode);\n                    const closingBracket = sourceCode.getLastToken(bodyNode);\n                    const lastTokenInBlock = sourceCode.getTokenBefore(closingBracket);\n\n                    if (needsSemicolon(closingBracket)) {\n\n                        /*\n                         * If removing braces would cause a SyntaxError due to multiple statements on the same line (or\n                         * change the semantics of the code due to ASI), don't perform a fix.\n                         */\n                        return null;\n                    }\n\n                    const resultingBodyText = sourceCode.getText().slice(openingBracket.range[1], lastTokenInBlock.range[0]) +\n                        sourceCode.getText(lastTokenInBlock) +\n                        sourceCode.getText().slice(lastTokenInBlock.range[1], closingBracket.range[0]);\n\n                    return fixer.replaceText(bodyNode, (needsPrecedingSpace ? \" \" : \"\") + resultingBodyText);\n                }\n            });\n        }\n\n        /**\n         * Prepares to check the body of a node to see if it's a block statement.\n         * @param {ASTNode} node The node to report if there's a problem.\n         * @param {ASTNode} body The body node to check for blocks.\n         * @param {string} name The name to report if there's a problem.\n         * @param {string} suffix Additional string to add to the end of a report.\n         * @returns {Object} a prepared check object, with \"actual\", \"expected\", \"check\" properties.\n         *   \"actual\" will be `true` or `false` whether the body is already a block statement.\n         *   \"expected\" will be `true` or `false` if the body should be a block statement or not, or\n         *   `null` if it doesn't matter, depending on the rule options. It can be modified to change\n         *   the final behavior of \"check\".\n         *   \"check\" will be a function reporting appropriate problems depending on the other\n         *   properties.\n         */\n        function prepareCheck(node, body, name, suffix) {\n            const hasBlock = (body.type === \"BlockStatement\");\n            let expected = null;\n\n            if (node.type === \"IfStatement\" && node.consequent === body && requiresBraceOfConsequent(node)) {\n                expected = true;\n            } else if (multiOnly) {\n                if (hasBlock && body.body.length === 1) {\n                    expected = false;\n                }\n            } else if (multiLine) {\n                if (!isCollapsedOneLiner(body)) {\n                    expected = true;\n                }\n            } else if (multiOrNest) {\n                if (hasBlock && body.body.length === 1 && isOneLiner(body.body[0])) {\n                    const leadingComments = sourceCode.getCommentsBefore(body.body[0]);\n\n                    expected = leadingComments.length > 0;\n                } else if (!isOneLiner(body)) {\n                    expected = true;\n                }\n            } else {\n                expected = true;\n            }\n\n            return {\n                actual: hasBlock,\n                expected,\n                check() {\n                    if (this.expected !== null && this.expected !== this.actual) {\n                        if (this.expected) {\n                            reportExpectedBraceError(node, body, name, suffix);\n                        } else {\n                            reportUnnecessaryBraceError(node, body, name, suffix);\n                        }\n                    }\n                }\n            };\n        }\n\n        /**\n         * Prepares to check the bodies of a \"if\", \"else if\" and \"else\" chain.\n         * @param {ASTNode} node The first IfStatement node of the chain.\n         * @returns {Object[]} prepared checks for each body of the chain. See `prepareCheck` for more\n         *   information.\n         */\n        function prepareIfChecks(node) {\n            const preparedChecks = [];\n\n            do {\n                preparedChecks.push(prepareCheck(node, node.consequent, \"if\", \"condition\"));\n                if (node.alternate && node.alternate.type !== \"IfStatement\") {\n                    preparedChecks.push(prepareCheck(node, node.alternate, \"else\"));\n                    break;\n                }\n                node = node.alternate;\n            } while (node);\n\n            if (consistent) {\n\n                /*\n                 * If any node should have or already have braces, make sure they\n                 * all have braces.\n                 * If all nodes shouldn't have braces, make sure they don't.\n                 */\n                const expected = preparedChecks.some(preparedCheck => {\n                    if (preparedCheck.expected !== null) {\n                        return preparedCheck.expected;\n                    }\n                    return preparedCheck.actual;\n                });\n\n                preparedChecks.forEach(preparedCheck => {\n                    preparedCheck.expected = expected;\n                });\n            }\n\n            return preparedChecks;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            IfStatement(node) {\n                if (node.parent.type !== \"IfStatement\") {\n                    prepareIfChecks(node).forEach(preparedCheck => {\n                        preparedCheck.check();\n                    });\n                }\n            },\n\n            WhileStatement(node) {\n                prepareCheck(node, node.body, \"while\", \"condition\").check();\n            },\n\n            DoWhileStatement(node) {\n                prepareCheck(node, node.body, \"do\").check();\n            },\n\n            ForStatement(node) {\n                prepareCheck(node, node.body, \"for\", \"condition\").check();\n            },\n\n            ForInStatement(node) {\n                prepareCheck(node, node.body, \"for-in\").check();\n            },\n\n            ForOfStatement(node) {\n                prepareCheck(node, node.body, \"for-of\").check();\n            }\n        };\n    }\n};\n","default-case.js":"/**\n * @fileoverview require default case in switch statements\n * @author Aliaksei Shytkin\n */\n\"use strict\";\n\nconst DEFAULT_COMMENT_PATTERN = /^no default$/i;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require `default` cases in `switch` statements\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                commentPattern: {\n                    type: \"string\"\n                }\n            },\n            additionalProperties: false\n        }]\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const commentPattern = options.commentPattern\n            ? new RegExp(options.commentPattern)\n            : DEFAULT_COMMENT_PATTERN;\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Shortcut to get last element of array\n         * @param  {*[]} collection Array\n         * @returns {*} Last element\n         */\n        function last(collection) {\n            return collection[collection.length - 1];\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            SwitchStatement(node) {\n\n                if (!node.cases.length) {\n\n                    /*\n                     * skip check of empty switch because there is no easy way\n                     * to extract comments inside it now\n                     */\n                    return;\n                }\n\n                const hasDefault = node.cases.some(v => v.test === null);\n\n                if (!hasDefault) {\n\n                    let comment;\n\n                    const lastCase = last(node.cases);\n                    const comments = sourceCode.getCommentsAfter(lastCase);\n\n                    if (comments.length) {\n                        comment = last(comments);\n                    }\n\n                    if (!comment || !commentPattern.test(comment.value.trim())) {\n                        context.report({ node, message: \"Expected a default case.\" });\n                    }\n                }\n            }\n        };\n    }\n};\n","dot-location.js":"/**\n * @fileoverview Validates newlines before and after dots\n * @author Greg Cochard\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent newlines before and after dots\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"object\", \"property\"]\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        const config = context.options[0];\n\n        // default to onObject if no preference is passed\n        const onObject = config === \"object\" || !config;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports if the dot between object and property is on the correct loccation.\n         * @param {ASTNode} obj The object owning the property.\n         * @param {ASTNode} prop The property of the object.\n         * @param {ASTNode} node The corresponding node of the token.\n         * @returns {void}\n         */\n        function checkDotLocation(obj, prop, node) {\n            const dot = sourceCode.getTokenBefore(prop);\n            const textBeforeDot = sourceCode.getText().slice(obj.range[1], dot.range[0]);\n            const textAfterDot = sourceCode.getText().slice(dot.range[1], prop.range[0]);\n\n            if (dot.type === \"Punctuator\" && dot.value === \".\") {\n                if (onObject) {\n                    if (!astUtils.isTokenOnSameLine(obj, dot)) {\n                        const neededTextAfterObj = astUtils.isDecimalInteger(obj) ? \" \" : \"\";\n\n                        context.report({\n                            node,\n                            loc: dot.loc.start,\n                            message: \"Expected dot to be on same line as object.\",\n                            fix: fixer => fixer.replaceTextRange([obj.range[1], prop.range[0]], `${neededTextAfterObj}.${textBeforeDot}${textAfterDot}`)\n                        });\n                    }\n                } else if (!astUtils.isTokenOnSameLine(dot, prop)) {\n                    context.report({\n                        node,\n                        loc: dot.loc.start,\n                        message: \"Expected dot to be on same line as property.\",\n                        fix: fixer => fixer.replaceTextRange([obj.range[1], prop.range[0]], `${textBeforeDot}${textAfterDot}.`)\n                    });\n                }\n            }\n        }\n\n        /**\n         * Checks the spacing of the dot within a member expression.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkNode(node) {\n            checkDotLocation(node.object, node.property, node);\n        }\n\n        return {\n            MemberExpression: checkNode\n        };\n    }\n};\n","dot-notation.js":"/**\n * @fileoverview Rule to warn about using dot notation instead of square bracket notation when possible.\n * @author Josh Perez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/;\nconst keywords = require(\"../util/keywords\");\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce dot notation whenever possible\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowKeywords: {\n                        type: \"boolean\"\n                    },\n                    allowPattern: {\n                        type: \"string\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const allowKeywords = options.allowKeywords === void 0 || !!options.allowKeywords;\n        const sourceCode = context.getSourceCode();\n\n        let allowPattern;\n\n        if (options.allowPattern) {\n            allowPattern = new RegExp(options.allowPattern);\n        }\n\n        /**\n        * Check if the property is valid dot notation\n        * @param {ASTNode} node The dot notation node\n        * @param {string} value Value which is to be checked\n        * @returns {void}\n        */\n        function checkComputedProperty(node, value) {\n            if (\n                validIdentifier.test(value) &&\n                (allowKeywords || keywords.indexOf(String(value)) === -1) &&\n                !(allowPattern && allowPattern.test(value))\n            ) {\n                const formattedValue = node.property.type === \"Literal\" ? JSON.stringify(value) : `\\`${value}\\``;\n\n                context.report({\n                    node: node.property,\n                    message: \"[{{propertyValue}}] is better written in dot notation.\",\n                    data: {\n                        propertyValue: formattedValue\n                    },\n                    fix(fixer) {\n                        const leftBracket = sourceCode.getTokenAfter(node.object, astUtils.isOpeningBracketToken);\n                        const rightBracket = sourceCode.getLastToken(node);\n\n                        if (sourceCode.getFirstTokenBetween(leftBracket, rightBracket, { includeComments: true, filter: astUtils.isCommentToken })) {\n\n                            // Don't perform any fixes if there are comments inside the brackets.\n                            return null;\n                        }\n\n                        const tokenAfterProperty = sourceCode.getTokenAfter(rightBracket);\n                        const needsSpaceAfterProperty = tokenAfterProperty &&\n                            rightBracket.range[1] === tokenAfterProperty.range[0] &&\n                            !astUtils.canTokensBeAdjacent(String(value), tokenAfterProperty);\n\n                        const textBeforeDot = astUtils.isDecimalInteger(node.object) ? \" \" : \"\";\n                        const textAfterProperty = needsSpaceAfterProperty ? \" \" : \"\";\n\n                        return fixer.replaceTextRange(\n                            [leftBracket.range[0], rightBracket.range[1]],\n                            `${textBeforeDot}.${value}${textAfterProperty}`\n                        );\n                    }\n                });\n            }\n        }\n\n        return {\n            MemberExpression(node) {\n                if (\n                    node.computed &&\n                    node.property.type === \"Literal\"\n                ) {\n                    checkComputedProperty(node, node.property.value);\n                }\n                if (\n                    node.computed &&\n                    node.property.type === \"TemplateLiteral\" &&\n                    node.property.expressions.length === 0\n                ) {\n                    checkComputedProperty(node, node.property.quasis[0].value.cooked);\n                }\n                if (\n                    !allowKeywords &&\n                    !node.computed &&\n                    keywords.indexOf(String(node.property.name)) !== -1\n                ) {\n                    context.report({\n                        node: node.property,\n                        message: \".{{propertyName}} is a syntax error.\",\n                        data: {\n                            propertyName: node.property.name\n                        },\n                        fix(fixer) {\n                            const dot = sourceCode.getTokenBefore(node.property);\n                            const textAfterDot = sourceCode.text.slice(dot.range[1], node.property.range[0]);\n\n                            if (textAfterDot.trim()) {\n\n                                // Don't perform any fixes if there are comments between the dot and the property name.\n                                return null;\n                            }\n\n                            if (node.object.type === \"Identifier\" && node.object.name === \"let\") {\n\n                                /*\n                                 * A statement that starts with `let[` is parsed as a destructuring variable declaration, not\n                                 * a MemberExpression.\n                                 */\n                                return null;\n                            }\n\n                            return fixer.replaceTextRange(\n                                [dot.range[0], node.property.range[1]],\n                                `[${textAfterDot}\"${node.property.name}\"]`\n                            );\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","eol-last.js":"/**\n * @fileoverview Require or disallow newline at the end of files\n * @author Nodeca Team <https://github.com/nodeca>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow newline at the end of files\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        fixable: \"whitespace\",\n        schema: [\n            {\n                enum: [\"always\", \"never\", \"unix\", \"windows\"]\n            }\n        ]\n    },\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: function checkBadEOF(node) {\n                const sourceCode = context.getSourceCode(),\n                    src = sourceCode.getText(),\n                    location = {\n                        column: lodash.last(sourceCode.lines).length,\n                        line: sourceCode.lines.length\n                    },\n                    LF = \"\\n\",\n                    CRLF = `\\r${LF}`,\n                    endsWithNewline = lodash.endsWith(src, LF);\n\n                let mode = context.options[0] || \"always\",\n                    appendCRLF = false;\n\n                if (mode === \"unix\") {\n\n                    // `\"unix\"` should behave exactly as `\"always\"`\n                    mode = \"always\";\n                }\n                if (mode === \"windows\") {\n\n                    // `\"windows\"` should behave exactly as `\"always\"`, but append CRLF in the fixer for backwards compatibility\n                    mode = \"always\";\n                    appendCRLF = true;\n                }\n                if (mode === \"always\" && !endsWithNewline) {\n\n                    // File is not newline-terminated, but should be\n                    context.report({\n                        node,\n                        loc: location,\n                        message: \"Newline required at end of file but not found.\",\n                        fix(fixer) {\n                            return fixer.insertTextAfterRange([0, src.length], appendCRLF ? CRLF : LF);\n                        }\n                    });\n                } else if (mode === \"never\" && endsWithNewline) {\n\n                    // File is newline-terminated, but shouldn't be\n                    context.report({\n                        node,\n                        loc: location,\n                        message: \"Newline not allowed at end of file.\",\n                        fix(fixer) {\n                            const finalEOLs = /(?:\\r?\\n)+$/,\n                                match = finalEOLs.exec(sourceCode.text),\n                                start = match.index,\n                                end = sourceCode.text.length;\n\n                            return fixer.replaceTextRange([start, end], \"\");\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","eqeqeq.js":"/**\n * @fileoverview Rule to flag statements that use != and == instead of !== and ===\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require the use of `===` and `!==`\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                null: {\n                                    enum: [\"always\", \"never\", \"ignore\"]\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    additionalItems: false\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"smart\", \"allow-null\"]\n                        }\n                    ],\n                    additionalItems: false\n                }\n            ]\n        },\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const config = context.options[0] || \"always\";\n        const options = context.options[1] || {};\n        const sourceCode = context.getSourceCode();\n\n        const nullOption = (config === \"always\")\n            ? options.null || \"always\"\n            : \"ignore\";\n        const enforceRuleForNull = (nullOption === \"always\");\n        const enforceInverseRuleForNull = (nullOption === \"never\");\n\n        /**\n         * Checks if an expression is a typeof expression\n         * @param  {ASTNode} node The node to check\n         * @returns {boolean} if the node is a typeof expression\n         */\n        function isTypeOf(node) {\n            return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n        }\n\n        /**\n         * Checks if either operand of a binary expression is a typeof operation\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} if one of the operands is typeof\n         * @private\n         */\n        function isTypeOfBinary(node) {\n            return isTypeOf(node.left) || isTypeOf(node.right);\n        }\n\n        /**\n         * Checks if operands are literals of the same type (via typeof)\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} if operands are of same type\n         * @private\n         */\n        function areLiteralsAndSameType(node) {\n            return node.left.type === \"Literal\" && node.right.type === \"Literal\" &&\n                    typeof node.left.value === typeof node.right.value;\n        }\n\n        /**\n         * Checks if one of the operands is a literal null\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} if operands are null\n         * @private\n         */\n        function isNullCheck(node) {\n            return astUtils.isNullLiteral(node.right) || astUtils.isNullLiteral(node.left);\n        }\n\n        /**\n         * Gets the location (line and column) of the binary expression's operator\n         * @param {ASTNode} node The binary expression node to check\n         * @param {string} operator The operator to find\n         * @returns {Object} { line, column } location of operator\n         * @private\n         */\n        function getOperatorLocation(node) {\n            const opToken = sourceCode.getTokenAfter(node.left);\n\n            return { line: opToken.loc.start.line, column: opToken.loc.start.column };\n        }\n\n        /**\n         * Reports a message for this rule.\n         * @param {ASTNode} node The binary expression node that was checked\n         * @param {string} expectedOperator The operator that was expected (either '==', '!=', '===', or '!==')\n         * @returns {void}\n         * @private\n         */\n        function report(node, expectedOperator) {\n            context.report({\n                node,\n                loc: getOperatorLocation(node),\n                message: \"Expected '{{expectedOperator}}' and instead saw '{{actualOperator}}'.\",\n                data: { expectedOperator, actualOperator: node.operator },\n                fix(fixer) {\n\n                    // If the comparison is a `typeof` comparison or both sides are literals with the same type, then it's safe to fix.\n                    if (isTypeOfBinary(node) || areLiteralsAndSameType(node)) {\n                        const operatorToken = sourceCode.getFirstTokenBetween(\n                            node.left,\n                            node.right,\n                            token => token.value === node.operator\n                        );\n\n                        return fixer.replaceText(operatorToken, expectedOperator);\n                    }\n                    return null;\n                }\n            });\n        }\n\n        return {\n            BinaryExpression(node) {\n                const isNull = isNullCheck(node);\n\n                if (node.operator !== \"==\" && node.operator !== \"!=\") {\n                    if (enforceInverseRuleForNull && isNull) {\n                        report(node, node.operator.slice(0, -1));\n                    }\n                    return;\n                }\n\n                if (config === \"smart\" && (isTypeOfBinary(node) ||\n                        areLiteralsAndSameType(node) || isNull)) {\n                    return;\n                }\n\n                if (!enforceRuleForNull && isNull) {\n                    return;\n                }\n\n                report(node, `${node.operator}=`);\n            }\n        };\n\n    }\n};\n","for-direction.js":"/**\n * @fileoverview enforce \"for\" loop update clause moving the counter in the right direction.(for-direction)\n * @author Aladdin-ADD<hh_2013@foxmail.com>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce \\\"for\\\" loop update clause moving the counter in the right direction.\",\n            category: \"Possible Errors\",\n            recommended: false\n        },\n        fixable: null,\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * report an error.\n         * @param {ASTNode} node the node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node,\n                message: \"The update clause in this loop moves the variable in the wrong direction.\"\n            });\n        }\n\n        /**\n         * check UpdateExpression add/sub the counter\n         * @param {ASTNode} update UpdateExpression to check\n         * @param {string} counter variable name to check\n         * @returns {int} if add return 1, if sub return -1, if nochange, return 0\n         */\n        function getUpdateDirection(update, counter) {\n            if (update.argument.type === \"Identifier\" && update.argument.name === counter) {\n                if (update.operator === \"++\") {\n                    return 1;\n                }\n                if (update.operator === \"--\") {\n                    return -1;\n                }\n            }\n            return 0;\n        }\n\n        /**\n         * check AssignmentExpression add/sub the counter\n         * @param {ASTNode} update AssignmentExpression to check\n         * @param {string} counter variable name to check\n         * @returns {int} if add return 1, if sub return -1, if nochange, return 0\n         */\n        function getAssignmentDirection(update, counter) {\n            if (update.left.name === counter) {\n                if (update.operator === \"+=\") {\n                    return 1;\n                }\n                if (update.operator === \"-=\") {\n                    return -1;\n                }\n            }\n            return 0;\n        }\n        return {\n            ForStatement(node) {\n\n                if (node.test && node.test.type === \"BinaryExpression\" && node.test.left.type === \"Identifier\" && node.update) {\n                    const counter = node.test.left.name;\n                    const operator = node.test.operator;\n                    const update = node.update;\n\n                    if (operator === \"<\" || operator === \"<=\") {\n\n                        // report error if update sub the counter (--, -=)\n                        if (update.type === \"UpdateExpression\" && getUpdateDirection(update, counter) < 0) {\n                            report(node);\n                        }\n\n                        if (update.type === \"AssignmentExpression\" && getAssignmentDirection(update, counter) < 0) {\n                            report(node);\n                        }\n                    } else if (operator === \">\" || operator === \">=\") {\n\n                        // report error if update add the counter (++, +=)\n                        if (update.type === \"UpdateExpression\" && getUpdateDirection(update, counter) > 0) {\n                            report(node);\n                        }\n\n                        if (update.type === \"AssignmentExpression\" && getAssignmentDirection(update, counter) > 0) {\n                            report(node);\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n","func-call-spacing.js":"/**\n * @fileoverview Rule to control spacing within function calls\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow spacing between function identifiers and their invocations\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"never\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                allowNewlines: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        }\n    },\n\n    create(context) {\n\n        const never = context.options[0] !== \"always\";\n        const allowNewlines = !never && context.options[1] && context.options[1].allowNewlines;\n        const sourceCode = context.getSourceCode();\n        const text = sourceCode.getText();\n\n        /**\n         * Check if open space is present in a function name\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkSpacing(node) {\n            const lastToken = sourceCode.getLastToken(node);\n            const lastCalleeToken = sourceCode.getLastToken(node.callee);\n            const parenToken = sourceCode.getFirstTokenBetween(lastCalleeToken, lastToken, astUtils.isOpeningParenToken);\n            const prevToken = parenToken && sourceCode.getTokenBefore(parenToken);\n\n            // Parens in NewExpression are optional\n            if (!(parenToken && parenToken.range[1] < node.range[1])) {\n                return;\n            }\n\n            const textBetweenTokens = text.slice(prevToken.range[1], parenToken.range[0]).replace(/\\/\\*.*?\\*\\//g, \"\");\n            const hasWhitespace = /\\s/.test(textBetweenTokens);\n            const hasNewline = hasWhitespace && astUtils.LINEBREAK_MATCHER.test(textBetweenTokens);\n\n            /*\n             * never allowNewlines hasWhitespace hasNewline message\n             * F     F             F             F          Missing space between function name and paren.\n             * F     F             F             T          (Invalid `!hasWhitespace && hasNewline`)\n             * F     F             T             T          Unexpected newline between function name and paren.\n             * F     F             T             F          (OK)\n             * F     T             T             F          (OK)\n             * F     T             T             T          (OK)\n             * F     T             F             T          (Invalid `!hasWhitespace && hasNewline`)\n             * F     T             F             F          Missing space between function name and paren.\n             * T     T             F             F          (Invalid `never && allowNewlines`)\n             * T     T             F             T          (Invalid `!hasWhitespace && hasNewline`)\n             * T     T             T             T          (Invalid `never && allowNewlines`)\n             * T     T             T             F          (Invalid `never && allowNewlines`)\n             * T     F             T             F          Unexpected space between function name and paren.\n             * T     F             T             T          Unexpected space between function name and paren.\n             * T     F             F             T          (Invalid `!hasWhitespace && hasNewline`)\n             * T     F             F             F          (OK)\n             *\n             * T                   T                        Unexpected space between function name and paren.\n             * F                   F                        Missing space between function name and paren.\n             * F     F                           T          Unexpected newline between function name and paren.\n             */\n\n            if (never && hasWhitespace) {\n                context.report({\n                    node,\n                    loc: lastCalleeToken.loc.start,\n                    message: \"Unexpected space between function name and paren.\",\n                    fix(fixer) {\n\n                        // Only autofix if there is no newline\n                        // https://github.com/eslint/eslint/issues/7787\n                        if (!hasNewline) {\n                            return fixer.removeRange([prevToken.range[1], parenToken.range[0]]);\n                        }\n\n                        return null;\n                    }\n                });\n            } else if (!never && !hasWhitespace) {\n                context.report({\n                    node,\n                    loc: lastCalleeToken.loc.start,\n                    message: \"Missing space between function name and paren.\",\n                    fix(fixer) {\n                        return fixer.insertTextBefore(parenToken, \" \");\n                    }\n                });\n            } else if (!never && !allowNewlines && hasNewline) {\n                context.report({\n                    node,\n                    loc: lastCalleeToken.loc.start,\n                    message: \"Unexpected newline between function name and paren.\",\n                    fix(fixer) {\n                        return fixer.replaceTextRange([prevToken.range[1], parenToken.range[0]], \" \");\n                    }\n                });\n            }\n        }\n\n        return {\n            CallExpression: checkSpacing,\n            NewExpression: checkSpacing\n        };\n\n    }\n};\n","func-name-matching.js":"/**\n * @fileoverview Rule to require function names to match the name of the variable or property to which they are assigned.\n * @author Annie Zhang, Pavel Strashkin\n */\n\n\"use strict\";\n\n//--------------------------------------------------------------------------\n// Requirements\n//--------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\nconst esutils = require(\"esutils\");\n\n//--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\n * Determines if a pattern is `module.exports` or `module[\"exports\"]`\n * @param {ASTNode} pattern The left side of the AssignmentExpression\n * @returns {boolean} True if the pattern is `module.exports` or `module[\"exports\"]`\n */\nfunction isModuleExports(pattern) {\n    if (pattern.type === \"MemberExpression\" && pattern.object.type === \"Identifier\" && pattern.object.name === \"module\") {\n\n        // module.exports\n        if (pattern.property.type === \"Identifier\" && pattern.property.name === \"exports\") {\n            return true;\n        }\n\n        // module[\"exports\"]\n        if (pattern.property.type === \"Literal\" && pattern.property.value === \"exports\") {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Determines if a string name is a valid identifier\n * @param {string} name The string to be checked\n * @param {int} ecmaVersion The ECMAScript version if specified in the parserOptions config\n * @returns {boolean} True if the string is a valid identifier\n */\nfunction isIdentifier(name, ecmaVersion) {\n    if (ecmaVersion >= 6) {\n        return esutils.keyword.isIdentifierES6(name);\n    }\n    return esutils.keyword.isIdentifierES5(name);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst alwaysOrNever = { enum: [\"always\", \"never\"] };\nconst optionsObject = {\n    type: \"object\",\n    properties: {\n        includeCommonJSModuleExports: {\n            type: \"boolean\"\n        }\n    },\n    additionalProperties: false\n};\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require function names to match the name of the variable or property to which they are assigned\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: {\n            anyOf: [{\n                type: \"array\",\n                additionalItems: false,\n                items: [alwaysOrNever, optionsObject]\n            }, {\n                type: \"array\",\n                additionalItems: false,\n                items: [optionsObject]\n            }]\n        }\n    },\n\n    create(context) {\n        const options = (typeof context.options[0] === \"object\" ? context.options[0] : context.options[1]) || {};\n        const nameMatches = typeof context.options[0] === \"string\" ? context.options[0] : \"always\";\n        const includeModuleExports = options.includeCommonJSModuleExports;\n        const ecmaVersion = context.parserOptions && context.parserOptions.ecmaVersion ? context.parserOptions.ecmaVersion : 5;\n\n        /**\n         * Compares identifiers based on the nameMatches option\n         * @param {string} x the first identifier\n         * @param {string} y the second identifier\n         * @returns {boolean} whether the two identifiers should warn.\n         */\n        function shouldWarn(x, y) {\n            return (nameMatches === \"always\" && x !== y) || (nameMatches === \"never\" && x === y);\n        }\n\n        /**\n         * Reports\n         * @param {ASTNode} node The node to report\n         * @param {string} name The variable or property name\n         * @param {string} funcName The function name\n         * @param {boolean} isProp True if the reported node is a property assignment\n         * @returns {void}\n         */\n        function report(node, name, funcName, isProp) {\n            let message;\n\n            if (nameMatches === \"always\" && isProp) {\n                message = \"Function name `{{funcName}}` should match property name `{{name}}`\";\n            } else if (nameMatches === \"always\") {\n                message = \"Function name `{{funcName}}` should match variable name `{{name}}`\";\n            } else if (isProp) {\n                message = \"Function name `{{funcName}}` should not match property name `{{name}}`\";\n            } else {\n                message = \"Function name `{{funcName}}` should not match variable name `{{name}}`\";\n            }\n            context.report({\n                node,\n                message,\n                data: {\n                    name,\n                    funcName\n                }\n            });\n        }\n\n        /**\n         * Determines whether a given node is a string literal\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} `true` if the node is a string literal\n         */\n        function isStringLiteral(node) {\n            return node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            VariableDeclarator(node) {\n                if (!node.init || node.init.type !== \"FunctionExpression\" || node.id.type !== \"Identifier\") {\n                    return;\n                }\n                if (node.init.id && shouldWarn(node.id.name, node.init.id.name)) {\n                    report(node, node.id.name, node.init.id.name, false);\n                }\n            },\n\n            AssignmentExpression(node) {\n                if (\n                    node.right.type !== \"FunctionExpression\" ||\n                    (node.left.computed && node.left.property.type !== \"Literal\") ||\n                    (!includeModuleExports && isModuleExports(node.left)) ||\n                    (node.left.type !== \"Identifier\" && node.left.type !== \"MemberExpression\")\n                ) {\n                    return;\n                }\n\n                const isProp = node.left.type === \"MemberExpression\";\n                const name = isProp ? astUtils.getStaticPropertyName(node.left) : node.left.name;\n\n                if (node.right.id && isIdentifier(name) && shouldWarn(name, node.right.id.name)) {\n                    report(node, name, node.right.id.name, isProp);\n                }\n            },\n\n            Property(node) {\n                if (node.value.type !== \"FunctionExpression\" || !node.value.id || node.computed && !isStringLiteral(node.key)) {\n                    return;\n                }\n                if (node.key.type === \"Identifier\" && shouldWarn(node.key.name, node.value.id.name)) {\n                    report(node, node.key.name, node.value.id.name, true);\n                } else if (\n                    isStringLiteral(node.key) &&\n                    isIdentifier(node.key.value, ecmaVersion) &&\n                    shouldWarn(node.key.value, node.value.id.name)\n                ) {\n                    report(node, node.key.value, node.value.id.name, true);\n                }\n            }\n        };\n    }\n};\n","func-names.js":"/**\n * @fileoverview Rule to warn when a function expression does not have a name.\n * @author Kyle T. Nunery\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n/**\n * Checks whether or not a given variable is a function name.\n * @param {eslint-scope.Variable} variable - A variable to check.\n * @returns {boolean} `true` if the variable is a function name.\n */\nfunction isFunctionName(variable) {\n    return variable && variable.defs[0].type === \"FunctionName\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow named `function` expressions\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"as-needed\", \"never\"]\n            }\n        ]\n    },\n\n    create(context) {\n        const never = context.options[0] === \"never\";\n        const asNeeded = context.options[0] === \"as-needed\";\n\n        /**\n         * Determines whether the current FunctionExpression node is a get, set, or\n         * shorthand method in an object literal or a class.\n         * @param {ASTNode} node - A node to check.\n         * @returns {boolean} True if the node is a get, set, or shorthand method.\n         */\n        function isObjectOrClassMethod(node) {\n            const parent = node.parent;\n\n            return (parent.type === \"MethodDefinition\" || (\n                parent.type === \"Property\" && (\n                    parent.method ||\n                    parent.kind === \"get\" ||\n                    parent.kind === \"set\"\n                )\n            ));\n        }\n\n        /**\n         * Determines whether the current FunctionExpression node has a name that would be\n         * inferred from context in a conforming ES6 environment.\n         * @param {ASTNode} node - A node to check.\n         * @returns {boolean} True if the node would have a name assigned automatically.\n         */\n        function hasInferredName(node) {\n            const parent = node.parent;\n\n            return isObjectOrClassMethod(node) ||\n                (parent.type === \"VariableDeclarator\" && parent.id.type === \"Identifier\" && parent.init === node) ||\n                (parent.type === \"Property\" && parent.value === node) ||\n                (parent.type === \"AssignmentExpression\" && parent.left.type === \"Identifier\" && parent.right === node) ||\n                (parent.type === \"ExportDefaultDeclaration\" && parent.declaration === node) ||\n                (parent.type === \"AssignmentPattern\" && parent.right === node);\n        }\n\n        return {\n            \"FunctionExpression:exit\"(node) {\n\n                // Skip recursive functions.\n                const nameVar = context.getDeclaredVariables(node)[0];\n\n                if (isFunctionName(nameVar) && nameVar.references.length > 0) {\n                    return;\n                }\n\n                const hasName = Boolean(node.id && node.id.name);\n                const name = astUtils.getFunctionNameWithKind(node);\n\n                if (never) {\n                    if (hasName) {\n                        context.report({\n                            node,\n                            message: \"Unexpected named {{name}}.\",\n                            data: { name }\n                        });\n                    }\n                } else {\n                    if (!hasName && (asNeeded ? !hasInferredName(node) : !isObjectOrClassMethod(node))) {\n                        context.report({\n                            node,\n                            message: \"Unexpected unnamed {{name}}.\",\n                            data: { name }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n","func-style.js":"/**\n * @fileoverview Rule to enforce a particular function style\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce the consistent use of either `function` declarations or expressions\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"declaration\", \"expression\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    allowArrowFunctions: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const style = context.options[0],\n            allowArrowFunctions = context.options[1] && context.options[1].allowArrowFunctions === true,\n            enforceDeclarations = (style === \"declaration\"),\n            stack = [];\n\n        const nodesToCheck = {\n            FunctionDeclaration(node) {\n                stack.push(false);\n\n                if (!enforceDeclarations && node.parent.type !== \"ExportDefaultDeclaration\") {\n                    context.report({ node, message: \"Expected a function expression.\" });\n                }\n            },\n            \"FunctionDeclaration:exit\"() {\n                stack.pop();\n            },\n\n            FunctionExpression(node) {\n                stack.push(false);\n\n                if (enforceDeclarations && node.parent.type === \"VariableDeclarator\") {\n                    context.report({ node: node.parent, message: \"Expected a function declaration.\" });\n                }\n            },\n            \"FunctionExpression:exit\"() {\n                stack.pop();\n            },\n\n            ThisExpression() {\n                if (stack.length > 0) {\n                    stack[stack.length - 1] = true;\n                }\n            }\n        };\n\n        if (!allowArrowFunctions) {\n            nodesToCheck.ArrowFunctionExpression = function() {\n                stack.push(false);\n            };\n\n            nodesToCheck[\"ArrowFunctionExpression:exit\"] = function(node) {\n                const hasThisExpr = stack.pop();\n\n                if (enforceDeclarations && !hasThisExpr && node.parent.type === \"VariableDeclarator\") {\n                    context.report({ node: node.parent, message: \"Expected a function declaration.\" });\n                }\n            };\n        }\n\n        return nodesToCheck;\n\n    }\n};\n","function-paren-newline.js":"/**\n * @fileoverview enforce consistent line breaks inside function parentheses\n * @author Teddy Katz\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent line breaks inside function parentheses\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        fixable: \"whitespace\",\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\", \"consistent\", \"multiline\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            minItems: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const rawOption = context.options[0] || \"multiline\";\n        const multilineOption = rawOption === \"multiline\";\n        const consistentOption = rawOption === \"consistent\";\n        let minItems;\n\n        if (typeof rawOption === \"object\") {\n            minItems = rawOption.minItems;\n        } else if (rawOption === \"always\") {\n            minItems = 0;\n        } else if (rawOption === \"never\") {\n            minItems = Infinity;\n        } else {\n            minItems = null;\n        }\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Determines whether there should be newlines inside function parens\n         * @param {ASTNode[]} elements The arguments or parameters in the list\n         * @param {boolean} hasLeftNewline `true` if the left paren has a newline in the current code.\n         * @returns {boolean} `true` if there should be newlines inside the function parens\n         */\n        function shouldHaveNewlines(elements, hasLeftNewline) {\n            if (multilineOption) {\n                return elements.some((element, index) => index !== elements.length - 1 && element.loc.end.line !== elements[index + 1].loc.start.line);\n            }\n            if (consistentOption) {\n                return hasLeftNewline;\n            }\n            return elements.length >= minItems;\n        }\n\n        /**\n         * Validates a list of arguments or parameters\n         * @param {Object} parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token\n         * @param {ASTNode[]} elements The arguments or parameters in the list\n         * @returns {void}\n         */\n        function validateParens(parens, elements) {\n            const leftParen = parens.leftParen;\n            const rightParen = parens.rightParen;\n            const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);\n            const tokenBeforeRightParen = sourceCode.getTokenBefore(rightParen);\n            const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);\n            const hasRightNewline = !astUtils.isTokenOnSameLine(tokenBeforeRightParen, rightParen);\n            const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);\n\n            if (hasLeftNewline && !needsNewlines) {\n                context.report({\n                    node: leftParen,\n                    message: \"Unexpected newline after '('.\",\n                    fix(fixer) {\n                        return sourceCode.getText().slice(leftParen.range[1], tokenAfterLeftParen.range[0]).trim()\n\n                            // If there is a comment between the ( and the first element, don't do a fix.\n                            ? null\n                            : fixer.removeRange([leftParen.range[1], tokenAfterLeftParen.range[0]]);\n                    }\n                });\n            } else if (!hasLeftNewline && needsNewlines) {\n                context.report({\n                    node: leftParen,\n                    message: \"Expected a newline after '('.\",\n                    fix: fixer => fixer.insertTextAfter(leftParen, \"\\n\")\n                });\n            }\n\n            if (hasRightNewline && !needsNewlines) {\n                context.report({\n                    node: rightParen,\n                    message: \"Unexpected newline before ')'.\",\n                    fix(fixer) {\n                        return sourceCode.getText().slice(tokenBeforeRightParen.range[1], rightParen.range[0]).trim()\n\n                            // If there is a comment between the last element and the ), don't do a fix.\n                            ? null\n                            : fixer.removeRange([tokenBeforeRightParen.range[1], rightParen.range[0]]);\n                    }\n                });\n            } else if (!hasRightNewline && needsNewlines) {\n                context.report({\n                    node: rightParen,\n                    message: \"Expected a newline before ')'.\",\n                    fix: fixer => fixer.insertTextBefore(rightParen, \"\\n\")\n                });\n            }\n        }\n\n        /**\n         * Gets the left paren and right paren tokens of a node.\n         * @param {ASTNode} node The node with parens\n         * @returns {Object} An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token.\n         * Can also return `null` if an expression has no parens (e.g. a NewExpression with no arguments, or an ArrowFunctionExpression\n         * with a single parameter)\n         */\n        function getParenTokens(node) {\n            switch (node.type) {\n                case \"NewExpression\":\n                    if (!node.arguments.length && !(\n                        astUtils.isOpeningParenToken(sourceCode.getLastToken(node, { skip: 1 })) &&\n                        astUtils.isClosingParenToken(sourceCode.getLastToken(node))\n                    )) {\n\n                        // If the NewExpression does not have parens (e.g. `new Foo`), return null.\n                        return null;\n                    }\n\n                    // falls through\n\n                case \"CallExpression\":\n                    return {\n                        leftParen: sourceCode.getTokenAfter(node.callee, astUtils.isOpeningParenToken),\n                        rightParen: sourceCode.getLastToken(node)\n                    };\n\n                case \"FunctionDeclaration\":\n                case \"FunctionExpression\": {\n                    const leftParen = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);\n                    const rightParen = node.params.length\n                        ? sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isClosingParenToken)\n                        : sourceCode.getTokenAfter(leftParen);\n\n                    return { leftParen, rightParen };\n                }\n\n                case \"ArrowFunctionExpression\": {\n                    const firstToken = sourceCode.getFirstToken(node);\n\n                    if (!astUtils.isOpeningParenToken(firstToken)) {\n\n                        // If the ArrowFunctionExpression has a single param without parens, return null.\n                        return null;\n                    }\n\n                    return {\n                        leftParen: firstToken,\n                        rightParen: sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken)\n                    };\n                }\n\n                default:\n                    throw new TypeError(`unexpected node with type ${node.type}`);\n            }\n        }\n\n        /**\n         * Validates the parentheses for a node\n         * @param {ASTNode} node The node with parens\n         * @returns {void}\n         */\n        function validateNode(node) {\n            const parens = getParenTokens(node);\n\n            if (parens) {\n                validateParens(parens, astUtils.isFunction(node) ? node.params : node.arguments);\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            ArrowFunctionExpression: validateNode,\n            CallExpression: validateNode,\n            FunctionDeclaration: validateNode,\n            FunctionExpression: validateNode,\n            NewExpression: validateNode\n        };\n    }\n};\n","generator-star-spacing.js":"/**\n * @fileoverview Rule to check the spacing around the * in generator functions.\n * @author Jamund Ferguson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst OVERRIDE_SCHEMA = {\n    oneOf: [\n        {\n            enum: [\"before\", \"after\", \"both\", \"neither\"]\n        },\n        {\n            type: \"object\",\n            properties: {\n                before: { type: \"boolean\" },\n                after: { type: \"boolean\" }\n            },\n            additionalProperties: false\n        }\n    ]\n};\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing around `*` operators in generator functions\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"before\", \"after\", \"both\", \"neither\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            before: { type: \"boolean\" },\n                            after: { type: \"boolean\" },\n                            named: OVERRIDE_SCHEMA,\n                            anonymous: OVERRIDE_SCHEMA,\n                            method: OVERRIDE_SCHEMA\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n\n        const optionDefinitions = {\n            before: { before: true, after: false },\n            after: { before: false, after: true },\n            both: { before: true, after: true },\n            neither: { before: false, after: false }\n        };\n\n        /**\n         * Returns resolved option definitions based on an option and defaults\n         * \n         * @param {any} option - The option object or string value\n         * @param {Object} defaults - The defaults to use if options are not present\n         * @returns {Object} the resolved object definition\n         */\n        function optionToDefinition(option, defaults) {\n            if (!option) {\n                return defaults;\n            }\n\n            return typeof option === \"string\"\n                ? optionDefinitions[option]\n                : Object.assign({}, defaults, option);\n        }\n\n        const modes = (function(option) {\n            option = option || {};\n            const defaults = optionToDefinition(option, optionDefinitions.before);\n\n            return {\n                named: optionToDefinition(option.named, defaults),\n                anonymous: optionToDefinition(option.anonymous, defaults),\n                method: optionToDefinition(option.method, defaults)\n            };\n        }(context.options[0]));\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Checks if the given token is a star token or not.\n         *\n         * @param {Token} token - The token to check.\n         * @returns {boolean} `true` if the token is a star token.\n         */\n        function isStarToken(token) {\n            return token.value === \"*\" && token.type === \"Punctuator\";\n        }\n\n        /**\n         * Gets the generator star token of the given function node.\n         *\n         * @param {ASTNode} node - The function node to get.\n         * @returns {Token} Found star token.\n         */\n        function getStarToken(node) {\n            return sourceCode.getFirstToken(\n                (node.parent.method || node.parent.type === \"MethodDefinition\") ? node.parent : node,\n                isStarToken\n            );\n        }\n\n        /**\n         * Checks the spacing between two tokens before or after the star token.\n         * \n         * @param {string} kind Either \"named\", \"anonymous\", or \"method\"\n         * @param {string} side Either \"before\" or \"after\".\n         * @param {Token} leftToken `function` keyword token if side is \"before\", or\n         *     star token if side is \"after\".\n         * @param {Token} rightToken Star token if side is \"before\", or identifier\n         *     token if side is \"after\".\n         * @returns {void}\n         */\n        function checkSpacing(kind, side, leftToken, rightToken) {\n            if (!!(rightToken.range[0] - leftToken.range[1]) !== modes[kind][side]) {\n                const after = leftToken.value === \"*\";\n                const spaceRequired = modes[kind][side];\n                const node = after ? leftToken : rightToken;\n                const type = spaceRequired ? \"Missing\" : \"Unexpected\";\n                const message = \"{{type}} space {{side}} *.\";\n                const data = {\n                    type,\n                    side\n                };\n\n                context.report({\n                    node,\n                    message,\n                    data,\n                    fix(fixer) {\n                        if (spaceRequired) {\n                            if (after) {\n                                return fixer.insertTextAfter(node, \" \");\n                            }\n                            return fixer.insertTextBefore(node, \" \");\n                        }\n                        return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Enforces the spacing around the star if node is a generator function.\n         * \n         * @param {ASTNode} node A function expression or declaration node.\n         * @returns {void}\n         */\n        function checkFunction(node) {\n            if (!node.generator) {\n                return;\n            }\n\n            const starToken = getStarToken(node);\n            const prevToken = sourceCode.getTokenBefore(starToken);\n            const nextToken = sourceCode.getTokenAfter(starToken);\n\n            let kind = \"named\";\n\n            if (node.parent.type === \"MethodDefinition\" || (node.parent.type === \"Property\" && node.parent.method)) {\n                kind = \"method\";\n            } else if (!node.id) {\n                kind = \"anonymous\";\n            }\n\n            // Only check before when preceded by `function`|`static` keyword\n            if (!(kind === \"method\" && starToken === sourceCode.getFirstToken(node.parent))) {\n                checkSpacing(kind, \"before\", prevToken, starToken);\n            }\n\n            checkSpacing(kind, \"after\", starToken, nextToken);\n        }\n\n        return {\n            FunctionDeclaration: checkFunction,\n            FunctionExpression: checkFunction\n        };\n\n    }\n};\n","getter-return.js":"/**\n * @fileoverview Enforces that a return statement is present in property getters.\n * @author Aladdin-ADD(hh_2013@foxmail.com)\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/;\n\n/**\n * Checks a given code path segment is reachable.\n *\n * @param {CodePathSegment} segment - A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Gets a readable location.\n *\n * - FunctionExpression -> the function name or `function` keyword.\n *\n * @param {ASTNode} node - A function node to get.\n * @returns {ASTNode|Token} The node or the token of a location.\n */\nfunction getId(node) {\n    return node.id || node;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce `return` statements in getters\",\n            category: \"Possible Errors\",\n            recommended: false\n        },\n        fixable: null,\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowImplicit: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const options = context.options[0] || { allowImplicit: false };\n\n        let funcInfo = {\n            upper: null,\n            codePath: null,\n            hasReturn: false,\n            shouldCheck: false,\n            node: null\n        };\n\n        /**\n         * Checks whether or not the last code path segment is reachable.\n         * Then reports this function if the segment is reachable.\n         *\n         * If the last code path segment is reachable, there are paths which are not\n         * returned or thrown.\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {void}\n         */\n        function checkLastSegment(node) {\n            if (funcInfo.shouldCheck &&\n                funcInfo.codePath.currentSegments.some(isReachable)\n            ) {\n                context.report({\n                    node,\n                    loc: getId(node).loc.start,\n                    message: funcInfo.hasReturn\n                        ? \"Expected {{name}} to always return a value.\"\n                        : \"Expected to return a value in {{name}}.\",\n                    data: {\n                        name: astUtils.getFunctionNameWithKind(funcInfo.node)\n                    }\n                });\n            }\n        }\n\n        /** Checks whether a node means a getter function.\n         * @param {ASTNode} node - a node to check.\n         * @returns {boolean} if node means a getter, return true; else return false.\n         */\n        function isGetter(node) {\n            const parent = node.parent;\n\n            if (TARGET_NODE_TYPE.test(node.type) && node.body.type === \"BlockStatement\") {\n                if (parent.kind === \"get\") {\n                    return true;\n                }\n                if (parent.type === \"Property\" && astUtils.getStaticPropertyName(parent) === \"get\" && parent.parent.type === \"ObjectExpression\") {\n\n                    // Object.defineProperty()\n                    if (parent.parent.parent.type === \"CallExpression\" &&\n                        astUtils.getStaticPropertyName(parent.parent.parent.callee) === \"defineProperty\") {\n                        return true;\n                    }\n\n                    // Object.defineProperties()\n                    if (parent.parent.parent.type === \"Property\" &&\n                        parent.parent.parent.parent.type === \"ObjectExpression\" &&\n                        parent.parent.parent.parent.parent.type === \"CallExpression\" &&\n                        astUtils.getStaticPropertyName(parent.parent.parent.parent.parent.callee) === \"defineProperties\") {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        return {\n\n            // Stacks this function's information.\n            onCodePathStart(codePath, node) {\n                funcInfo = {\n                    upper: funcInfo,\n                    codePath,\n                    hasReturn: false,\n                    shouldCheck: isGetter(node),\n                    node\n                };\n            },\n\n            // Pops this function's information.\n            onCodePathEnd() {\n                funcInfo = funcInfo.upper;\n            },\n\n            // Checks the return statement is valid.\n            ReturnStatement(node) {\n                if (funcInfo.shouldCheck) {\n                    funcInfo.hasReturn = true;\n\n                    // if allowImplicit: false, should also check node.argument\n                    if (!options.allowImplicit && !node.argument) {\n                        context.report({\n                            node,\n                            message: \"Expected to return a value in {{name}}.\",\n                            data: {\n                                name: astUtils.getFunctionNameWithKind(funcInfo.node)\n                            }\n                        });\n                    }\n                }\n            },\n\n            // Reports a given function if the last path is reachable.\n            \"FunctionExpression:exit\": checkLastSegment,\n            \"ArrowFunctionExpression:exit\": checkLastSegment\n        };\n    }\n};\n","global-require.js":"/**\n * @fileoverview Rule for disallowing require() outside of the top-level module context\n * @author Jamund Ferguson\n */\n\n\"use strict\";\n\nconst ACCEPTABLE_PARENTS = [\n    \"AssignmentExpression\",\n    \"VariableDeclarator\",\n    \"MemberExpression\",\n    \"ExpressionStatement\",\n    \"CallExpression\",\n    \"ConditionalExpression\",\n    \"Program\",\n    \"VariableDeclaration\"\n];\n\n/**\n * Finds the eslint-scope reference in the given scope.\n * @param {Object} scope The scope to search.\n * @param {ASTNode} node The identifier node.\n * @returns {Reference|null} Returns the found reference or null if none were found.\n */\nfunction findReference(scope, node) {\n    const references = scope.references.filter(reference => reference.identifier.range[0] === node.range[0] &&\n            reference.identifier.range[1] === node.range[1]);\n\n    /* istanbul ignore else: correctly returns null */\n    if (references.length === 1) {\n        return references[0];\n    }\n    return null;\n\n}\n\n/**\n * Checks if the given identifier node is shadowed in the given scope.\n * @param {Object} scope The current scope.\n * @param {ASTNode} node The identifier node to check.\n * @returns {boolean} Whether or not the name is shadowed.\n */\nfunction isShadowed(scope, node) {\n    const reference = findReference(scope, node);\n\n    return reference && reference.resolved && reference.resolved.defs.length > 0;\n}\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require `require()` calls to be placed at top-level module scope\",\n            category: \"Node.js and CommonJS\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        return {\n            CallExpression(node) {\n                const currentScope = context.getScope();\n\n                if (node.callee.name === \"require\" && !isShadowed(currentScope, node.callee)) {\n                    const isGoodRequire = context.getAncestors().every(parent => ACCEPTABLE_PARENTS.indexOf(parent.type) > -1);\n\n                    if (!isGoodRequire) {\n                        context.report({ node, message: \"Unexpected require().\" });\n                    }\n                }\n            }\n        };\n    }\n};\n","guard-for-in.js":"/**\n * @fileoverview Rule to flag for-in loops without if statements inside\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require `for-in` loops to include an `if` statement\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            ForInStatement(node) {\n\n                /*\n                 * If the for-in statement has {}, then the real body is the body\n                 * of the BlockStatement. Otherwise, just use body as provided.\n                 */\n                const body = node.body.type === \"BlockStatement\" ? node.body.body[0] : node.body;\n\n                if (body && body.type !== \"IfStatement\") {\n                    context.report({ node, message: \"The body of a for-in should be wrapped in an if statement to filter unwanted properties from the prototype.\" });\n                }\n            }\n        };\n\n    }\n};\n","handle-callback-err.js":"/**\n * @fileoverview Ensure handling of errors when we know they exist.\n * @author Jamund Ferguson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require error handling in callbacks\",\n            category: \"Node.js and CommonJS\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"string\"\n            }\n        ]\n    },\n\n    create(context) {\n\n        const errorArgument = context.options[0] || \"err\";\n\n        /**\n         * Checks if the given argument should be interpreted as a regexp pattern.\n         * @param {string} stringToCheck The string which should be checked.\n         * @returns {boolean} Whether or not the string should be interpreted as a pattern.\n         */\n        function isPattern(stringToCheck) {\n            const firstChar = stringToCheck[0];\n\n            return firstChar === \"^\";\n        }\n\n        /**\n         * Checks if the given name matches the configured error argument.\n         * @param {string} name The name which should be compared.\n         * @returns {boolean} Whether or not the given name matches the configured error variable name.\n         */\n        function matchesConfiguredErrorName(name) {\n            if (isPattern(errorArgument)) {\n                const regexp = new RegExp(errorArgument);\n\n                return regexp.test(name);\n            }\n            return name === errorArgument;\n        }\n\n        /**\n         * Get the parameters of a given function scope.\n         * @param {Object} scope The function scope.\n         * @returns {array} All parameters of the given scope.\n         */\n        function getParameters(scope) {\n            return scope.variables.filter(variable => variable.defs[0] && variable.defs[0].type === \"Parameter\");\n        }\n\n        /**\n         * Check to see if we're handling the error object properly.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         */\n        function checkForError(node) {\n            const scope = context.getScope(),\n                parameters = getParameters(scope),\n                firstParameter = parameters[0];\n\n            if (firstParameter && matchesConfiguredErrorName(firstParameter.name)) {\n                if (firstParameter.references.length === 0) {\n                    context.report({ node, message: \"Expected error to be handled.\" });\n                }\n            }\n        }\n\n        return {\n            FunctionDeclaration: checkForError,\n            FunctionExpression: checkForError,\n            ArrowFunctionExpression: checkForError\n        };\n\n    }\n};\n","id-blacklist.js":"/**\n * @fileoverview Rule that warns when identifier names that are\n * blacklisted in the configuration are used.\n * @author Keith Cirkel (http://keithcirkel.co.uk)\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow specified identifiers\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: {\n            type: \"array\",\n            items: {\n                type: \"string\"\n            },\n            uniqueItems: true\n        }\n    },\n\n    create(context) {\n\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const blacklist = context.options;\n\n\n        /**\n         * Checks if a string matches the provided pattern\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is a match\n         * @private\n         */\n        function isInvalid(name) {\n            return blacklist.indexOf(name) !== -1;\n        }\n\n        /**\n         * Verifies if we should report an error or not based on the effective\n         * parent node and the identifier name.\n         * @param {ASTNode} effectiveParent The effective parent node of the node to be reported\n         * @param {string} name The identifier name of the identifier node\n         * @returns {boolean} whether an error should be reported or not\n         */\n        function shouldReport(effectiveParent, name) {\n            return effectiveParent.type !== \"CallExpression\" &&\n                effectiveParent.type !== \"NewExpression\" &&\n                isInvalid(name);\n        }\n\n        /**\n         * Reports an AST node as a rule violation.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            context.report({\n                node,\n                message: \"Identifier '{{name}}' is blacklisted.\",\n                data: {\n                    name: node.name\n                }\n            });\n        }\n\n        return {\n\n            Identifier(node) {\n                const name = node.name,\n                    effectiveParent = (node.parent.type === \"MemberExpression\") ? node.parent.parent : node.parent;\n\n                // MemberExpressions get special rules\n                if (node.parent.type === \"MemberExpression\") {\n\n                    // Always check object names\n                    if (node.parent.object.type === \"Identifier\" &&\n                        node.parent.object.name === node.name) {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n\n                        // Report AssignmentExpressions only if they are the left side of the assignment\n                    } else if (effectiveParent.type === \"AssignmentExpression\" &&\n                        (effectiveParent.right.type !== \"MemberExpression\" ||\n                        effectiveParent.left.type === \"MemberExpression\" &&\n                        effectiveParent.left.property.name === node.name)) {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n                    }\n\n                // Properties have their own rules\n                } else if (node.parent.type === \"Property\") {\n\n                    if (shouldReport(effectiveParent, name)) {\n                        report(node);\n                    }\n\n                // Report anything that is a match and not a CallExpression\n                } else if (shouldReport(effectiveParent, name)) {\n                    report(node);\n                }\n            }\n\n        };\n\n    }\n};\n","id-length.js":"/**\n * @fileoverview Rule that warns when identifier names are shorter or longer\n * than the values provided in configuration.\n * @author Burak Yigit Kaya aka BYK\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce minimum and maximum identifier lengths\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    min: {\n                        type: \"number\"\n                    },\n                    max: {\n                        type: \"number\"\n                    },\n                    exceptions: {\n                        type: \"array\",\n                        uniqueItems: true,\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    properties: {\n                        enum: [\"always\", \"never\"]\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const minLength = typeof options.min !== \"undefined\" ? options.min : 2;\n        const maxLength = typeof options.max !== \"undefined\" ? options.max : Infinity;\n        const properties = options.properties !== \"never\";\n        const exceptions = (options.exceptions ? options.exceptions : [])\n            .reduce((obj, item) => {\n                obj[item] = true;\n\n                return obj;\n            }, {});\n\n        const SUPPORTED_EXPRESSIONS = {\n            MemberExpression: properties && function(parent) {\n                return !parent.computed && (\n\n                    // regular property assignment\n                    (parent.parent.left === parent && parent.parent.type === \"AssignmentExpression\" ||\n\n                    // or the last identifier in an ObjectPattern destructuring\n                    parent.parent.type === \"Property\" && parent.parent.value === parent &&\n                    parent.parent.parent.type === \"ObjectPattern\" && parent.parent.parent.parent.left === parent.parent.parent)\n                );\n            },\n            AssignmentPattern(parent, node) {\n                return parent.left === node;\n            },\n            VariableDeclarator(parent, node) {\n                return parent.id === node;\n            },\n            Property: properties && function(parent, node) {\n                return parent.key === node;\n            },\n            ImportDefaultSpecifier: true,\n            RestElement: true,\n            FunctionExpression: true,\n            ArrowFunctionExpression: true,\n            ClassDeclaration: true,\n            FunctionDeclaration: true,\n            MethodDefinition: true,\n            CatchClause: true\n        };\n\n        return {\n            Identifier(node) {\n                const name = node.name;\n                const parent = node.parent;\n\n                const isShort = name.length < minLength;\n                const isLong = name.length > maxLength;\n\n                if (!(isShort || isLong) || exceptions[name]) {\n                    return; // Nothing to report\n                }\n\n                const isValidExpression = SUPPORTED_EXPRESSIONS[parent.type];\n\n                if (isValidExpression && (isValidExpression === true || isValidExpression(parent, node))) {\n                    context.report({\n                        node,\n                        message: isShort\n                            ? \"Identifier name '{{name}}' is too short (< {{min}}).\"\n                            : \"Identifier name '{{name}}' is too long (> {{max}}).\",\n                        data: { name, min: minLength, max: maxLength }\n                    });\n                }\n            }\n        };\n    }\n};\n","id-match.js":"/**\n * @fileoverview Rule to flag non-matching identifiers\n * @author Matthieu Larcher\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require identifiers to match a specified regular expression\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"string\"\n            },\n            {\n                type: \"object\",\n                properties: {\n                    properties: {\n                        type: \"boolean\"\n                    }\n                }\n            }\n        ]\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const pattern = context.options[0] || \"^.+$\",\n            regexp = new RegExp(pattern);\n\n        const options = context.options[1] || {},\n            properties = !!options.properties,\n            onlyDeclarations = !!options.onlyDeclarations;\n\n        /**\n         * Checks if a string matches the provided pattern\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is a match\n         * @private\n         */\n        function isInvalid(name) {\n            return !regexp.test(name);\n        }\n\n        /**\n         * Verifies if we should report an error or not based on the effective\n         * parent node and the identifier name.\n         * @param {ASTNode} effectiveParent The effective parent node of the node to be reported\n         * @param {string} name The identifier name of the identifier node\n         * @returns {boolean} whether an error should be reported or not\n         */\n        function shouldReport(effectiveParent, name) {\n            return effectiveParent.type !== \"CallExpression\" &&\n                effectiveParent.type !== \"NewExpression\" &&\n                isInvalid(name);\n        }\n\n        /**\n         * Reports an AST node as a rule violation.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            context.report({\n                node,\n                message: \"Identifier '{{name}}' does not match the pattern '{{pattern}}'.\",\n                data: {\n                    name: node.name,\n                    pattern\n                }\n            });\n        }\n\n        return {\n\n            Identifier(node) {\n                const name = node.name,\n                    parent = node.parent,\n                    effectiveParent = (parent.type === \"MemberExpression\") ? parent.parent : parent;\n\n                if (parent.type === \"MemberExpression\") {\n\n                    if (!properties) {\n                        return;\n                    }\n\n                    // Always check object names\n                    if (parent.object.type === \"Identifier\" &&\n                        parent.object.name === name) {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n\n                    // Report AssignmentExpressions only if they are the left side of the assignment\n                    } else if (effectiveParent.type === \"AssignmentExpression\" &&\n                        (effectiveParent.right.type !== \"MemberExpression\" ||\n                        effectiveParent.left.type === \"MemberExpression\" &&\n                        effectiveParent.left.property.name === name)) {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n                    }\n\n                } else if (parent.type === \"Property\") {\n\n                    if (!properties || parent.key.name !== name) {\n                        return;\n                    }\n\n                    if (shouldReport(effectiveParent, name)) {\n                        report(node);\n                    }\n\n                } else {\n                    const isDeclaration = effectiveParent.type === \"FunctionDeclaration\" || effectiveParent.type === \"VariableDeclarator\";\n\n                    if (onlyDeclarations && !isDeclaration) {\n                        return;\n                    }\n\n                    if (shouldReport(effectiveParent, name)) {\n                        report(node);\n                    }\n                }\n            }\n\n        };\n\n    }\n};\n","indent-legacy.js":"/**\n * @fileoverview This option sets a specific tab width for your code\n *\n * This rule has been ported and modified from nodeca.\n * @author Vitaly Puzrin\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/* istanbul ignore next: this rule has known coverage issues, but it's deprecated and shouldn't be updated in the future anyway. */\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent indentation\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            replacedBy: [\"indent\"]\n        },\n\n        deprecated: true,\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"tab\"]\n                    },\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    SwitchCase: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    VariableDeclarator: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                type: \"object\",\n                                properties: {\n                                    var: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    let: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    const: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    }\n                                }\n                            }\n                        ]\n                    },\n                    outerIIFEBody: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    MemberExpression: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    FunctionDeclaration: {\n                        type: \"object\",\n                        properties: {\n                            parameters: {\n                                oneOf: [\n                                    {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    {\n                                        enum: [\"first\"]\n                                    }\n                                ]\n                            },\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        }\n                    },\n                    FunctionExpression: {\n                        type: \"object\",\n                        properties: {\n                            parameters: {\n                                oneOf: [\n                                    {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    {\n                                        enum: [\"first\"]\n                                    }\n                                ]\n                            },\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        }\n                    },\n                    CallExpression: {\n                        type: \"object\",\n                        properties: {\n                            parameters: {\n                                oneOf: [\n                                    {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    {\n                                        enum: [\"first\"]\n                                    }\n                                ]\n                            }\n                        }\n                    },\n                    ArrayExpression: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                enum: [\"first\"]\n                            }\n                        ]\n                    },\n                    ObjectExpression: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                enum: [\"first\"]\n                            }\n                        ]\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const DEFAULT_VARIABLE_INDENT = 1;\n        const DEFAULT_PARAMETER_INDENT = null; // For backwards compatibility, don't check parameter indentation unless specified in the config\n        const DEFAULT_FUNCTION_BODY_INDENT = 1;\n\n        let indentType = \"space\";\n        let indentSize = 4;\n        const options = {\n            SwitchCase: 0,\n            VariableDeclarator: {\n                var: DEFAULT_VARIABLE_INDENT,\n                let: DEFAULT_VARIABLE_INDENT,\n                const: DEFAULT_VARIABLE_INDENT\n            },\n            outerIIFEBody: null,\n            FunctionDeclaration: {\n                parameters: DEFAULT_PARAMETER_INDENT,\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            FunctionExpression: {\n                parameters: DEFAULT_PARAMETER_INDENT,\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            CallExpression: {\n                arguments: DEFAULT_PARAMETER_INDENT\n            },\n            ArrayExpression: 1,\n            ObjectExpression: 1\n        };\n\n        const sourceCode = context.getSourceCode();\n\n        if (context.options.length) {\n            if (context.options[0] === \"tab\") {\n                indentSize = 1;\n                indentType = \"tab\";\n            } else /* istanbul ignore else : this will be caught by options validation */ if (typeof context.options[0] === \"number\") {\n                indentSize = context.options[0];\n                indentType = \"space\";\n            }\n\n            if (context.options[1]) {\n                const opts = context.options[1];\n\n                options.SwitchCase = opts.SwitchCase || 0;\n                const variableDeclaratorRules = opts.VariableDeclarator;\n\n                if (typeof variableDeclaratorRules === \"number\") {\n                    options.VariableDeclarator = {\n                        var: variableDeclaratorRules,\n                        let: variableDeclaratorRules,\n                        const: variableDeclaratorRules\n                    };\n                } else if (typeof variableDeclaratorRules === \"object\") {\n                    Object.assign(options.VariableDeclarator, variableDeclaratorRules);\n                }\n\n                if (typeof opts.outerIIFEBody === \"number\") {\n                    options.outerIIFEBody = opts.outerIIFEBody;\n                }\n\n                if (typeof opts.MemberExpression === \"number\") {\n                    options.MemberExpression = opts.MemberExpression;\n                }\n\n                if (typeof opts.FunctionDeclaration === \"object\") {\n                    Object.assign(options.FunctionDeclaration, opts.FunctionDeclaration);\n                }\n\n                if (typeof opts.FunctionExpression === \"object\") {\n                    Object.assign(options.FunctionExpression, opts.FunctionExpression);\n                }\n\n                if (typeof opts.CallExpression === \"object\") {\n                    Object.assign(options.CallExpression, opts.CallExpression);\n                }\n\n                if (typeof opts.ArrayExpression === \"number\" || typeof opts.ArrayExpression === \"string\") {\n                    options.ArrayExpression = opts.ArrayExpression;\n                }\n\n                if (typeof opts.ObjectExpression === \"number\" || typeof opts.ObjectExpression === \"string\") {\n                    options.ObjectExpression = opts.ObjectExpression;\n                }\n            }\n        }\n\n        const caseIndentStore = {};\n\n        /**\n         * Creates an error message for a line, given the expected/actual indentation.\n         * @param {int} expectedAmount The expected amount of indentation characters for this line\n         * @param {int} actualSpaces The actual number of indentation spaces that were found on this line\n         * @param {int} actualTabs The actual number of indentation tabs that were found on this line\n         * @returns {string} An error message for this line\n         */\n        function createErrorMessage(expectedAmount, actualSpaces, actualTabs) {\n            const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? \"\" : \"s\"}`; // e.g. \"2 tabs\"\n            const foundSpacesWord = `space${actualSpaces === 1 ? \"\" : \"s\"}`; // e.g. \"space\"\n            const foundTabsWord = `tab${actualTabs === 1 ? \"\" : \"s\"}`; // e.g. \"tabs\"\n            let foundStatement;\n\n            if (actualSpaces > 0 && actualTabs > 0) {\n                foundStatement = `${actualSpaces} ${foundSpacesWord} and ${actualTabs} ${foundTabsWord}`; // e.g. \"1 space and 2 tabs\"\n            } else if (actualSpaces > 0) {\n\n                // Abbreviate the message if the expected indentation is also spaces.\n                // e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'\n                foundStatement = indentType === \"space\" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;\n            } else if (actualTabs > 0) {\n                foundStatement = indentType === \"tab\" ? actualTabs : `${actualTabs} ${foundTabsWord}`;\n            } else {\n                foundStatement = \"0\";\n            }\n\n            return `Expected indentation of ${expectedStatement} but found ${foundStatement}.`;\n        }\n\n        /**\n         * Reports a given indent violation\n         * @param {ASTNode} node Node violating the indent rule\n         * @param {int} needed Expected indentation character count\n         * @param {int} gottenSpaces Indentation space count in the actual node/code\n         * @param {int} gottenTabs Indentation tab count in the actual node/code\n         * @param {Object=} loc Error line and column location\n         * @param {boolean} isLastNodeCheck Is the error for last node check\n         * @param {int} lastNodeCheckEndOffset Number of charecters to skip from the end\n         * @returns {void}\n         */\n        function report(node, needed, gottenSpaces, gottenTabs, loc, isLastNodeCheck) {\n            if (gottenSpaces && gottenTabs) {\n\n                // To avoid conflicts with `no-mixed-spaces-and-tabs`, don't report lines that have both spaces and tabs.\n                return;\n            }\n\n            const desiredIndent = (indentType === \"space\" ? \" \" : \"\\t\").repeat(needed);\n\n            const textRange = isLastNodeCheck\n                ? [node.range[1] - node.loc.end.column, node.range[1] - node.loc.end.column + gottenSpaces + gottenTabs]\n                : [node.range[0] - node.loc.start.column, node.range[0] - node.loc.start.column + gottenSpaces + gottenTabs];\n\n            context.report({\n                node,\n                loc,\n                message: createErrorMessage(needed, gottenSpaces, gottenTabs),\n                fix: fixer => fixer.replaceTextRange(textRange, desiredIndent)\n            });\n        }\n\n        /**\n         * Get the actual indent of node\n         * @param {ASTNode|Token} node Node to examine\n         * @param {boolean} [byLastLine=false] get indent of node's last line\n         * @returns {Object} The node's indent. Contains keys `space` and `tab`, representing the indent of each character. Also\n         contains keys `goodChar` and `badChar`, where `goodChar` is the amount of the user's desired indentation character, and\n         `badChar` is the amount of the other indentation character.\n         */\n        function getNodeIndent(node, byLastLine) {\n            const token = byLastLine ? sourceCode.getLastToken(node) : sourceCode.getFirstToken(node);\n            const srcCharsBeforeNode = sourceCode.getText(token, token.loc.start.column).split(\"\");\n            const indentChars = srcCharsBeforeNode.slice(0, srcCharsBeforeNode.findIndex(char => char !== \" \" && char !== \"\\t\"));\n            const spaces = indentChars.filter(char => char === \" \").length;\n            const tabs = indentChars.filter(char => char === \"\\t\").length;\n\n            return {\n                space: spaces,\n                tab: tabs,\n                goodChar: indentType === \"space\" ? spaces : tabs,\n                badChar: indentType === \"space\" ? tabs : spaces\n            };\n        }\n\n        /**\n         * Checks node is the first in its own start line. By default it looks by start line.\n         * @param {ASTNode} node The node to check\n         * @param {boolean} [byEndLocation=false] Lookup based on start position or end\n         * @returns {boolean} true if its the first in the its start line\n         */\n        function isNodeFirstInLine(node, byEndLocation) {\n            const firstToken = byEndLocation === true ? sourceCode.getLastToken(node, 1) : sourceCode.getTokenBefore(node),\n                startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line,\n                endLine = firstToken ? firstToken.loc.end.line : -1;\n\n            return startLine !== endLine;\n        }\n\n        /**\n         * Check indent for node\n         * @param {ASTNode} node Node to check\n         * @param {int} neededIndent needed indent\n         * @param {boolean} [excludeCommas=false] skip comma on start of line\n         * @returns {void}\n         */\n        function checkNodeIndent(node, neededIndent) {\n            const actualIndent = getNodeIndent(node, false);\n\n            if (\n                node.type !== \"ArrayExpression\" &&\n                node.type !== \"ObjectExpression\" &&\n                (actualIndent.goodChar !== neededIndent || actualIndent.badChar !== 0) &&\n                isNodeFirstInLine(node)\n            ) {\n                report(node, neededIndent, actualIndent.space, actualIndent.tab);\n            }\n\n            if (node.type === \"IfStatement\" && node.alternate) {\n                const elseToken = sourceCode.getTokenBefore(node.alternate);\n\n                checkNodeIndent(elseToken, neededIndent);\n\n                if (!isNodeFirstInLine(node.alternate)) {\n                    checkNodeIndent(node.alternate, neededIndent);\n                }\n            }\n\n            if (node.type === \"TryStatement\" && node.handler) {\n                const catchToken = sourceCode.getFirstToken(node.handler);\n\n                checkNodeIndent(catchToken, neededIndent);\n            }\n\n            if (node.type === \"TryStatement\" && node.finalizer) {\n                const finallyToken = sourceCode.getTokenBefore(node.finalizer);\n\n                checkNodeIndent(finallyToken, neededIndent);\n            }\n\n            if (node.type === \"DoWhileStatement\") {\n                const whileToken = sourceCode.getTokenAfter(node.body);\n\n                checkNodeIndent(whileToken, neededIndent);\n            }\n        }\n\n        /**\n         * Check indent for nodes list\n         * @param {ASTNode[]} nodes list of node objects\n         * @param {int} indent needed indent\n         * @param {boolean} [excludeCommas=false] skip comma on start of line\n         * @returns {void}\n         */\n        function checkNodesIndent(nodes, indent) {\n            nodes.forEach(node => checkNodeIndent(node, indent));\n        }\n\n        /**\n         * Check last node line indent this detects, that block closed correctly\n         * @param {ASTNode} node Node to examine\n         * @param {int} lastLineIndent needed indent\n         * @returns {void}\n         */\n        function checkLastNodeLineIndent(node, lastLineIndent) {\n            const lastToken = sourceCode.getLastToken(node);\n            const endIndent = getNodeIndent(lastToken, true);\n\n            if ((endIndent.goodChar !== lastLineIndent || endIndent.badChar !== 0) && isNodeFirstInLine(node, true)) {\n                report(\n                    node,\n                    lastLineIndent,\n                    endIndent.space,\n                    endIndent.tab,\n                    { line: lastToken.loc.start.line, column: lastToken.loc.start.column },\n                    true\n                );\n            }\n        }\n\n        /**\n         * Check last node line indent this detects, that block closed correctly\n         * This function for more complicated return statement case, where closing parenthesis may be followed by ';'\n         * @param {ASTNode} node Node to examine\n         * @param {int} firstLineIndent first line needed indent\n         * @returns {void}\n         */\n        function checkLastReturnStatementLineIndent(node, firstLineIndent) {\n\n            // in case if return statement ends with ');' we have traverse back to ')'\n            // otherwise we'll measure indent for ';' and replace ')'\n            const lastToken = sourceCode.getLastToken(node, astUtils.isClosingParenToken);\n            const textBeforeClosingParenthesis = sourceCode.getText(lastToken, lastToken.loc.start.column).slice(0, -1);\n\n            if (textBeforeClosingParenthesis.trim()) {\n\n                // There are tokens before the closing paren, don't report this case\n                return;\n            }\n\n            const endIndent = getNodeIndent(lastToken, true);\n\n            if (endIndent.goodChar !== firstLineIndent) {\n                report(\n                    node,\n                    firstLineIndent,\n                    endIndent.space,\n                    endIndent.tab,\n                    { line: lastToken.loc.start.line, column: lastToken.loc.start.column },\n                    true\n                );\n            }\n        }\n\n        /**\n         * Check first node line indent is correct\n         * @param {ASTNode} node Node to examine\n         * @param {int} firstLineIndent needed indent\n         * @returns {void}\n         */\n        function checkFirstNodeLineIndent(node, firstLineIndent) {\n            const startIndent = getNodeIndent(node, false);\n\n            if ((startIndent.goodChar !== firstLineIndent || startIndent.badChar !== 0) && isNodeFirstInLine(node)) {\n                report(\n                    node,\n                    firstLineIndent,\n                    startIndent.space,\n                    startIndent.tab,\n                    { line: node.loc.start.line, column: node.loc.start.column }\n                );\n            }\n        }\n\n        /**\n         * Returns a parent node of given node based on a specified type\n         * if not present then return null\n         * @param {ASTNode} node node to examine\n         * @param {string} type type that is being looked for\n         * @param {string} stopAtList end points for the evaluating code\n         * @returns {ASTNode|void} if found then node otherwise null\n         */\n        function getParentNodeByType(node, type, stopAtList) {\n            let parent = node.parent;\n\n            if (!stopAtList) {\n                stopAtList = [\"Program\"];\n            }\n\n            while (parent.type !== type && stopAtList.indexOf(parent.type) === -1 && parent.type !== \"Program\") {\n                parent = parent.parent;\n            }\n\n            return parent.type === type ? parent : null;\n        }\n\n        /**\n         * Returns the VariableDeclarator based on the current node\n         * if not present then return null\n         * @param {ASTNode} node node to examine\n         * @returns {ASTNode|void} if found then node otherwise null\n         */\n        function getVariableDeclaratorNode(node) {\n            return getParentNodeByType(node, \"VariableDeclarator\");\n        }\n\n        /**\n         * Check to see if the node is part of the multi-line variable declaration.\n         * Also if its on the same line as the varNode\n         * @param {ASTNode} node node to check\n         * @param {ASTNode} varNode variable declaration node to check against\n         * @returns {boolean} True if all the above condition satisfy\n         */\n        function isNodeInVarOnTop(node, varNode) {\n            return varNode &&\n                varNode.parent.loc.start.line === node.loc.start.line &&\n                varNode.parent.declarations.length > 1;\n        }\n\n        /**\n         * Check to see if the argument before the callee node is multi-line and\n         * there should only be 1 argument before the callee node\n         * @param {ASTNode} node node to check\n         * @returns {boolean} True if arguments are multi-line\n         */\n        function isArgBeforeCalleeNodeMultiline(node) {\n            const parent = node.parent;\n\n            if (parent.arguments.length >= 2 && parent.arguments[1] === node) {\n                return parent.arguments[0].loc.end.line > parent.arguments[0].loc.start.line;\n            }\n\n            return false;\n        }\n\n        /**\n         * Check to see if the node is a file level IIFE\n         * @param {ASTNode} node The function node to check.\n         * @returns {boolean} True if the node is the outer IIFE\n         */\n        function isOuterIIFE(node) {\n            const parent = node.parent;\n            let stmt = parent.parent;\n\n            /*\n             * Verify that the node is an IIEF\n             */\n            if (\n                parent.type !== \"CallExpression\" ||\n                parent.callee !== node) {\n\n                return false;\n            }\n\n            /*\n             * Navigate legal ancestors to determine whether this IIEF is outer\n             */\n            while (\n                stmt.type === \"UnaryExpression\" && (\n                    stmt.operator === \"!\" ||\n                    stmt.operator === \"~\" ||\n                    stmt.operator === \"+\" ||\n                    stmt.operator === \"-\") ||\n                stmt.type === \"AssignmentExpression\" ||\n                stmt.type === \"LogicalExpression\" ||\n                stmt.type === \"SequenceExpression\" ||\n                stmt.type === \"VariableDeclarator\") {\n\n                stmt = stmt.parent;\n            }\n\n            return ((\n                stmt.type === \"ExpressionStatement\" ||\n                stmt.type === \"VariableDeclaration\") &&\n                stmt.parent && stmt.parent.type === \"Program\"\n            );\n        }\n\n        /**\n         * Check indent for function block content\n         * @param {ASTNode} node A BlockStatement node that is inside of a function.\n         * @returns {void}\n         */\n        function checkIndentInFunctionBlock(node) {\n\n            /*\n             * Search first caller in chain.\n             * Ex.:\n             *\n             * Models <- Identifier\n             *   .User\n             *   .find()\n             *   .exec(function() {\n             *   // function body\n             * });\n             *\n             * Looks for 'Models'\n             */\n            const calleeNode = node.parent; // FunctionExpression\n            let indent;\n\n            if (calleeNode.parent &&\n                (calleeNode.parent.type === \"Property\" ||\n                calleeNode.parent.type === \"ArrayExpression\")) {\n\n                // If function is part of array or object, comma can be put at left\n                indent = getNodeIndent(calleeNode, false).goodChar;\n            } else {\n\n                // If function is standalone, simple calculate indent\n                indent = getNodeIndent(calleeNode).goodChar;\n            }\n\n            if (calleeNode.parent.type === \"CallExpression\") {\n                const calleeParent = calleeNode.parent;\n\n                if (calleeNode.type !== \"FunctionExpression\" && calleeNode.type !== \"ArrowFunctionExpression\") {\n                    if (calleeParent && calleeParent.loc.start.line < node.loc.start.line) {\n                        indent = getNodeIndent(calleeParent).goodChar;\n                    }\n                } else {\n                    if (isArgBeforeCalleeNodeMultiline(calleeNode) &&\n                        calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line &&\n                        !isNodeFirstInLine(calleeNode)) {\n                        indent = getNodeIndent(calleeParent).goodChar;\n                    }\n                }\n            }\n\n            // function body indent should be indent + indent size, unless this\n            // is a FunctionDeclaration, FunctionExpression, or outer IIFE and the corresponding options are enabled.\n            let functionOffset = indentSize;\n\n            if (options.outerIIFEBody !== null && isOuterIIFE(calleeNode)) {\n                functionOffset = options.outerIIFEBody * indentSize;\n            } else if (calleeNode.type === \"FunctionExpression\") {\n                functionOffset = options.FunctionExpression.body * indentSize;\n            } else if (calleeNode.type === \"FunctionDeclaration\") {\n                functionOffset = options.FunctionDeclaration.body * indentSize;\n            }\n            indent += functionOffset;\n\n            // check if the node is inside a variable\n            const parentVarNode = getVariableDeclaratorNode(node);\n\n            if (parentVarNode && isNodeInVarOnTop(node, parentVarNode)) {\n                indent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n            }\n\n            if (node.body.length > 0) {\n                checkNodesIndent(node.body, indent);\n            }\n\n            checkLastNodeLineIndent(node, indent - functionOffset);\n        }\n\n\n        /**\n         * Checks if the given node starts and ends on the same line\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} Whether or not the block starts and ends on the same line.\n         */\n        function isSingleLineNode(node) {\n            const lastToken = sourceCode.getLastToken(node),\n                startLine = node.loc.start.line,\n                endLine = lastToken.loc.end.line;\n\n            return startLine === endLine;\n        }\n\n        /**\n         * Check to see if the first element inside an array is an object and on the same line as the node\n         * If the node is not an array then it will return false.\n         * @param {ASTNode} node node to check\n         * @returns {boolean} success/failure\n         */\n        function isFirstArrayElementOnSameLine(node) {\n            if (node.type === \"ArrayExpression\" && node.elements[0]) {\n                return node.elements[0].loc.start.line === node.loc.start.line && node.elements[0].type === \"ObjectExpression\";\n            }\n            return false;\n\n        }\n\n        /**\n         * Check indent for array block content or object block content\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function checkIndentInArrayOrObjectBlock(node) {\n\n            // Skip inline\n            if (isSingleLineNode(node)) {\n                return;\n            }\n\n            let elements = (node.type === \"ArrayExpression\") ? node.elements : node.properties;\n\n            // filter out empty elements example would be [ , 2] so remove first element as espree considers it as null\n            elements = elements.filter(elem => elem !== null);\n\n            let nodeIndent;\n            let elementsIndent;\n            const parentVarNode = getVariableDeclaratorNode(node);\n\n            // TODO - come up with a better strategy in future\n            if (isNodeFirstInLine(node)) {\n                const parent = node.parent;\n\n                nodeIndent = getNodeIndent(parent).goodChar;\n                if (!parentVarNode || parentVarNode.loc.start.line !== node.loc.start.line) {\n                    if (parent.type !== \"VariableDeclarator\" || parentVarNode === parentVarNode.parent.declarations[0]) {\n                        if (parent.type === \"VariableDeclarator\" && parentVarNode.loc.start.line === parent.loc.start.line) {\n                            nodeIndent += (indentSize * options.VariableDeclarator[parentVarNode.parent.kind]);\n                        } else if (parent.type === \"ObjectExpression\" || parent.type === \"ArrayExpression\") {\n                            const parentElements = node.parent.type === \"ObjectExpression\" ? node.parent.properties : node.parent.elements;\n\n                            if (parentElements[0] && parentElements[0].loc.start.line === parent.loc.start.line && parentElements[0].loc.end.line !== parent.loc.start.line) {\n\n                                /*\n                                 * If the first element of the array spans multiple lines, don't increase the expected indentation of the rest.\n                                 * e.g. [{\n                                 *        foo: 1\n                                 *      },\n                                 *      {\n                                 *        bar: 1\n                                 *      }]\n                                 * the second object is not indented.\n                                 */\n                            } else if (typeof options[parent.type] === \"number\") {\n                                nodeIndent += options[parent.type] * indentSize;\n                            } else {\n                                nodeIndent = parentElements[0].loc.start.column;\n                            }\n                        } else if (parent.type === \"CallExpression\" || parent.type === \"NewExpression\") {\n                            if (typeof options.CallExpression.arguments === \"number\") {\n                                nodeIndent += options.CallExpression.arguments * indentSize;\n                            } else if (options.CallExpression.arguments === \"first\") {\n                                if (parent.arguments.indexOf(node) !== -1) {\n                                    nodeIndent = parent.arguments[0].loc.start.column;\n                                }\n                            } else {\n                                nodeIndent += indentSize;\n                            }\n                        } else if (parent.type === \"LogicalExpression\" || parent.type === \"ArrowFunctionExpression\") {\n                            nodeIndent += indentSize;\n                        }\n                    }\n                } else if (!parentVarNode && !isFirstArrayElementOnSameLine(parent) && parent.type !== \"MemberExpression\" && parent.type !== \"ExpressionStatement\" && parent.type !== \"AssignmentExpression\" && parent.type !== \"Property\") {\n                    nodeIndent += indentSize;\n                }\n\n                checkFirstNodeLineIndent(node, nodeIndent);\n            } else {\n                nodeIndent = getNodeIndent(node).goodChar;\n            }\n\n            if (options[node.type] === \"first\") {\n                elementsIndent = elements.length ? elements[0].loc.start.column : 0; // If there are no elements, elementsIndent doesn't matter.\n            } else {\n                elementsIndent = nodeIndent + indentSize * options[node.type];\n            }\n\n            /*\n             * Check if the node is a multiple variable declaration; if so, then\n             * make sure indentation takes that into account.\n             */\n            if (isNodeInVarOnTop(node, parentVarNode)) {\n                elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n            }\n\n            checkNodesIndent(elements, elementsIndent);\n\n            if (elements.length > 0) {\n\n                // Skip last block line check if last item in same line\n                if (elements[elements.length - 1].loc.end.line === node.loc.end.line) {\n                    return;\n                }\n            }\n\n            checkLastNodeLineIndent(node, nodeIndent + (isNodeInVarOnTop(node, parentVarNode) ? options.VariableDeclarator[parentVarNode.parent.kind] * indentSize : 0));\n        }\n\n        /**\n         * Check if the node or node body is a BlockStatement or not\n         * @param {ASTNode} node node to test\n         * @returns {boolean} True if it or its body is a block statement\n         */\n        function isNodeBodyBlock(node) {\n            return node.type === \"BlockStatement\" || node.type === \"ClassBody\" || (node.body && node.body.type === \"BlockStatement\") ||\n                (node.consequent && node.consequent.type === \"BlockStatement\");\n        }\n\n        /**\n         * Check indentation for blocks\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function blockIndentationCheck(node) {\n\n            // Skip inline blocks\n            if (isSingleLineNode(node)) {\n                return;\n            }\n\n            if (node.parent && (\n                node.parent.type === \"FunctionExpression\" ||\n                node.parent.type === \"FunctionDeclaration\" ||\n                node.parent.type === \"ArrowFunctionExpression\")\n            ) {\n                checkIndentInFunctionBlock(node);\n                return;\n            }\n\n            let indent;\n            let nodesToCheck = [];\n\n            /*\n             * For this statements we should check indent from statement beginning,\n             * not from the beginning of the block.\n             */\n            const statementsWithProperties = [\n                \"IfStatement\", \"WhileStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\", \"DoWhileStatement\", \"ClassDeclaration\", \"TryStatement\"\n            ];\n\n            if (node.parent && statementsWithProperties.indexOf(node.parent.type) !== -1 && isNodeBodyBlock(node)) {\n                indent = getNodeIndent(node.parent).goodChar;\n            } else if (node.parent && node.parent.type === \"CatchClause\") {\n                indent = getNodeIndent(node.parent.parent).goodChar;\n            } else {\n                indent = getNodeIndent(node).goodChar;\n            }\n\n            if (node.type === \"IfStatement\" && node.consequent.type !== \"BlockStatement\") {\n                nodesToCheck = [node.consequent];\n            } else if (Array.isArray(node.body)) {\n                nodesToCheck = node.body;\n            } else {\n                nodesToCheck = [node.body];\n            }\n\n            if (nodesToCheck.length > 0) {\n                checkNodesIndent(nodesToCheck, indent + indentSize);\n            }\n\n            if (node.type === \"BlockStatement\") {\n                checkLastNodeLineIndent(node, indent);\n            }\n        }\n\n        /**\n         * Filter out the elements which are on the same line of each other or the node.\n         * basically have only 1 elements from each line except the variable declaration line.\n         * @param {ASTNode} node Variable declaration node\n         * @returns {ASTNode[]} Filtered elements\n         */\n        function filterOutSameLineVars(node) {\n            return node.declarations.reduce((finalCollection, elem) => {\n                const lastElem = finalCollection[finalCollection.length - 1];\n\n                if ((elem.loc.start.line !== node.loc.start.line && !lastElem) ||\n                    (lastElem && lastElem.loc.start.line !== elem.loc.start.line)) {\n                    finalCollection.push(elem);\n                }\n\n                return finalCollection;\n            }, []);\n        }\n\n        /**\n         * Check indentation for variable declarations\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function checkIndentInVariableDeclarations(node) {\n            const elements = filterOutSameLineVars(node);\n            const nodeIndent = getNodeIndent(node).goodChar;\n            const lastElement = elements[elements.length - 1];\n\n            const elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node.kind];\n\n            checkNodesIndent(elements, elementsIndent);\n\n            // Only check the last line if there is any token after the last item\n            if (sourceCode.getLastToken(node).loc.end.line <= lastElement.loc.end.line) {\n                return;\n            }\n\n            const tokenBeforeLastElement = sourceCode.getTokenBefore(lastElement);\n\n            if (tokenBeforeLastElement.value === \",\") {\n\n                // Special case for comma-first syntax where the semicolon is indented\n                checkLastNodeLineIndent(node, getNodeIndent(tokenBeforeLastElement).goodChar);\n            } else {\n                checkLastNodeLineIndent(node, elementsIndent - indentSize);\n            }\n        }\n\n        /**\n         * Check and decide whether to check for indentation for blockless nodes\n         * Scenarios are for or while statements without braces around them\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function blockLessNodes(node) {\n            if (node.body.type !== \"BlockStatement\") {\n                blockIndentationCheck(node);\n            }\n        }\n\n        /**\n         * Returns the expected indentation for the case statement\n         * @param {ASTNode} node node to examine\n         * @param {int} [switchIndent] indent for switch statement\n         * @returns {int} indent size\n         */\n        function expectedCaseIndent(node, switchIndent) {\n            const switchNode = (node.type === \"SwitchStatement\") ? node : node.parent;\n            let caseIndent;\n\n            if (caseIndentStore[switchNode.loc.start.line]) {\n                return caseIndentStore[switchNode.loc.start.line];\n            }\n            if (typeof switchIndent === \"undefined\") {\n                switchIndent = getNodeIndent(switchNode).goodChar;\n            }\n\n            if (switchNode.cases.length > 0 && options.SwitchCase === 0) {\n                caseIndent = switchIndent;\n            } else {\n                caseIndent = switchIndent + (indentSize * options.SwitchCase);\n            }\n\n            caseIndentStore[switchNode.loc.start.line] = caseIndent;\n            return caseIndent;\n\n        }\n\n        /**\n         * Checks wether a return statement is wrapped in ()\n         * @param {ASTNode} node node to examine\n         * @returns {boolean} the result\n         */\n        function isWrappedInParenthesis(node) {\n            const regex = /^return\\s*?\\(\\s*?\\);*?/;\n\n            const statementWithoutArgument = sourceCode.getText(node).replace(\n                sourceCode.getText(node.argument), \"\"\n            );\n\n            return regex.test(statementWithoutArgument);\n        }\n\n        return {\n            Program(node) {\n                if (node.body.length > 0) {\n\n                    // Root nodes should have no indent\n                    checkNodesIndent(node.body, getNodeIndent(node).goodChar);\n                }\n            },\n\n            ClassBody: blockIndentationCheck,\n\n            BlockStatement: blockIndentationCheck,\n\n            WhileStatement: blockLessNodes,\n\n            ForStatement: blockLessNodes,\n\n            ForInStatement: blockLessNodes,\n\n            ForOfStatement: blockLessNodes,\n\n            DoWhileStatement: blockLessNodes,\n\n            IfStatement(node) {\n                if (node.consequent.type !== \"BlockStatement\" && node.consequent.loc.start.line > node.loc.start.line) {\n                    blockIndentationCheck(node);\n                }\n            },\n\n            VariableDeclaration(node) {\n                if (node.declarations[node.declarations.length - 1].loc.start.line > node.declarations[0].loc.start.line) {\n                    checkIndentInVariableDeclarations(node);\n                }\n            },\n\n            ObjectExpression(node) {\n                checkIndentInArrayOrObjectBlock(node);\n            },\n\n            ArrayExpression(node) {\n                checkIndentInArrayOrObjectBlock(node);\n            },\n\n            MemberExpression(node) {\n\n                if (typeof options.MemberExpression === \"undefined\") {\n                    return;\n                }\n\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n\n                // The typical layout of variable declarations and assignments\n                // alter the expectation of correct indentation. Skip them.\n                // TODO: Add appropriate configuration options for variable\n                // declarations and assignments.\n                if (getParentNodeByType(node, \"VariableDeclarator\", [\"FunctionExpression\", \"ArrowFunctionExpression\"])) {\n                    return;\n                }\n\n                if (getParentNodeByType(node, \"AssignmentExpression\", [\"FunctionExpression\"])) {\n                    return;\n                }\n\n                const propertyIndent = getNodeIndent(node).goodChar + indentSize * options.MemberExpression;\n\n                const checkNodes = [node.property];\n\n                const dot = sourceCode.getTokenBefore(node.property);\n\n                if (dot.type === \"Punctuator\" && dot.value === \".\") {\n                    checkNodes.push(dot);\n                }\n\n                checkNodesIndent(checkNodes, propertyIndent);\n            },\n\n            SwitchStatement(node) {\n\n                // Switch is not a 'BlockStatement'\n                const switchIndent = getNodeIndent(node).goodChar;\n                const caseIndent = expectedCaseIndent(node, switchIndent);\n\n                checkNodesIndent(node.cases, caseIndent);\n\n\n                checkLastNodeLineIndent(node, switchIndent);\n            },\n\n            SwitchCase(node) {\n\n                // Skip inline cases\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                const caseIndent = expectedCaseIndent(node);\n\n                checkNodesIndent(node.consequent, caseIndent + indentSize);\n            },\n\n            FunctionDeclaration(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                if (options.FunctionDeclaration.parameters === \"first\" && node.params.length) {\n                    checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\n                } else if (options.FunctionDeclaration.parameters !== null) {\n                    checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionDeclaration.parameters);\n                }\n            },\n\n            FunctionExpression(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                if (options.FunctionExpression.parameters === \"first\" && node.params.length) {\n                    checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\n                } else if (options.FunctionExpression.parameters !== null) {\n                    checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionExpression.parameters);\n                }\n            },\n\n            ReturnStatement(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n\n                const firstLineIndent = getNodeIndent(node).goodChar;\n\n                // in case if return statement is wrapped in parenthesis\n                if (isWrappedInParenthesis(node)) {\n                    checkLastReturnStatementLineIndent(node, firstLineIndent);\n                } else {\n                    checkNodeIndent(node, firstLineIndent);\n                }\n            },\n\n            CallExpression(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                if (options.CallExpression.arguments === \"first\" && node.arguments.length) {\n                    checkNodesIndent(node.arguments.slice(1), node.arguments[0].loc.start.column);\n                } else if (options.CallExpression.arguments !== null) {\n                    checkNodesIndent(node.arguments, getNodeIndent(node).goodChar + indentSize * options.CallExpression.arguments);\n                }\n            }\n\n        };\n\n    }\n};\n","indent.js":"/**\n * @fileoverview This option sets a specific tab width for your code\n *\n * @author Teddy Katz\n * @author Vitaly Puzrin\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\nconst astUtils = require(\"../ast-utils\");\nconst createTree = require(\"functional-red-black-tree\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst KNOWN_NODES = new Set([\n    \"AssignmentExpression\",\n    \"AssignmentPattern\",\n    \"ArrayExpression\",\n    \"ArrayPattern\",\n    \"ArrowFunctionExpression\",\n    \"AwaitExpression\",\n    \"BlockStatement\",\n    \"BinaryExpression\",\n    \"BreakStatement\",\n    \"CallExpression\",\n    \"CatchClause\",\n    \"ClassBody\",\n    \"ClassDeclaration\",\n    \"ClassExpression\",\n    \"ConditionalExpression\",\n    \"ContinueStatement\",\n    \"DoWhileStatement\",\n    \"DebuggerStatement\",\n    \"EmptyStatement\",\n    \"ExperimentalRestProperty\",\n    \"ExperimentalSpreadProperty\",\n    \"ExpressionStatement\",\n    \"ForStatement\",\n    \"ForInStatement\",\n    \"ForOfStatement\",\n    \"FunctionDeclaration\",\n    \"FunctionExpression\",\n    \"Identifier\",\n    \"IfStatement\",\n    \"Literal\",\n    \"LabeledStatement\",\n    \"LogicalExpression\",\n    \"MemberExpression\",\n    \"MetaProperty\",\n    \"MethodDefinition\",\n    \"NewExpression\",\n    \"ObjectExpression\",\n    \"ObjectPattern\",\n    \"Program\",\n    \"Property\",\n    \"RestElement\",\n    \"ReturnStatement\",\n    \"SequenceExpression\",\n    \"SpreadElement\",\n    \"Super\",\n    \"SwitchCase\",\n    \"SwitchStatement\",\n    \"TaggedTemplateExpression\",\n    \"TemplateElement\",\n    \"TemplateLiteral\",\n    \"ThisExpression\",\n    \"ThrowStatement\",\n    \"TryStatement\",\n    \"UnaryExpression\",\n    \"UpdateExpression\",\n    \"VariableDeclaration\",\n    \"VariableDeclarator\",\n    \"WhileStatement\",\n    \"WithStatement\",\n    \"YieldExpression\",\n    \"JSXIdentifier\",\n    \"JSXNamespacedName\",\n    \"JSXMemberExpression\",\n    \"JSXEmptyExpression\",\n    \"JSXExpressionContainer\",\n    \"JSXElement\",\n    \"JSXClosingElement\",\n    \"JSXOpeningElement\",\n    \"JSXAttribute\",\n    \"JSXSpreadAttribute\",\n    \"JSXText\",\n    \"ExportDefaultDeclaration\",\n    \"ExportNamedDeclaration\",\n    \"ExportAllDeclaration\",\n    \"ExportSpecifier\",\n    \"ImportDeclaration\",\n    \"ImportSpecifier\",\n    \"ImportDefaultSpecifier\",\n    \"ImportNamespaceSpecifier\"\n]);\n\n/*\n * General rule strategy:\n * 1. An OffsetStorage instance stores a map of desired offsets, where each token has a specified offset from another\n *    specified token or to the first column.\n * 2. As the AST is traversed, modify the desired offsets of tokens accordingly. For example, when entering a\n *    BlockStatement, offset all of the tokens in the BlockStatement by 1 indent level from the opening curly\n *    brace of the BlockStatement.\n * 3. After traversing the AST, calculate the expected indentation levels of every token according to the\n *    OffsetStorage container.\n * 4. For each line, compare the expected indentation of the first token to the actual indentation in the file,\n *    and report the token if the two values are not equal.\n */\n\n\n/**\n * A mutable balanced binary search tree that stores (key, value) pairs. The keys are numeric, and must be unique.\n * This is intended to be a generic wrapper around a balanced binary search tree library, so that the underlying implementation\n * can easily be swapped out.\n */\nclass BinarySearchTree {\n\n    /**\n     * Creates an empty tree\n     */\n    constructor() {\n        this._rbTree = createTree();\n    }\n\n    /**\n     * Inserts an entry into the tree.\n     * @param {number} key The entry's key\n     * @param {*} value The entry's value\n     * @returns {void}\n     */\n    insert(key, value) {\n        const iterator = this._rbTree.find(key);\n\n        if (iterator.valid) {\n            this._rbTree = iterator.update(value);\n        } else {\n            this._rbTree = this._rbTree.insert(key, value);\n        }\n    }\n\n    /**\n     * Finds the entry with the largest key less than or equal to the provided key\n     * @param {number} key The provided key\n     * @returns {{key: number, value: *}|null} The found entry, or null if no such entry exists.\n     */\n    findLe(key) {\n        const iterator = this._rbTree.le(key);\n\n        return iterator && { key: iterator.key, value: iterator.value };\n    }\n\n    /**\n     * Deletes all of the keys in the interval [start, end)\n     * @param {number} start The start of the range\n     * @param {number} end The end of the range\n     * @returns {void}\n     */\n    deleteRange(start, end) {\n\n        // Exit without traversing the tree if the range has zero size.\n        if (start === end) {\n            return;\n        }\n        const iterator = this._rbTree.ge(start);\n\n        while (iterator.valid && iterator.key < end) {\n            this._rbTree = this._rbTree.remove(iterator.key);\n            iterator.next();\n        }\n    }\n}\n\n/**\n * A helper class to get token-based info related to indentation\n */\nclass TokenInfo {\n\n    /**\n     * @param {SourceCode} sourceCode A SourceCode object\n     */\n    constructor(sourceCode) {\n        this.sourceCode = sourceCode;\n        this.firstTokensByLineNumber = sourceCode.tokensAndComments.reduce((map, token) => {\n            if (!map.has(token.loc.start.line)) {\n                map.set(token.loc.start.line, token);\n            }\n            if (!map.has(token.loc.end.line) && sourceCode.text.slice(token.range[1] - token.loc.end.column, token.range[1]).trim()) {\n                map.set(token.loc.end.line, token);\n            }\n            return map;\n        }, new Map());\n    }\n\n    /**\n    * Gets the first token on a given token's line\n    * @param {Token|ASTNode} token a node or token\n    * @returns {Token} The first token on the given line\n    */\n    getFirstTokenOfLine(token) {\n        return this.firstTokensByLineNumber.get(token.loc.start.line);\n    }\n\n    /**\n    * Determines whether a token is the first token in its line\n    * @param {Token} token The token\n    * @returns {boolean} `true` if the token is the first on its line\n    */\n    isFirstTokenOfLine(token) {\n        return this.getFirstTokenOfLine(token) === token;\n    }\n\n    /**\n     * Get the actual indent of a token\n     * @param {Token} token Token to examine. This should be the first token on its line.\n     * @returns {string} The indentation characters that precede the token\n     */\n    getTokenIndent(token) {\n        return this.sourceCode.text.slice(token.range[0] - token.loc.start.column, token.range[0]);\n    }\n}\n\n/**\n * A class to store information on desired offsets of tokens from each other\n */\nclass OffsetStorage {\n\n    /**\n     * @param {TokenInfo} tokenInfo a TokenInfo instance\n     * @param {number} indentSize The desired size of each indentation level\n     */\n    constructor(tokenInfo, indentSize) {\n        this._tokenInfo = tokenInfo;\n        this._indentSize = indentSize;\n\n        this._tree = new BinarySearchTree();\n        this._tree.insert(0, { offset: 0, from: null, force: false });\n\n        this._lockedFirstTokens = new WeakMap();\n        this._desiredIndentCache = new WeakMap();\n        this._ignoredTokens = new WeakSet();\n    }\n\n    _getOffsetDescriptor(token) {\n        return this._tree.findLe(token.range[0]).value;\n    }\n\n    /**\n     * Sets the offset column of token B to match the offset column of token A.\n     * **WARNING**: This matches a *column*, even if baseToken is not the first token on its line. In\n     * most cases, `setDesiredOffset` should be used instead.\n     * @param {Token} baseToken The first token\n     * @param {Token} offsetToken The second token, whose offset should be matched to the first token\n     * @returns {void}\n     */\n    matchOffsetOf(baseToken, offsetToken) {\n\n        /*\n         * lockedFirstTokens is a map from a token whose indentation is controlled by the \"first\" option to\n         * the token that it depends on. For example, with the `ArrayExpression: first` option, the first\n         * token of each element in the array after the first will be mapped to the first token of the first\n         * element. The desired indentation of each of these tokens is computed based on the desired indentation\n         * of the \"first\" element, rather than through the normal offset mechanism.\n         */\n        this._lockedFirstTokens.set(offsetToken, baseToken);\n    }\n\n    /**\n     * Sets the desired offset of a token.\n     *\n     * This uses a line-based offset collapsing behavior to handle tokens on the same line.\n     * For example, consider the following two cases:\n     *\n     * (\n     *     [\n     *         bar\n     *     ]\n     * )\n     *\n     * ([\n     *     bar\n     * ])\n     *\n     * Based on the first case, it's clear that the `bar` token needs to have an offset of 1 indent level (4 spaces) from\n     * the `[` token, and the `[` token has to have an offset of 1 indent level from the `(` token. Since the `(` token is\n     * the first on its line (with an indent of 0 spaces), the `bar` token needs to be offset by 2 indent levels (8 spaces)\n     * from the start of its line.\n     *\n     * However, in the second case `bar` should only be indented by 4 spaces. This is because the offset of 1 indent level\n     * between the `(` and the `[` tokens gets \"collapsed\" because the two tokens are on the same line. As a result, the\n     * `(` token is mapped to the `[` token with an offset of 0, and the rule correctly decides that `bar` should be indented\n     * by 1 indent level from the start of the line.\n     *\n     * This is useful because rule listeners can usually just call `setDesiredOffset` for all the tokens in the node,\n     * without needing to check which lines those tokens are on.\n     *\n     * Note that since collapsing only occurs when two tokens are on the same line, there are a few cases where non-intuitive\n     * behavior can occur. For example, consider the following cases:\n     *\n     * foo(\n     * ).\n     *     bar(\n     *         baz\n     *     )\n     *\n     * foo(\n     * ).bar(\n     *     baz\n     * )\n     *\n     * Based on the first example, it would seem that `bar` should be offset by 1 indent level from `foo`, and `baz`\n     * should be offset by 1 indent level from `bar`. However, this is not correct, because it would result in `baz`\n     * being indented by 2 indent levels in the second case (since `foo`, `bar`, and `baz` are all on separate lines, no\n     * collapsing would occur).\n     *\n     * Instead, the correct way would be to offset `baz` by 1 level from `bar`, offset `bar` by 1 level from the `)`, and\n     * offset the `)` by 0 levels from `foo`. This ensures that the offset between `bar` and the `)` are correctly collapsed\n     * in the second case.\n     *\n     * @param {Token} token The token\n     * @param {Token} fromToken The token that `token` should be offset from\n     * @param {number} offset The desired indent level\n     * @returns {void}\n     */\n    setDesiredOffset(token, fromToken, offset) {\n        return this.setDesiredOffsets(token.range, fromToken, offset);\n    }\n\n    /**\n    * Sets the desired offset of all tokens in a range\n    * It's common for node listeners in this file to need to apply the same offset to a large, contiguous range of tokens.\n    * Moreover, the offset of any given token is usually updated multiple times (roughly once for each node that contains\n    * it). This means that the offset of each token is updated O(AST depth) times.\n    * It would not be performant to store and update the offsets for each token independently, because the rule would end\n    * up having a time complexity of O(number of tokens * AST depth), which is quite slow for large files.\n    *\n    * Instead, the offset tree is represented as a collection of contiguous offset ranges in a file. For example, the following\n    * list could represent the state of the offset tree at a given point:\n    *\n    * * Tokens starting in the interval [0, 15) are aligned with the beginning of the file\n    * * Tokens starting in the interval [15, 30) are offset by 1 indent level from the `bar` token\n    * * Tokens starting in the interval [30, 43) are offset by 1 indent level from the `foo` token\n    * * Tokens starting in the interval [43, 820) are offset by 2 indent levels from the `bar` token\n    * * Tokens starting in the interval [820, â) are offset by 1 indent level from the `baz` token\n    *\n    * The `setDesiredOffsets` methods inserts ranges like the ones above. The third line above would be inserted by using:\n    * `setDesiredOffsets([30, 43], fooToken, 1);`\n    *\n    * @param {[number, number]} range A [start, end] pair. All tokens with range[0] <= token.start < range[1] will have the offset applied.\n    * @param {Token} fromToken The token that this is offset from\n    * @param {number} offset The desired indent level\n    * @param {boolean} force `true` if this offset should not use the normal collapsing behavior. This should almost always be false.\n    * @returns {void}\n    */\n    setDesiredOffsets(range, fromToken, offset, force) {\n\n        /*\n         * Offset ranges are stored as a collection of nodes, where each node maps a numeric key to an offset\n         * descriptor. The tree for the example above would have the following nodes:\n         *\n         * * key: 0, value: { offset: 0, from: null }\n         * * key: 15, value: { offset: 1, from: barToken }\n         * * key: 30, value: { offset: 1, from: fooToken }\n         * * key: 43, value: { offset: 2, from: barToken }\n         * * key: 820, value: { offset: 1, from: bazToken }\n         *\n         * To find the offset descriptor for any given token, one needs to find the node with the largest key\n         * which is <= token.start. To make this operation fast, the nodes are stored in a balanced binary\n         * search tree indexed by key.\n         */\n\n        const descriptorToInsert = { offset, from: fromToken, force };\n\n        const descriptorAfterRange = this._tree.findLe(range[1]).value;\n\n        const fromTokenIsInRange = fromToken && fromToken.range[0] >= range[0] && fromToken.range[1] <= range[1];\n        const fromTokenDescriptor = fromTokenIsInRange && this._getOffsetDescriptor(fromToken);\n\n        // First, remove any existing nodes in the range from the tree.\n        this._tree.deleteRange(range[0] + 1, range[1]);\n\n        // Insert a new node into the tree for this range\n        this._tree.insert(range[0], descriptorToInsert);\n\n        /*\n         * To avoid circular offset dependencies, keep the `fromToken` token mapped to whatever it was mapped to previously,\n         * even if it's in the current range.\n         */\n        if (fromTokenIsInRange) {\n            this._tree.insert(fromToken.range[0], fromTokenDescriptor);\n            this._tree.insert(fromToken.range[1], descriptorToInsert);\n        }\n\n        /*\n         * To avoid modifying the offset of tokens after the range, insert another node to keep the offset of the following\n         * tokens the same as it was before.\n         */\n        this._tree.insert(range[1], descriptorAfterRange);\n    }\n\n    /**\n    * Gets the desired indent of a token\n    * @param {Token} token The token\n    * @returns {number} The desired indent of the token\n    */\n    getDesiredIndent(token) {\n        if (!this._desiredIndentCache.has(token)) {\n\n            if (this._ignoredTokens.has(token)) {\n\n                // If the token is ignored, use the actual indent of the token as the desired indent.\n                // This ensures that no errors are reported for this token.\n                this._desiredIndentCache.set(token, this._tokenInfo.getTokenIndent(token).length / this._indentSize);\n            } else if (this._lockedFirstTokens.has(token)) {\n                const firstToken = this._lockedFirstTokens.get(token);\n\n                this._desiredIndentCache.set(\n                    token,\n\n                    // (indentation for the first element's line)\n                    this.getDesiredIndent(this._tokenInfo.getFirstTokenOfLine(firstToken)) +\n\n                        // (space between the start of the first element's line and the first element)\n                        (firstToken.loc.start.column - this._tokenInfo.getFirstTokenOfLine(firstToken).loc.start.column) / this._indentSize\n                );\n            } else {\n                const offsetInfo = this._getOffsetDescriptor(token);\n                const offset = (\n                    offsetInfo.from &&\n                    offsetInfo.from.loc.start.line === token.loc.start.line &&\n                    !offsetInfo.force\n                ) ? 0 : offsetInfo.offset;\n\n                this._desiredIndentCache.set(token, offset + (offsetInfo.from ? this.getDesiredIndent(offsetInfo.from) : 0));\n            }\n        }\n        return this._desiredIndentCache.get(token);\n    }\n\n    /**\n    * Ignores a token, preventing it from being reported.\n    * @param {Token} token The token\n    * @returns {void}\n    */\n    ignoreToken(token) {\n        if (this._tokenInfo.isFirstTokenOfLine(token)) {\n            this._ignoredTokens.add(token);\n        }\n    }\n\n    /**\n     * Gets the first token that the given token's indentation is dependent on\n     * @param {Token} token The token\n     * @returns {Token} The token that the given token depends on, or `null` if the given token is at the top level\n     */\n    getFirstDependency(token) {\n        return this._getOffsetDescriptor(token).from;\n    }\n}\n\nconst ELEMENT_LIST_SCHEMA = {\n    oneOf: [\n        {\n            type: \"integer\",\n            minimum: 0\n        },\n        {\n            enum: [\"first\", \"off\"]\n        }\n    ]\n};\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent indentation\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"tab\"]\n                    },\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    SwitchCase: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    VariableDeclarator: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                type: \"object\",\n                                properties: {\n                                    var: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    let: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    const: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    }\n                                },\n                                additionalProperties: false\n                            }\n                        ]\n                    },\n                    outerIIFEBody: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    MemberExpression: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                enum: [\"off\"]\n                            }\n                        ]\n                    },\n                    FunctionDeclaration: {\n                        type: \"object\",\n                        properties: {\n                            parameters: ELEMENT_LIST_SCHEMA,\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    FunctionExpression: {\n                        type: \"object\",\n                        properties: {\n                            parameters: ELEMENT_LIST_SCHEMA,\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    CallExpression: {\n                        type: \"object\",\n                        properties: {\n                            arguments: ELEMENT_LIST_SCHEMA\n                        },\n                        additionalProperties: false\n                    },\n                    ArrayExpression: ELEMENT_LIST_SCHEMA,\n                    ObjectExpression: ELEMENT_LIST_SCHEMA,\n                    ImportDeclaration: ELEMENT_LIST_SCHEMA,\n                    flatTernaryExpressions: {\n                        type: \"boolean\"\n                    },\n                    ignoredNodes: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\",\n                            not: {\n                                pattern: \":exit$\"\n                            }\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const DEFAULT_VARIABLE_INDENT = 1;\n        const DEFAULT_PARAMETER_INDENT = 1;\n        const DEFAULT_FUNCTION_BODY_INDENT = 1;\n\n        let indentType = \"space\";\n        let indentSize = 4;\n        const options = {\n            SwitchCase: 0,\n            VariableDeclarator: {\n                var: DEFAULT_VARIABLE_INDENT,\n                let: DEFAULT_VARIABLE_INDENT,\n                const: DEFAULT_VARIABLE_INDENT\n            },\n            outerIIFEBody: 1,\n            FunctionDeclaration: {\n                parameters: DEFAULT_PARAMETER_INDENT,\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            FunctionExpression: {\n                parameters: DEFAULT_PARAMETER_INDENT,\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            CallExpression: {\n                arguments: DEFAULT_PARAMETER_INDENT\n            },\n            MemberExpression: 1,\n            ArrayExpression: 1,\n            ObjectExpression: 1,\n            ImportDeclaration: 1,\n            flatTernaryExpressions: false,\n            ignoredNodes: []\n        };\n\n        if (context.options.length) {\n            if (context.options[0] === \"tab\") {\n                indentSize = 1;\n                indentType = \"tab\";\n            } else {\n                indentSize = context.options[0];\n                indentType = \"space\";\n            }\n\n            if (context.options[1]) {\n                lodash.merge(options, context.options[1]);\n\n                if (typeof options.VariableDeclarator === \"number\") {\n                    options.VariableDeclarator = {\n                        var: options.VariableDeclarator,\n                        let: options.VariableDeclarator,\n                        const: options.VariableDeclarator\n                    };\n                }\n            }\n        }\n\n        const sourceCode = context.getSourceCode();\n        const tokenInfo = new TokenInfo(sourceCode);\n        const offsets = new OffsetStorage(tokenInfo, indentSize);\n        const parameterParens = new WeakSet();\n\n        /**\n         * Creates an error message for a line, given the expected/actual indentation.\n         * @param {int} expectedAmount The expected amount of indentation characters for this line\n         * @param {int} actualSpaces The actual number of indentation spaces that were found on this line\n         * @param {int} actualTabs The actual number of indentation tabs that were found on this line\n         * @returns {string} An error message for this line\n         */\n        function createErrorMessage(expectedAmount, actualSpaces, actualTabs) {\n            const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? \"\" : \"s\"}`; // e.g. \"2 tabs\"\n            const foundSpacesWord = `space${actualSpaces === 1 ? \"\" : \"s\"}`; // e.g. \"space\"\n            const foundTabsWord = `tab${actualTabs === 1 ? \"\" : \"s\"}`; // e.g. \"tabs\"\n            let foundStatement;\n\n            if (actualSpaces > 0) {\n\n                // Abbreviate the message if the expected indentation is also spaces.\n                // e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'\n                foundStatement = indentType === \"space\" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;\n            } else if (actualTabs > 0) {\n                foundStatement = indentType === \"tab\" ? actualTabs : `${actualTabs} ${foundTabsWord}`;\n            } else {\n                foundStatement = \"0\";\n            }\n\n            return `Expected indentation of ${expectedStatement} but found ${foundStatement}.`;\n        }\n\n        /**\n         * Reports a given indent violation\n         * @param {Token} token Token violating the indent rule\n         * @param {int} neededIndentLevel Expected indentation level\n         * @param {int} gottenSpaces Actual number of indentation spaces for the token\n         * @param {int} gottenTabs Actual number of indentation tabs for the token\n         * @returns {void}\n         */\n        function report(token, neededIndentLevel) {\n            const actualIndent = Array.from(tokenInfo.getTokenIndent(token));\n            const numSpaces = actualIndent.filter(char => char === \" \").length;\n            const numTabs = actualIndent.filter(char => char === \"\\t\").length;\n            const neededChars = neededIndentLevel * indentSize;\n\n            context.report({\n                node: token,\n                message: createErrorMessage(neededChars, numSpaces, numTabs),\n                loc: {\n                    start: { line: token.loc.start.line, column: 0 },\n                    end: { line: token.loc.start.line, column: token.loc.start.column }\n                },\n                fix(fixer) {\n                    const range = [token.range[0] - token.loc.start.column, token.range[0]];\n                    const newText = (indentType === \"space\" ? \" \" : \"\\t\").repeat(neededChars);\n\n                    return fixer.replaceTextRange(range, newText);\n                }\n            });\n        }\n\n        /**\n         * Checks if a token's indentation is correct\n         * @param {Token} token Token to examine\n         * @param {int} desiredIndentLevel needed indent level\n         * @returns {boolean} `true` if the token's indentation is correct\n         */\n        function validateTokenIndent(token, desiredIndentLevel) {\n            const indentation = tokenInfo.getTokenIndent(token);\n            const expectedChar = indentType === \"space\" ? \" \" : \"\\t\";\n\n            return indentation === expectedChar.repeat(desiredIndentLevel * indentSize) ||\n\n                // To avoid conflicts with no-mixed-spaces-and-tabs, don't report mixed spaces and tabs.\n                indentation.includes(\" \") && indentation.includes(\"\\t\");\n        }\n\n        /**\n         * Check to see if the node is a file level IIFE\n         * @param {ASTNode} node The function node to check.\n         * @returns {boolean} True if the node is the outer IIFE\n         */\n        function isOuterIIFE(node) {\n\n            /*\n             * Verify that the node is an IIFE\n             */\n            if (!node.parent || node.parent.type !== \"CallExpression\" || node.parent.callee !== node) {\n                return false;\n            }\n\n            /*\n             * Navigate legal ancestors to determine whether this IIFE is outer.\n             * A \"legal ancestor\" is an expression or statement that causes the function to get executed immediately.\n             * For example, `!(function(){})()` is an outer IIFE even though it is preceded by a ! operator.\n             */\n            let statement = node.parent && node.parent.parent;\n\n            while (\n                statement.type === \"UnaryExpression\" && [\"!\", \"~\", \"+\", \"-\"].indexOf(statement.operator) > -1 ||\n                statement.type === \"AssignmentExpression\" ||\n                statement.type === \"LogicalExpression\" ||\n                statement.type === \"SequenceExpression\" ||\n                statement.type === \"VariableDeclarator\"\n            ) {\n                statement = statement.parent;\n            }\n\n            return (statement.type === \"ExpressionStatement\" || statement.type === \"VariableDeclaration\") && statement.parent.type === \"Program\";\n        }\n\n        /**\n        * Check indentation for lists of elements (arrays, objects, function params)\n        * @param {ASTNode[]} elements List of elements that should be offset\n        * @param {Token} startToken The start token of the list that element should be aligned against, e.g. '['\n        * @param {Token} endToken The end token of the list, e.g. ']'\n        * @param {number|string} offset The amount that the elements should be offset\n        * @returns {void}\n        */\n        function addElementListIndent(elements, startToken, endToken, offset) {\n\n            /**\n            * Gets the first token of a given element, including surrounding parentheses.\n            * @param {ASTNode} element A node in the `elements` list\n            * @returns {Token} The first token of this element\n            */\n            function getFirstToken(element) {\n                let token = sourceCode.getTokenBefore(element);\n\n                while (astUtils.isOpeningParenToken(token) && token !== startToken) {\n                    token = sourceCode.getTokenBefore(token);\n                }\n                return sourceCode.getTokenAfter(token);\n            }\n\n            // Run through all the tokens in the list, and offset them by one indent level (mainly for comments, other things will end up overridden)\n            offsets.setDesiredOffsets(\n                [startToken.range[1], endToken.range[0]],\n                startToken,\n                typeof offset === \"number\" ? offset : 1\n            );\n            offsets.setDesiredOffset(endToken, startToken, 0);\n\n            // If the preference is \"first\" but there is no first element (e.g. sparse arrays w/ empty first slot), fall back to 1 level.\n            if (offset === \"first\" && elements.length && !elements[0]) {\n                return;\n            }\n            elements.forEach((element, index) => {\n                if (!element) {\n\n                    // Skip holes in arrays\n                    return;\n                }\n                if (offset === \"off\") {\n\n                    // Ignore the first token of every element if the \"off\" option is used\n                    offsets.ignoreToken(getFirstToken(element));\n                }\n\n                // Offset the following elements correctly relative to the first element\n                if (index === 0) {\n                    return;\n                }\n                if (offset === \"first\" && tokenInfo.isFirstTokenOfLine(getFirstToken(element))) {\n                    offsets.matchOffsetOf(getFirstToken(elements[0]), getFirstToken(element));\n                } else {\n                    const previousElement = elements[index - 1];\n                    const firstTokenOfPreviousElement = previousElement && getFirstToken(previousElement);\n\n                    if (previousElement && sourceCode.getLastToken(previousElement).loc.start.line > startToken.loc.end.line) {\n                        offsets.setDesiredOffsets(element.range, firstTokenOfPreviousElement, 0);\n                    }\n                }\n            });\n        }\n\n        /**\n         * Check and decide whether to check for indentation for blockless nodes\n         * Scenarios are for or while statements without braces around them\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function addBlocklessNodeIndent(node) {\n            if (node.type !== \"BlockStatement\") {\n                const lastParentToken = sourceCode.getTokenBefore(node, astUtils.isNotOpeningParenToken);\n\n                let firstBodyToken = sourceCode.getFirstToken(node);\n                let lastBodyToken = sourceCode.getLastToken(node);\n\n                while (\n                    astUtils.isOpeningParenToken(sourceCode.getTokenBefore(firstBodyToken)) &&\n                    astUtils.isClosingParenToken(sourceCode.getTokenAfter(lastBodyToken))\n                ) {\n                    firstBodyToken = sourceCode.getTokenBefore(firstBodyToken);\n                    lastBodyToken = sourceCode.getTokenAfter(lastBodyToken);\n                }\n\n                offsets.setDesiredOffsets([firstBodyToken.range[0], lastBodyToken.range[1]], lastParentToken, 1);\n\n                /*\n                 * For blockless nodes with semicolon-first style, don't indent the semicolon.\n                 * e.g.\n                 * if (foo) bar()\n                 * ; [1, 2, 3].map(foo)\n                 */\n                const lastToken = sourceCode.getLastToken(node);\n\n                if (node.type !== \"EmptyStatement\" && astUtils.isSemicolonToken(lastToken)) {\n                    offsets.setDesiredOffset(lastToken, lastParentToken, 0);\n                }\n            }\n        }\n\n        /**\n        * Checks the indentation for nodes that are like function calls (`CallExpression` and `NewExpression`)\n        * @param {ASTNode} node A CallExpression or NewExpression node\n        * @returns {void}\n        */\n        function addFunctionCallIndent(node) {\n            let openingParen;\n\n            if (node.arguments.length) {\n                openingParen = sourceCode.getFirstTokenBetween(node.callee, node.arguments[0], astUtils.isOpeningParenToken);\n            } else {\n                openingParen = sourceCode.getLastToken(node, 1);\n            }\n            const closingParen = sourceCode.getLastToken(node);\n\n            parameterParens.add(openingParen);\n            parameterParens.add(closingParen);\n            offsets.setDesiredOffset(openingParen, sourceCode.getTokenBefore(openingParen), 0);\n\n            addElementListIndent(node.arguments, openingParen, closingParen, options.CallExpression.arguments);\n        }\n\n        /**\n        * Checks the indentation of parenthesized values, given a list of tokens in a program\n        * @param {Token[]} tokens A list of tokens\n        * @returns {void}\n        */\n        function addParensIndent(tokens) {\n            const parenStack = [];\n            const parenPairs = [];\n\n            tokens.forEach(nextToken => {\n\n                // Accumulate a list of parenthesis pairs\n                if (astUtils.isOpeningParenToken(nextToken)) {\n                    parenStack.push(nextToken);\n                } else if (astUtils.isClosingParenToken(nextToken)) {\n                    parenPairs.unshift({ left: parenStack.pop(), right: nextToken });\n                }\n            });\n\n            parenPairs.forEach(pair => {\n                const leftParen = pair.left;\n                const rightParen = pair.right;\n\n                // We only want to handle parens around expressions, so exclude parentheses that are in function parameters and function call arguments.\n                if (!parameterParens.has(leftParen) && !parameterParens.has(rightParen)) {\n                    const parenthesizedTokens = new Set(sourceCode.getTokensBetween(leftParen, rightParen));\n\n                    parenthesizedTokens.forEach(token => {\n                        if (!parenthesizedTokens.has(offsets.getFirstDependency(token))) {\n                            offsets.setDesiredOffset(token, leftParen, 1);\n                        }\n                    });\n                }\n\n                offsets.setDesiredOffset(rightParen, leftParen, 0);\n            });\n        }\n\n        /**\n        * Ignore all tokens within an unknown node whose offset do not depend\n        * on another token's offset within the unknown node\n        * @param {ASTNode} node Unknown Node\n        * @returns {void}\n        */\n        function ignoreNode(node) {\n            const unknownNodeTokens = new Set(sourceCode.getTokens(node, { includeComments: true }));\n\n            unknownNodeTokens.forEach(token => {\n                if (!unknownNodeTokens.has(offsets.getFirstDependency(token))) {\n                    const firstTokenOfLine = tokenInfo.getFirstTokenOfLine(token);\n\n                    if (token === firstTokenOfLine) {\n                        offsets.ignoreToken(token);\n                    } else {\n                        offsets.setDesiredOffset(token, firstTokenOfLine, 0);\n                    }\n                }\n            });\n        }\n\n        /**\n         * Check whether the given token is on the first line of a statement.\n         * @param {Token} token The token to check.\n         * @param {ASTNode} leafNode The expression node that the token belongs directly.\n         * @returns {boolean} `true` if the token is on the first line of a statement.\n         */\n        function isOnFirstLineOfStatement(token, leafNode) {\n            let node = leafNode;\n\n            while (node.parent && !node.parent.type.endsWith(\"Statement\") && !node.parent.type.endsWith(\"Declaration\")) {\n                node = node.parent;\n            }\n            node = node.parent;\n\n            return !node || node.loc.start.line === token.loc.start.line;\n        }\n\n        const baseOffsetListeners = {\n            \"ArrayExpression, ArrayPattern\"(node) {\n                const openingBracket = sourceCode.getFirstToken(node);\n                const closingBracket = sourceCode.getTokenAfter(lodash.findLast(node.elements) || openingBracket, astUtils.isClosingBracketToken);\n\n                addElementListIndent(node.elements, openingBracket, closingBracket, options.ArrayExpression);\n            },\n\n            \"ObjectExpression, ObjectPattern\"(node) {\n                const openingCurly = sourceCode.getFirstToken(node);\n                const closingCurly = sourceCode.getTokenAfter(\n                    node.properties.length ? node.properties[node.properties.length - 1] : openingCurly,\n                    astUtils.isClosingBraceToken\n                );\n\n                addElementListIndent(node.properties, openingCurly, closingCurly, options.ObjectExpression);\n            },\n\n            ArrowFunctionExpression(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n\n                if (astUtils.isOpeningParenToken(firstToken)) {\n                    const openingParen = firstToken;\n                    const closingParen = sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken);\n\n                    parameterParens.add(openingParen);\n                    parameterParens.add(closingParen);\n                    addElementListIndent(node.params, openingParen, closingParen, options.FunctionExpression.parameters);\n                }\n                addBlocklessNodeIndent(node.body);\n\n                let arrowToken;\n\n                if (node.params.length) {\n                    arrowToken = sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isArrowToken);\n                } else {\n                    arrowToken = sourceCode.getFirstToken(node, astUtils.isArrowToken);\n                }\n                offsets.setDesiredOffset(arrowToken, sourceCode.getFirstToken(node), 0);\n            },\n\n            AssignmentExpression(node) {\n                const operator = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n\n                offsets.setDesiredOffsets([operator.range[0], node.range[1]], sourceCode.getLastToken(node.left), 1);\n                offsets.ignoreToken(operator);\n                offsets.ignoreToken(sourceCode.getTokenAfter(operator));\n            },\n\n            \"BinaryExpression, LogicalExpression\"(node) {\n                const operator = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n\n                /*\n                * For backwards compatibility, don't check BinaryExpression indents, e.g.\n                * var foo = bar &&\n                *                   baz;\n                */\n\n                const tokenAfterOperator = sourceCode.getTokenAfter(operator);\n\n                offsets.ignoreToken(operator);\n                offsets.ignoreToken(tokenAfterOperator);\n                offsets.setDesiredOffset(tokenAfterOperator, operator, 0);\n                offsets.setDesiredOffsets([tokenAfterOperator.range[1], node.range[1]], tokenAfterOperator, 1);\n            },\n\n            \"BlockStatement, ClassBody\"(node) {\n\n                let blockIndentLevel;\n\n                if (node.parent && isOuterIIFE(node.parent)) {\n                    blockIndentLevel = options.outerIIFEBody;\n                } else if (node.parent && (node.parent.type === \"FunctionExpression\" || node.parent.type === \"ArrowFunctionExpression\")) {\n                    blockIndentLevel = options.FunctionExpression.body;\n                } else if (node.parent && node.parent.type === \"FunctionDeclaration\") {\n                    blockIndentLevel = options.FunctionDeclaration.body;\n                } else {\n                    blockIndentLevel = 1;\n                }\n\n                /*\n                 * For blocks that aren't lone statements, ensure that the opening curly brace\n                 * is aligned with the parent.\n                 */\n                if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\n                    offsets.setDesiredOffset(sourceCode.getFirstToken(node), sourceCode.getFirstToken(node.parent), 0);\n                }\n                addElementListIndent(node.body, sourceCode.getFirstToken(node), sourceCode.getLastToken(node), blockIndentLevel);\n            },\n\n            CallExpression: addFunctionCallIndent,\n\n\n            \"ClassDeclaration[superClass], ClassExpression[superClass]\"(node) {\n                const classToken = sourceCode.getFirstToken(node);\n                const extendsToken = sourceCode.getTokenBefore(node.superClass, astUtils.isNotOpeningParenToken);\n\n                offsets.setDesiredOffsets([extendsToken.range[0], node.body.range[0]], classToken, 1);\n            },\n\n            ConditionalExpression(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n\n                // `flatTernaryExpressions` option is for the following style:\n                // var a =\n                //     foo > 0 ? bar :\n                //     foo < 0 ? baz :\n                //     /*else*/ qiz ;\n                if (!options.flatTernaryExpressions ||\n                    !astUtils.isTokenOnSameLine(node.test, node.consequent) ||\n                    isOnFirstLineOfStatement(firstToken, node)\n                ) {\n                    const questionMarkToken = sourceCode.getFirstTokenBetween(node.test, node.consequent, token => token.type === \"Punctuator\" && token.value === \"?\");\n                    const colonToken = sourceCode.getFirstTokenBetween(node.consequent, node.alternate, token => token.type === \"Punctuator\" && token.value === \":\");\n\n                    const firstConsequentToken = sourceCode.getTokenAfter(questionMarkToken, { includeComments: true });\n                    const lastConsequentToken = sourceCode.getTokenBefore(colonToken, { includeComments: true });\n                    const firstAlternateToken = sourceCode.getTokenAfter(colonToken);\n\n                    offsets.setDesiredOffset(questionMarkToken, firstToken, 1);\n                    offsets.setDesiredOffset(colonToken, firstToken, 1);\n\n                    offsets.setDesiredOffset(firstConsequentToken, firstToken, 1);\n\n                    /*\n                     * The alternate and the consequent should usually have the same indentation.\n                     * If they share part of a line, align the alternate against the first token of the consequent.\n                     * This allows the alternate to be indented correctly in cases like this:\n                     * foo ? (\n                     *   bar\n                     * ) : ( // this '(' is aligned with the '(' above, so it's considered to be aligned with `foo`\n                     *   baz // as a result, `baz` is offset by 1 rather than 2\n                     * )\n                     */\n                    if (lastConsequentToken.loc.end.line === firstAlternateToken.loc.start.line) {\n                        offsets.setDesiredOffset(firstAlternateToken, firstConsequentToken, 0);\n                    } else {\n\n                        /**\n                         * If the alternate and consequent do not share part of a line, offset the alternate from the first\n                         * token of the conditional expression. For example:\n                         * foo ? bar\n                         *   : baz\n                         *\n                         * If `baz` were aligned with `bar` rather than being offset by 1 from `foo`, `baz` would end up\n                         * having no expected indentation.\n                         */\n                        offsets.setDesiredOffset(firstAlternateToken, firstToken, 1);\n                    }\n\n                    offsets.setDesiredOffsets([questionMarkToken.range[1], colonToken.range[0]], firstConsequentToken, 0);\n                    offsets.setDesiredOffsets([colonToken.range[1], node.range[1]], firstAlternateToken, 0);\n                }\n            },\n\n            \"DoWhileStatement, WhileStatement, ForInStatement, ForOfStatement\": node => addBlocklessNodeIndent(node.body),\n\n            ExportNamedDeclaration(node) {\n                if (node.declaration === null) {\n                    const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);\n\n                    // Indent the specifiers in `export {foo, bar, baz}`\n                    addElementListIndent(node.specifiers, sourceCode.getFirstToken(node, { skip: 1 }), closingCurly, 1);\n\n                    if (node.source) {\n\n                        // Indent everything after and including the `from` token in `export {foo, bar, baz} from 'qux'`\n                        offsets.setDesiredOffsets([closingCurly.range[1], node.range[1]], sourceCode.getFirstToken(node), 1);\n                    }\n                }\n            },\n\n            ForStatement(node) {\n                const forOpeningParen = sourceCode.getFirstToken(node, 1);\n\n                if (node.init) {\n                    offsets.setDesiredOffsets(node.init.range, forOpeningParen, 1);\n                }\n                if (node.test) {\n                    offsets.setDesiredOffsets(node.test.range, forOpeningParen, 1);\n                }\n                if (node.update) {\n                    offsets.setDesiredOffsets(node.update.range, forOpeningParen, 1);\n                }\n                addBlocklessNodeIndent(node.body);\n            },\n\n            \"FunctionDeclaration, FunctionExpression\"(node) {\n                const closingParen = sourceCode.getTokenBefore(node.body);\n                const openingParen = sourceCode.getTokenBefore(node.params.length ? node.params[0] : closingParen);\n\n                parameterParens.add(openingParen);\n                parameterParens.add(closingParen);\n                addElementListIndent(node.params, openingParen, closingParen, options[node.type].parameters);\n            },\n\n            IfStatement(node) {\n                addBlocklessNodeIndent(node.consequent);\n                if (node.alternate && node.alternate.type !== \"IfStatement\") {\n                    addBlocklessNodeIndent(node.alternate);\n                }\n            },\n\n            ImportDeclaration(node) {\n                if (node.specifiers.some(specifier => specifier.type === \"ImportSpecifier\")) {\n                    const openingCurly = sourceCode.getFirstToken(node, astUtils.isOpeningBraceToken);\n                    const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);\n\n                    addElementListIndent(node.specifiers.filter(specifier => specifier.type === \"ImportSpecifier\"), openingCurly, closingCurly, options.ImportDeclaration);\n                }\n\n                const fromToken = sourceCode.getLastToken(node, token => token.type === \"Identifier\" && token.value === \"from\");\n\n                if (fromToken) {\n                    offsets.setDesiredOffsets([fromToken.range[0], node.range[1]], sourceCode.getFirstToken(node), 1);\n                }\n            },\n\n            \"MemberExpression, JSXMemberExpression, MetaProperty\"(node) {\n                const object = node.type === \"MetaProperty\" ? node.meta : node.object;\n                const firstNonObjectToken = sourceCode.getFirstTokenBetween(object, node.property, astUtils.isNotClosingParenToken);\n                const secondNonObjectToken = sourceCode.getTokenAfter(firstNonObjectToken);\n\n                const objectParenCount = sourceCode.getTokensBetween(object, node.property, { filter: astUtils.isClosingParenToken }).length;\n                const firstObjectToken = objectParenCount\n                    ? sourceCode.getTokenBefore(object, { skip: objectParenCount - 1 })\n                    : sourceCode.getFirstToken(object);\n                const lastObjectToken = sourceCode.getTokenBefore(firstNonObjectToken);\n                const firstPropertyToken = node.computed ? firstNonObjectToken : secondNonObjectToken;\n\n                if (node.computed) {\n\n                    // For computed MemberExpressions, match the closing bracket with the opening bracket.\n                    offsets.setDesiredOffset(sourceCode.getLastToken(node), firstNonObjectToken, 0);\n                    offsets.setDesiredOffsets(node.property.range, firstNonObjectToken, 1);\n                }\n\n                /*\n                 * If the object ends on the same line that the property starts, match against the last token\n                 * of the object, to ensure that the MemberExpression is not indented.\n                 *\n                 * Otherwise, match against the first token of the object, e.g.\n                 * foo\n                 *   .bar\n                 *   .baz // <-- offset by 1 from `foo`\n                 */\n                const offsetBase = lastObjectToken.loc.end.line === firstPropertyToken.loc.start.line\n                    ? lastObjectToken\n                    : firstObjectToken;\n\n                if (typeof options.MemberExpression === \"number\") {\n\n                    // Match the dot (for non-computed properties) or the opening bracket (for computed properties) against the object.\n                    offsets.setDesiredOffset(firstNonObjectToken, offsetBase, options.MemberExpression);\n\n                    /*\n                     * For computed MemberExpressions, match the first token of the property against the opening bracket.\n                     * Otherwise, match the first token of the property against the object.\n                     */\n                    offsets.setDesiredOffset(secondNonObjectToken, node.computed ? firstNonObjectToken : offsetBase, options.MemberExpression);\n                } else {\n\n                    // If the MemberExpression option is off, ignore the dot and the first token of the property.\n                    offsets.ignoreToken(firstNonObjectToken);\n                    offsets.ignoreToken(secondNonObjectToken);\n\n                    // To ignore the property indentation, ensure that the property tokens depend on the ignored tokens.\n                    offsets.setDesiredOffset(firstNonObjectToken, offsetBase, 0);\n                    offsets.setDesiredOffset(secondNonObjectToken, firstNonObjectToken, 0);\n                }\n            },\n\n            NewExpression(node) {\n\n                // Only indent the arguments if the NewExpression has parens (e.g. `new Foo(bar)` or `new Foo()`, but not `new Foo`\n                if (node.arguments.length > 0 || astUtils.isClosingParenToken(sourceCode.getLastToken(node)) && astUtils.isOpeningParenToken(sourceCode.getLastToken(node, 1))) {\n                    addFunctionCallIndent(node);\n                }\n            },\n\n            Property(node) {\n                if (!node.shorthand && !node.method && node.kind === \"init\") {\n                    const colon = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isColonToken);\n\n                    offsets.ignoreToken(sourceCode.getTokenAfter(colon));\n                }\n            },\n\n            SwitchStatement(node) {\n                const openingCurly = sourceCode.getTokenAfter(node.discriminant, astUtils.isOpeningBraceToken);\n                const closingCurly = sourceCode.getLastToken(node);\n                const caseKeywords = node.cases.map(switchCase => sourceCode.getFirstToken(switchCase));\n\n                offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, options.SwitchCase);\n\n                node.cases.forEach((switchCase, index) => {\n                    const caseKeyword = caseKeywords[index];\n\n                    if (!(switchCase.consequent.length === 1 && switchCase.consequent[0].type === \"BlockStatement\")) {\n                        const tokenAfterCurrentCase = index === node.cases.length - 1 ? closingCurly : caseKeywords[index + 1];\n\n                        offsets.setDesiredOffsets([caseKeyword.range[1], tokenAfterCurrentCase.range[0]], caseKeyword, 1);\n                    }\n                });\n\n                if (node.cases.length) {\n                    sourceCode.getTokensBetween(\n                        node.cases[node.cases.length - 1],\n                        closingCurly,\n                        { includeComments: true, filter: astUtils.isCommentToken }\n                    ).forEach(token => offsets.ignoreToken(token));\n                }\n            },\n\n            TemplateLiteral(node) {\n                node.expressions.forEach((expression, index) => {\n                    const previousQuasi = node.quasis[index];\n                    const nextQuasi = node.quasis[index + 1];\n                    const tokenToAlignFrom = previousQuasi.loc.start.line === previousQuasi.loc.end.line ? sourceCode.getFirstToken(previousQuasi) : null;\n\n                    offsets.setDesiredOffsets([previousQuasi.range[1], nextQuasi.range[0]], tokenToAlignFrom, 1);\n                    offsets.setDesiredOffset(sourceCode.getFirstToken(nextQuasi), tokenToAlignFrom, 0);\n                });\n            },\n\n            VariableDeclaration(node) {\n                const variableIndent = options.VariableDeclarator.hasOwnProperty(node.kind) ? options.VariableDeclarator[node.kind] : DEFAULT_VARIABLE_INDENT;\n\n                if (node.declarations[node.declarations.length - 1].loc.start.line > node.loc.start.line) {\n\n                    /*\n                     * VariableDeclarator indentation is a bit different from other forms of indentation, in that the\n                     * indentation of an opening bracket sometimes won't match that of a closing bracket. For example,\n                     * the following indentations are correct:\n                     *\n                     * var foo = {\n                     *   ok: true\n                     * };\n                     *\n                     * var foo = {\n                     *     ok: true,\n                     *   },\n                     *   bar = 1;\n                     *\n                     * Account for when exiting the AST (after indentations have already been set for the nodes in\n                     * the declaration) by manually increasing the indentation level of the tokens in this declarator\n                     * on the same line as the start of the declaration, provided that there are declarators that\n                     * follow this one.\n                     */\n                    const firstToken = sourceCode.getFirstToken(node);\n\n                    offsets.setDesiredOffsets(node.range, firstToken, variableIndent, true);\n                } else {\n                    offsets.setDesiredOffsets(node.range, sourceCode.getFirstToken(node), variableIndent);\n                }\n                const lastToken = sourceCode.getLastToken(node);\n\n                if (astUtils.isSemicolonToken(lastToken)) {\n                    offsets.ignoreToken(lastToken);\n                }\n            },\n\n            VariableDeclarator(node) {\n                if (node.init) {\n                    const equalOperator = sourceCode.getTokenBefore(node.init, astUtils.isNotOpeningParenToken);\n                    const tokenAfterOperator = sourceCode.getTokenAfter(equalOperator);\n\n                    offsets.ignoreToken(equalOperator);\n                    offsets.ignoreToken(tokenAfterOperator);\n                    offsets.setDesiredOffsets([tokenAfterOperator.range[0], node.range[1]], equalOperator, 1);\n                    offsets.setDesiredOffset(equalOperator, sourceCode.getLastToken(node.id), 0);\n                }\n            },\n\n            \"JSXAttribute[value]\"(node) {\n                const equalsToken = sourceCode.getFirstTokenBetween(node.name, node.value, token => token.type === \"Punctuator\" && token.value === \"=\");\n\n                offsets.setDesiredOffsets([equalsToken.range[0], node.value.range[1]], sourceCode.getFirstToken(node.name), 1);\n            },\n\n            JSXElement(node) {\n                if (node.closingElement) {\n                    addElementListIndent(node.children, sourceCode.getFirstToken(node.openingElement), sourceCode.getFirstToken(node.closingElement), 1);\n                }\n            },\n\n            JSXOpeningElement(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n                let closingToken;\n\n                if (node.selfClosing) {\n                    closingToken = sourceCode.getLastToken(node, { skip: 1 });\n                    offsets.setDesiredOffset(sourceCode.getLastToken(node), closingToken, 0);\n                } else {\n                    closingToken = sourceCode.getLastToken(node);\n                }\n                offsets.setDesiredOffsets(node.name.range, sourceCode.getFirstToken(node));\n                addElementListIndent(node.attributes, firstToken, closingToken, 1);\n            },\n\n            JSXClosingElement(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n\n                offsets.setDesiredOffsets(node.name.range, firstToken, 1);\n                offsets.setDesiredOffset(sourceCode.getLastToken(node), firstToken, 0);\n            },\n\n            JSXExpressionContainer(node) {\n                const openingCurly = sourceCode.getFirstToken(node);\n                const closingCurly = sourceCode.getLastToken(node);\n\n                offsets.setDesiredOffsets(\n                    [openingCurly.range[1], closingCurly.range[0]],\n                    openingCurly,\n                    1\n                );\n                offsets.setDesiredOffset(closingCurly, openingCurly, 0);\n            }\n        };\n\n        const listenerCallQueue = [];\n\n        /*\n         * To ignore the indentation of a node:\n         * 1. Don't call the node's listener when entering it (if it has a listener)\n         * 2. Call `ignoreNode` on the node sometime after exiting it and before validating offsets.\n         */\n        const offsetListeners = lodash.mapValues(\n            baseOffsetListeners,\n\n            /*\n             * Offset listener calls are deferred until traversal is finished, and are called as\n             * part of the final `Program:exit` listener. This is necessary because a node might\n             * be matched by multiple selectors.\n             *\n             * Example: Suppose there is an offset listener for `Identifier`, and the user has\n             * specified in configuration that `MemberExpression > Identifier` should be ignored.\n             * Due to selector specificity rules, the `Identifier` listener will get called first. However,\n             * if a given Identifier node is supposed to be ignored, then the `Identifier` offset listener\n             * should not have been called at all. Without doing extra selector matching, we don't know\n             * whether the Identifier matches the `MemberExpression > Identifier` selector until the\n             * `MemberExpression > Identifier` listener is called.\n             *\n             * To avoid this, the `Identifier` listener isn't called until traversal finishes and all\n             * ignored nodes are known.\n             */\n            listener =>\n                node =>\n                    listenerCallQueue.push({ listener, node })\n        );\n\n        // For each ignored node selector, set up a listener to collect it into the `ignoredNodes` set.\n        const ignoredNodes = new Set();\n        const addToIgnoredNodes = ignoredNodes.add.bind(ignoredNodes);\n\n        const ignoredNodeListeners = options.ignoredNodes.reduce(\n            (listeners, ignoredSelector) => Object.assign(listeners, { [ignoredSelector]: addToIgnoredNodes }),\n            {}\n        );\n\n        /*\n         * Join the listeners, and add a listener to verify that all tokens actually have the correct indentation\n         * at the end.\n         *\n         * Using Object.assign will cause some offset listeners to be overwritten if the same selector also appears\n         * in `ignoredNodeListeners`. This isn't a problem because all of the matching nodes will be ignored,\n         * so those listeners wouldn't be called anyway.\n         */\n        return Object.assign(\n            offsetListeners,\n            ignoredNodeListeners,\n            {\n                \"*:exit\"(node) {\n\n                    // If a node's type is nonstandard, we can't tell how its children should be offset, so ignore it.\n                    if (!KNOWN_NODES.has(node.type)) {\n                        ignoredNodes.add(node);\n                    }\n                },\n                \"Program:exit\"() {\n\n                    // Invoke the queued offset listeners for the nodes that aren't ignored.\n                    listenerCallQueue\n                        .filter(nodeInfo => !ignoredNodes.has(nodeInfo.node))\n                        .forEach(nodeInfo => nodeInfo.listener(nodeInfo.node));\n\n                    // Update the offsets for ignored nodes to prevent their child tokens from being reported.\n                    ignoredNodes.forEach(ignoreNode);\n\n                    addParensIndent(sourceCode.ast.tokens);\n\n                    /*\n                     * Create a Map from (tokenOrComment) => (precedingToken).\n                     * This is necessary because sourceCode.getTokenBefore does not handle a comment as an argument correctly.\n                     */\n                    const precedingTokens = sourceCode.ast.comments.reduce((commentMap, comment) => {\n                        const tokenOrCommentBefore = sourceCode.getTokenBefore(comment, { includeComments: true });\n\n                        return commentMap.set(comment, commentMap.has(tokenOrCommentBefore) ? commentMap.get(tokenOrCommentBefore) : tokenOrCommentBefore);\n                    }, new WeakMap());\n\n                    sourceCode.lines.forEach((line, lineIndex) => {\n                        const lineNumber = lineIndex + 1;\n\n                        if (!tokenInfo.firstTokensByLineNumber.has(lineNumber)) {\n\n                            // Don't check indentation on blank lines\n                            return;\n                        }\n\n                        const firstTokenOfLine = tokenInfo.firstTokensByLineNumber.get(lineNumber);\n\n                        if (firstTokenOfLine.loc.start.line !== lineNumber) {\n\n                            // Don't check the indentation of multi-line tokens (e.g. template literals or block comments) twice.\n                            return;\n                        }\n\n                        // If the token matches the expected expected indentation, don't report it.\n                        if (validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine))) {\n                            return;\n                        }\n\n                        if (astUtils.isCommentToken(firstTokenOfLine)) {\n                            const tokenBefore = precedingTokens.get(firstTokenOfLine);\n                            const tokenAfter = tokenBefore ? sourceCode.getTokenAfter(tokenBefore) : sourceCode.ast.tokens[0];\n\n                            // If a comment matches the expected indentation of the token immediately before or after, don't report it.\n                            if (\n                                tokenBefore && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenBefore)) ||\n                                tokenAfter && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenAfter))\n                            ) {\n                                return;\n                            }\n                        }\n\n                        // Otherwise, report the token/comment.\n                        report(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine));\n                    });\n                }\n            }\n        );\n    }\n};\n","init-declarations.js":"/**\n * @fileoverview A rule to control the style of variable initializations.\n * @author Colin Ihrig\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a for loop.\n * @param {ASTNode} block - A node to check.\n * @returns {boolean} `true` when the node is a for loop.\n */\nfunction isForLoop(block) {\n    return block.type === \"ForInStatement\" ||\n    block.type === \"ForOfStatement\" ||\n    block.type === \"ForStatement\";\n}\n\n/**\n * Checks whether or not a given declarator node has its initializer.\n * @param {ASTNode} node - A declarator node to check.\n * @returns {boolean} `true` when the node has its initializer.\n */\nfunction isInitialized(node) {\n    const declaration = node.parent;\n    const block = declaration.parent;\n\n    if (isForLoop(block)) {\n        if (block.type === \"ForStatement\") {\n            return block.init === declaration;\n        }\n        return block.left === declaration;\n    }\n    return Boolean(node.init);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow initialization in variable declarations\",\n            category: \"Variables\",\n            recommended: false\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"never\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                ignoreForLoopInit: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        }\n    },\n\n    create(context) {\n\n        const MODE_ALWAYS = \"always\",\n            MODE_NEVER = \"never\";\n\n        const mode = context.options[0] || MODE_ALWAYS;\n        const params = context.options[1] || {};\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            \"VariableDeclaration:exit\"(node) {\n\n                const kind = node.kind,\n                    declarations = node.declarations;\n\n                for (let i = 0; i < declarations.length; ++i) {\n                    const declaration = declarations[i],\n                        id = declaration.id,\n                        initialized = isInitialized(declaration),\n                        isIgnoredForLoop = params.ignoreForLoopInit && isForLoop(node.parent);\n\n                    if (id.type !== \"Identifier\") {\n                        continue;\n                    }\n\n                    if (mode === MODE_ALWAYS && !initialized) {\n                        context.report({\n                            node: declaration,\n                            message: \"Variable '{{idName}}' should be initialized on declaration.\",\n                            data: {\n                                idName: id.name\n                            }\n                        });\n                    } else if (mode === MODE_NEVER && kind !== \"const\" && initialized && !isIgnoredForLoop) {\n                        context.report({\n                            node: declaration,\n                            message: \"Variable '{{idName}}' should not be initialized on declaration.\",\n                            data: {\n                                idName: id.name\n                            }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n","jsx-quotes.js":"/**\n * @fileoverview A rule to ensure consistent quotes used in jsx syntax.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst QUOTE_SETTINGS = {\n    \"prefer-double\": {\n        quote: \"\\\"\",\n        description: \"singlequote\",\n        convert(str) {\n            return str.replace(/'/g, \"\\\"\");\n        }\n    },\n    \"prefer-single\": {\n        quote: \"'\",\n        description: \"doublequote\",\n        convert(str) {\n            return str.replace(/\"/g, \"'\");\n        }\n    }\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce the consistent use of either double or single quotes in JSX attributes\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"prefer-single\", \"prefer-double\"]\n            }\n        ]\n    },\n\n    create(context) {\n        const quoteOption = context.options[0] || \"prefer-double\",\n            setting = QUOTE_SETTINGS[quoteOption];\n\n        /**\n         * Checks if the given string literal node uses the expected quotes\n         * @param {ASTNode} node - A string literal node.\n         * @returns {boolean} Whether or not the string literal used the expected quotes.\n         * @public\n         */\n        function usesExpectedQuotes(node) {\n            return node.value.indexOf(setting.quote) !== -1 || astUtils.isSurroundedBy(node.raw, setting.quote);\n        }\n\n        return {\n            JSXAttribute(node) {\n                const attributeValue = node.value;\n\n                if (attributeValue && astUtils.isStringLiteral(attributeValue) && !usesExpectedQuotes(attributeValue)) {\n                    context.report({\n                        node: attributeValue,\n                        message: \"Unexpected usage of {{description}}.\",\n                        data: {\n                            description: setting.description\n                        },\n                        fix(fixer) {\n                            return fixer.replaceText(attributeValue, setting.convert(attributeValue.raw));\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","key-spacing.js":"/**\n * @fileoverview Rule to specify spacing of object literal keys and values\n * @author Brandon Mills\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a string contains a line terminator as defined in\n * http://www.ecma-international.org/ecma-262/5.1/#sec-7.3\n * @param {string} str String to test.\n * @returns {boolean} True if str contains a line terminator.\n */\nfunction containsLineTerminator(str) {\n    return astUtils.LINEBREAK_MATCHER.test(str);\n}\n\n/**\n * Gets the last element of an array.\n * @param {Array} arr An array.\n * @returns {any} Last element of arr.\n */\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n\n/**\n * Checks whether a node is contained on a single line.\n * @param {ASTNode} node AST Node being evaluated.\n * @returns {boolean} True if the node is a single line.\n */\nfunction isSingleLine(node) {\n    return (node.loc.end.line === node.loc.start.line);\n}\n\n/**\n * Initializes a single option property from the configuration with defaults for undefined values\n * @param {Object} toOptions Object to be initialized\n * @param {Object} fromOptions Object to be initialized from\n * @returns {Object} The object with correctly initialized options and values\n */\nfunction initOptionProperty(toOptions, fromOptions) {\n    toOptions.mode = fromOptions.mode || \"strict\";\n\n    // Set value of beforeColon\n    if (typeof fromOptions.beforeColon !== \"undefined\") {\n        toOptions.beforeColon = +fromOptions.beforeColon;\n    } else {\n        toOptions.beforeColon = 0;\n    }\n\n    // Set value of afterColon\n    if (typeof fromOptions.afterColon !== \"undefined\") {\n        toOptions.afterColon = +fromOptions.afterColon;\n    } else {\n        toOptions.afterColon = 1;\n    }\n\n    // Set align if exists\n    if (typeof fromOptions.align !== \"undefined\") {\n        if (typeof fromOptions.align === \"object\") {\n            toOptions.align = fromOptions.align;\n        } else { // \"string\"\n            toOptions.align = {\n                on: fromOptions.align,\n                mode: toOptions.mode,\n                beforeColon: toOptions.beforeColon,\n                afterColon: toOptions.afterColon\n            };\n        }\n    }\n\n    return toOptions;\n}\n\n/**\n * Initializes all the option values (singleLine, multiLine and align) from the configuration with defaults for undefined values\n * @param {Object} toOptions Object to be initialized\n * @param {Object} fromOptions Object to be initialized from\n * @returns {Object} The object with correctly initialized options and values\n */\nfunction initOptions(toOptions, fromOptions) {\n    if (typeof fromOptions.align === \"object\") {\n\n        // Initialize the alignment configuration\n        toOptions.align = initOptionProperty({}, fromOptions.align);\n        toOptions.align.on = fromOptions.align.on || \"colon\";\n        toOptions.align.mode = fromOptions.align.mode || \"strict\";\n\n        toOptions.multiLine = initOptionProperty({}, (fromOptions.multiLine || fromOptions));\n        toOptions.singleLine = initOptionProperty({}, (fromOptions.singleLine || fromOptions));\n\n    } else { // string or undefined\n        toOptions.multiLine = initOptionProperty({}, (fromOptions.multiLine || fromOptions));\n        toOptions.singleLine = initOptionProperty({}, (fromOptions.singleLine || fromOptions));\n\n        // If alignment options are defined in multiLine, pull them out into the general align configuration\n        if (toOptions.multiLine.align) {\n            toOptions.align = {\n                on: toOptions.multiLine.align.on,\n                mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,\n                beforeColon: toOptions.multiLine.align.beforeColon,\n                afterColon: toOptions.multiLine.align.afterColon\n            };\n        }\n    }\n\n    return toOptions;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst messages = {\n    key: \"{{error}} space after {{computed}}key '{{key}}'.\",\n    value: \"{{error}} space before value for {{computed}}key '{{key}}'.\"\n};\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing between keys and values in object literal properties\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [{\n            anyOf: [\n                {\n                    type: \"object\",\n                    properties: {\n                        align: {\n                            anyOf: [\n                                {\n                                    enum: [\"colon\", \"value\"]\n                                },\n                                {\n                                    type: \"object\",\n                                    properties: {\n                                        mode: {\n                                            enum: [\"strict\", \"minimum\"]\n                                        },\n                                        on: {\n                                            enum: [\"colon\", \"value\"]\n                                        },\n                                        beforeColon: {\n                                            type: \"boolean\"\n                                        },\n                                        afterColon: {\n                                            type: \"boolean\"\n                                        }\n                                    },\n                                    additionalProperties: false\n                                }\n                            ]\n                        },\n                        mode: {\n                            enum: [\"strict\", \"minimum\"]\n                        },\n                        beforeColon: {\n                            type: \"boolean\"\n                        },\n                        afterColon: {\n                            type: \"boolean\"\n                        }\n                    },\n                    additionalProperties: false\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        singleLine: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        },\n                        multiLine: {\n                            type: \"object\",\n                            properties: {\n                                align: {\n                                    anyOf: [\n                                        {\n                                            enum: [\"colon\", \"value\"]\n                                        },\n                                        {\n                                            type: \"object\",\n                                            properties: {\n                                                mode: {\n                                                    enum: [\"strict\", \"minimum\"]\n                                                },\n                                                on: {\n                                                    enum: [\"colon\", \"value\"]\n                                                },\n                                                beforeColon: {\n                                                    type: \"boolean\"\n                                                },\n                                                afterColon: {\n                                                    type: \"boolean\"\n                                                }\n                                            },\n                                            additionalProperties: false\n                                        }\n                                    ]\n                                },\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    },\n                    additionalProperties: false\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        singleLine: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        },\n                        multiLine: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        },\n                        align: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                on: {\n                                    enum: [\"colon\", \"value\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    },\n                    additionalProperties: false\n                }\n            ]\n        }]\n    },\n\n    create(context) {\n\n        /**\n         * OPTIONS\n         * \"key-spacing\": [2, {\n         *     beforeColon: false,\n         *     afterColon: true,\n         *     align: \"colon\" // Optional, or \"value\"\n         * }\n         */\n        const options = context.options[0] || {},\n            ruleOptions = initOptions({}, options),\n            multiLineOptions = ruleOptions.multiLine,\n            singleLineOptions = ruleOptions.singleLine,\n            alignmentOptions = ruleOptions.align || null;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Checks whether a property is a member of the property group it follows.\n         * @param {ASTNode} lastMember The last Property known to be in the group.\n         * @param {ASTNode} candidate The next Property that might be in the group.\n         * @returns {boolean} True if the candidate property is part of the group.\n         */\n        function continuesPropertyGroup(lastMember, candidate) {\n            const groupEndLine = lastMember.loc.start.line,\n                candidateStartLine = candidate.loc.start.line;\n\n            if (candidateStartLine - groupEndLine <= 1) {\n                return true;\n            }\n\n            // Check that the first comment is adjacent to the end of the group, the\n            // last comment is adjacent to the candidate property, and that successive\n            // comments are adjacent to each other.\n            const leadingComments = sourceCode.getCommentsBefore(candidate);\n\n            if (\n                leadingComments.length &&\n                leadingComments[0].loc.start.line - groupEndLine <= 1 &&\n                candidateStartLine - last(leadingComments).loc.end.line <= 1\n            ) {\n                for (let i = 1; i < leadingComments.length; i++) {\n                    if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line > 1) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if the given property is key-value property.\n         * @param {ASTNode} property Property node to check.\n         * @returns {boolean} Whether the property is a key-value property.\n         */\n        function isKeyValueProperty(property) {\n            return !(\n                (property.method ||\n                property.shorthand ||\n                property.kind !== \"init\" || property.type !== \"Property\") // Could be \"ExperimentalSpreadProperty\" or \"SpreadProperty\"\n            );\n        }\n\n        /**\n         * Starting from the given a node (a property.key node here) looks forward\n         * until it finds the last token before a colon punctuator and returns it.\n         * @param {ASTNode} node The node to start looking from.\n         * @returns {ASTNode} The last token before a colon punctuator.\n         */\n        function getLastTokenBeforeColon(node) {\n            const colonToken = sourceCode.getTokenAfter(node, astUtils.isColonToken);\n\n            return sourceCode.getTokenBefore(colonToken);\n        }\n\n        /**\n         * Starting from the given a node (a property.key node here) looks forward\n         * until it finds the colon punctuator and returns it.\n         * @param {ASTNode} node The node to start looking from.\n         * @returns {ASTNode} The colon punctuator.\n         */\n        function getNextColon(node) {\n            return sourceCode.getTokenAfter(node, astUtils.isColonToken);\n        }\n\n        /**\n         * Gets an object literal property's key as the identifier name or string value.\n         * @param {ASTNode} property Property node whose key to retrieve.\n         * @returns {string} The property's key.\n         */\n        function getKey(property) {\n            const key = property.key;\n\n            if (property.computed) {\n                return sourceCode.getText().slice(key.range[0], key.range[1]);\n            }\n\n            return property.key.name || property.key.value;\n        }\n\n        /**\n         * Reports an appropriately-formatted error if spacing is incorrect on one\n         * side of the colon.\n         * @param {ASTNode} property Key-value pair in an object literal.\n         * @param {string} side Side being verified - either \"key\" or \"value\".\n         * @param {string} whitespace Actual whitespace string.\n         * @param {int} expected Expected whitespace length.\n         * @param {string} mode Value of the mode as \"strict\" or \"minimum\"\n         * @returns {void}\n         */\n        function report(property, side, whitespace, expected, mode) {\n            const diff = whitespace.length - expected,\n                nextColon = getNextColon(property.key),\n                tokenBeforeColon = sourceCode.getTokenBefore(nextColon, { includeComments: true }),\n                tokenAfterColon = sourceCode.getTokenAfter(nextColon, { includeComments: true }),\n                isKeySide = side === \"key\",\n                locStart = isKeySide ? tokenBeforeColon.loc.start : tokenAfterColon.loc.start,\n                isExtra = diff > 0,\n                diffAbs = Math.abs(diff),\n                spaces = Array(diffAbs + 1).join(\" \");\n\n            if ((\n                diff && mode === \"strict\" ||\n                diff < 0 && mode === \"minimum\" ||\n                diff > 0 && !expected && mode === \"minimum\") &&\n                !(expected && containsLineTerminator(whitespace))\n            ) {\n                let fix;\n\n                if (isExtra) {\n                    let range;\n\n                    // Remove whitespace\n                    if (isKeySide) {\n                        range = [tokenBeforeColon.range[1], tokenBeforeColon.range[1] + diffAbs];\n                    } else {\n                        range = [tokenAfterColon.range[0] - diffAbs, tokenAfterColon.range[0]];\n                    }\n                    fix = function(fixer) {\n                        return fixer.removeRange(range);\n                    };\n                } else {\n\n                    // Add whitespace\n                    if (isKeySide) {\n                        fix = function(fixer) {\n                            return fixer.insertTextAfter(tokenBeforeColon, spaces);\n                        };\n                    } else {\n                        fix = function(fixer) {\n                            return fixer.insertTextBefore(tokenAfterColon, spaces);\n                        };\n                    }\n                }\n\n                context.report({\n                    node: property[side],\n                    loc: locStart,\n                    message: messages[side],\n                    data: {\n                        error: isExtra ? \"Extra\" : \"Missing\",\n                        computed: property.computed ? \"computed \" : \"\",\n                        key: getKey(property)\n                    },\n                    fix\n                });\n            }\n        }\n\n        /**\n         * Gets the number of characters in a key, including quotes around string\n         * keys and braces around computed property keys.\n         * @param {ASTNode} property Property of on object literal.\n         * @returns {int} Width of the key.\n         */\n        function getKeyWidth(property) {\n            const startToken = sourceCode.getFirstToken(property);\n            const endToken = getLastTokenBeforeColon(property.key);\n\n            return endToken.range[1] - startToken.range[0];\n        }\n\n        /**\n         * Gets the whitespace around the colon in an object literal property.\n         * @param {ASTNode} property Property node from an object literal.\n         * @returns {Object} Whitespace before and after the property's colon.\n         */\n        function getPropertyWhitespace(property) {\n            const whitespace = /(\\s*):(\\s*)/.exec(sourceCode.getText().slice(\n                property.key.range[1], property.value.range[0]\n            ));\n\n            if (whitespace) {\n                return {\n                    beforeColon: whitespace[1],\n                    afterColon: whitespace[2]\n                };\n            }\n            return null;\n        }\n\n        /**\n         * Creates groups of properties.\n         * @param  {ASTNode} node ObjectExpression node being evaluated.\n         * @returns {Array.<ASTNode[]>} Groups of property AST node lists.\n         */\n        function createGroups(node) {\n            if (node.properties.length === 1) {\n                return [node.properties];\n            }\n\n            return node.properties.reduce((groups, property) => {\n                const currentGroup = last(groups),\n                    prev = last(currentGroup);\n\n                if (!prev || continuesPropertyGroup(prev, property)) {\n                    currentGroup.push(property);\n                } else {\n                    groups.push([property]);\n                }\n\n                return groups;\n            }, [\n                []\n            ]);\n        }\n\n        /**\n         * Verifies correct vertical alignment of a group of properties.\n         * @param {ASTNode[]} properties List of Property AST nodes.\n         * @returns {void}\n         */\n        function verifyGroupAlignment(properties) {\n            const length = properties.length,\n                widths = properties.map(getKeyWidth), // Width of keys, including quotes\n                align = alignmentOptions.on; // \"value\" or \"colon\"\n            let targetWidth = Math.max.apply(null, widths),\n                beforeColon, afterColon, mode;\n\n            if (alignmentOptions && length > 1) { // When aligning values within a group, use the alignment configuration.\n                beforeColon = alignmentOptions.beforeColon;\n                afterColon = alignmentOptions.afterColon;\n                mode = alignmentOptions.mode;\n            } else {\n                beforeColon = multiLineOptions.beforeColon;\n                afterColon = multiLineOptions.afterColon;\n                mode = alignmentOptions.mode;\n            }\n\n            // Conditionally include one space before or after colon\n            targetWidth += (align === \"colon\" ? beforeColon : afterColon);\n\n            for (let i = 0; i < length; i++) {\n                const property = properties[i];\n                const whitespace = getPropertyWhitespace(property);\n\n                if (whitespace) { // Object literal getters/setters lack a colon\n                    const width = widths[i];\n\n                    if (align === \"value\") {\n                        report(property, \"key\", whitespace.beforeColon, beforeColon, mode);\n                        report(property, \"value\", whitespace.afterColon, targetWidth - width, mode);\n                    } else { // align = \"colon\"\n                        report(property, \"key\", whitespace.beforeColon, targetWidth - width, mode);\n                        report(property, \"value\", whitespace.afterColon, afterColon, mode);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Verifies vertical alignment, taking into account groups of properties.\n         * @param  {ASTNode} node ObjectExpression node being evaluated.\n         * @returns {void}\n         */\n        function verifyAlignment(node) {\n            createGroups(node).forEach(group => {\n                verifyGroupAlignment(group.filter(isKeyValueProperty));\n            });\n        }\n\n        /**\n         * Verifies spacing of property conforms to specified options.\n         * @param  {ASTNode} node Property node being evaluated.\n         * @param {Object} lineOptions Configured singleLine or multiLine options\n         * @returns {void}\n         */\n        function verifySpacing(node, lineOptions) {\n            const actual = getPropertyWhitespace(node);\n\n            if (actual) { // Object literal getters/setters lack colons\n                report(node, \"key\", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);\n                report(node, \"value\", actual.afterColon, lineOptions.afterColon, lineOptions.mode);\n            }\n        }\n\n        /**\n         * Verifies spacing of each property in a list.\n         * @param  {ASTNode[]} properties List of Property AST nodes.\n         * @returns {void}\n         */\n        function verifyListSpacing(properties) {\n            const length = properties.length;\n\n            for (let i = 0; i < length; i++) {\n                verifySpacing(properties[i], singleLineOptions);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        if (alignmentOptions) { // Verify vertical alignment\n\n            return {\n                ObjectExpression(node) {\n                    if (isSingleLine(node)) {\n                        verifyListSpacing(node.properties.filter(isKeyValueProperty));\n                    } else {\n                        verifyAlignment(node);\n                    }\n                }\n            };\n\n        }\n\n        // Obey beforeColon and afterColon in each property as configured\n        return {\n            Property(node) {\n                verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);\n            }\n        };\n\n\n    }\n};\n","keyword-spacing.js":"/**\n * @fileoverview Rule to enforce spacing before and after keywords.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\"),\n    keywords = require(\"../util/keywords\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst PREV_TOKEN = /^[)\\]}>]$/;\nconst NEXT_TOKEN = /^(?:[([{<~!]|\\+\\+?|--?)$/;\nconst PREV_TOKEN_M = /^[)\\]}>*]$/;\nconst NEXT_TOKEN_M = /^[{*]$/;\nconst TEMPLATE_OPEN_PAREN = /\\$\\{$/;\nconst TEMPLATE_CLOSE_PAREN = /^\\}/;\nconst CHECK_TYPE = /^(?:JSXElement|RegularExpression|String|Template)$/;\nconst KEYS = keywords.concat([\"as\", \"async\", \"await\", \"from\", \"get\", \"let\", \"of\", \"set\", \"yield\"]);\n\n// check duplications.\n(function() {\n    KEYS.sort();\n    for (let i = 1; i < KEYS.length; ++i) {\n        if (KEYS[i] === KEYS[i - 1]) {\n            throw new Error(`Duplication was found in the keyword list: ${KEYS[i]}`);\n        }\n    }\n}());\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given token is a \"Template\" token ends with \"${\".\n *\n * @param {Token} token - A token to check.\n * @returns {boolean} `true` if the token is a \"Template\" token ends with \"${\".\n */\nfunction isOpenParenOfTemplate(token) {\n    return token.type === \"Template\" && TEMPLATE_OPEN_PAREN.test(token.value);\n}\n\n/**\n * Checks whether or not a given token is a \"Template\" token starts with \"}\".\n *\n * @param {Token} token - A token to check.\n * @returns {boolean} `true` if the token is a \"Template\" token starts with \"}\".\n */\nfunction isCloseParenOfTemplate(token) {\n    return token.type === \"Template\" && TEMPLATE_CLOSE_PAREN.test(token.value);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing before and after keywords\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: { type: \"boolean\" },\n                    after: { type: \"boolean\" },\n                    overrides: {\n                        type: \"object\",\n                        properties: KEYS.reduce((retv, key) => {\n                            retv[key] = {\n                                type: \"object\",\n                                properties: {\n                                    before: { type: \"boolean\" },\n                                    after: { type: \"boolean\" }\n                                },\n                                additionalProperties: false\n                            };\n                            return retv;\n                        }, {}),\n                        additionalProperties: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports a given token if there are not space(s) before the token.\n         *\n         * @param {Token} token - A token to report.\n         * @param {RegExp|undefined} pattern - Optional. A pattern of the previous\n         *      token to check.\n         * @returns {void}\n         */\n        function expectSpaceBefore(token, pattern) {\n            pattern = pattern || PREV_TOKEN;\n\n            const prevToken = sourceCode.getTokenBefore(token);\n\n            if (prevToken &&\n                (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) &&\n                !isOpenParenOfTemplate(prevToken) &&\n                astUtils.isTokenOnSameLine(prevToken, token) &&\n                !sourceCode.isSpaceBetweenTokens(prevToken, token)\n            ) {\n                context.report({\n                    loc: token.loc.start,\n                    message: \"Expected space(s) before \\\"{{value}}\\\".\",\n                    data: token,\n                    fix(fixer) {\n                        return fixer.insertTextBefore(token, \" \");\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports a given token if there are space(s) before the token.\n         *\n         * @param {Token} token - A token to report.\n         * @param {RegExp|undefined} pattern - Optional. A pattern of the previous\n         *      token to check.\n         * @returns {void}\n         */\n        function unexpectSpaceBefore(token, pattern) {\n            pattern = pattern || PREV_TOKEN;\n\n            const prevToken = sourceCode.getTokenBefore(token);\n\n            if (prevToken &&\n                (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) &&\n                !isOpenParenOfTemplate(prevToken) &&\n                astUtils.isTokenOnSameLine(prevToken, token) &&\n                sourceCode.isSpaceBetweenTokens(prevToken, token)\n            ) {\n                context.report({\n                    loc: token.loc.start,\n                    message: \"Unexpected space(s) before \\\"{{value}}\\\".\",\n                    data: token,\n                    fix(fixer) {\n                        return fixer.removeRange([prevToken.range[1], token.range[0]]);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports a given token if there are not space(s) after the token.\n         *\n         * @param {Token} token - A token to report.\n         * @param {RegExp|undefined} pattern - Optional. A pattern of the next\n         *      token to check.\n         * @returns {void}\n         */\n        function expectSpaceAfter(token, pattern) {\n            pattern = pattern || NEXT_TOKEN;\n\n            const nextToken = sourceCode.getTokenAfter(token);\n\n            if (nextToken &&\n                (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) &&\n                !isCloseParenOfTemplate(nextToken) &&\n                astUtils.isTokenOnSameLine(token, nextToken) &&\n                !sourceCode.isSpaceBetweenTokens(token, nextToken)\n            ) {\n                context.report({\n                    loc: token.loc.start,\n                    message: \"Expected space(s) after \\\"{{value}}\\\".\",\n                    data: token,\n                    fix(fixer) {\n                        return fixer.insertTextAfter(token, \" \");\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports a given token if there are space(s) after the token.\n         *\n         * @param {Token} token - A token to report.\n         * @param {RegExp|undefined} pattern - Optional. A pattern of the next\n         *      token to check.\n         * @returns {void}\n         */\n        function unexpectSpaceAfter(token, pattern) {\n            pattern = pattern || NEXT_TOKEN;\n\n            const nextToken = sourceCode.getTokenAfter(token);\n\n            if (nextToken &&\n                (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) &&\n                !isCloseParenOfTemplate(nextToken) &&\n                astUtils.isTokenOnSameLine(token, nextToken) &&\n                sourceCode.isSpaceBetweenTokens(token, nextToken)\n            ) {\n                context.report({\n                    loc: token.loc.start,\n                    message: \"Unexpected space(s) after \\\"{{value}}\\\".\",\n                    data: token,\n                    fix(fixer) {\n                        return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Parses the option object and determines check methods for each keyword.\n         *\n         * @param {Object|undefined} options - The option object to parse.\n         * @returns {Object} - Normalized option object.\n         *      Keys are keywords (there are for every keyword).\n         *      Values are instances of `{\"before\": function, \"after\": function}`.\n         */\n        function parseOptions(options) {\n            const before = !options || options.before !== false;\n            const after = !options || options.after !== false;\n            const defaultValue = {\n                before: before ? expectSpaceBefore : unexpectSpaceBefore,\n                after: after ? expectSpaceAfter : unexpectSpaceAfter\n            };\n            const overrides = (options && options.overrides) || {};\n            const retv = Object.create(null);\n\n            for (let i = 0; i < KEYS.length; ++i) {\n                const key = KEYS[i];\n                const override = overrides[key];\n\n                if (override) {\n                    const thisBefore = (\"before\" in override) ? override.before : before;\n                    const thisAfter = (\"after\" in override) ? override.after : after;\n\n                    retv[key] = {\n                        before: thisBefore ? expectSpaceBefore : unexpectSpaceBefore,\n                        after: thisAfter ? expectSpaceAfter : unexpectSpaceAfter\n                    };\n                } else {\n                    retv[key] = defaultValue;\n                }\n            }\n\n            return retv;\n        }\n\n        const checkMethodMap = parseOptions(context.options[0]);\n\n        /**\n         * Reports a given token if usage of spacing followed by the token is\n         * invalid.\n         *\n         * @param {Token} token - A token to report.\n         * @param {RegExp|undefined} pattern - Optional. A pattern of the previous\n         *      token to check.\n         * @returns {void}\n         */\n        function checkSpacingBefore(token, pattern) {\n            checkMethodMap[token.value].before(token, pattern);\n        }\n\n        /**\n         * Reports a given token if usage of spacing preceded by the token is\n         * invalid.\n         *\n         * @param {Token} token - A token to report.\n         * @param {RegExp|undefined} pattern - Optional. A pattern of the next\n         *      token to check.\n         * @returns {void}\n         */\n        function checkSpacingAfter(token, pattern) {\n            checkMethodMap[token.value].after(token, pattern);\n        }\n\n        /**\n         * Reports a given token if usage of spacing around the token is invalid.\n         *\n         * @param {Token} token - A token to report.\n         * @returns {void}\n         */\n        function checkSpacingAround(token) {\n            checkSpacingBefore(token);\n            checkSpacingAfter(token);\n        }\n\n        /**\n         * Reports the first token of a given node if the first token is a keyword\n         * and usage of spacing around the token is invalid.\n         *\n         * @param {ASTNode|null} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingAroundFirstToken(node) {\n            const firstToken = node && sourceCode.getFirstToken(node);\n\n            if (firstToken && firstToken.type === \"Keyword\") {\n                checkSpacingAround(firstToken);\n            }\n        }\n\n        /**\n         * Reports the first token of a given node if the first token is a keyword\n         * and usage of spacing followed by the token is invalid.\n         *\n         * This is used for unary operators (e.g. `typeof`), `function`, and `super`.\n         * Other rules are handling usage of spacing preceded by those keywords.\n         *\n         * @param {ASTNode|null} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingBeforeFirstToken(node) {\n            const firstToken = node && sourceCode.getFirstToken(node);\n\n            if (firstToken && firstToken.type === \"Keyword\") {\n                checkSpacingBefore(firstToken);\n            }\n        }\n\n        /**\n         * Reports the previous token of a given node if the token is a keyword and\n         * usage of spacing around the token is invalid.\n         *\n         * @param {ASTNode|null} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingAroundTokenBefore(node) {\n            if (node) {\n                const token = sourceCode.getTokenBefore(node, astUtils.isKeywordToken);\n\n                checkSpacingAround(token);\n            }\n        }\n\n        /**\n         * Reports `async` or `function` keywords of a given node if usage of\n         * spacing around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForFunction(node) {\n            const firstToken = node && sourceCode.getFirstToken(node);\n\n            if (firstToken &&\n                ((firstToken.type === \"Keyword\" && firstToken.value === \"function\") ||\n                firstToken.value === \"async\")\n            ) {\n                checkSpacingBefore(firstToken);\n            }\n        }\n\n        /**\n         * Reports `class` and `extends` keywords of a given node if usage of\n         * spacing around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForClass(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundTokenBefore(node.superClass);\n        }\n\n        /**\n         * Reports `if` and `else` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForIfStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundTokenBefore(node.alternate);\n        }\n\n        /**\n         * Reports `try`, `catch`, and `finally` keywords of a given node if usage\n         * of spacing around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForTryStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundFirstToken(node.handler);\n            checkSpacingAroundTokenBefore(node.finalizer);\n        }\n\n        /**\n         * Reports `do` and `while` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForDoWhileStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundTokenBefore(node.test);\n        }\n\n        /**\n         * Reports `for` and `in` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForForInStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundTokenBefore(node.right);\n        }\n\n        /**\n         * Reports `for` and `of` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForForOfStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAround(sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken));\n        }\n\n        /**\n         * Reports `import`, `export`, `as`, and `from` keywords of a given node if\n         * usage of spacing around those keywords is invalid.\n         *\n         * This rule handles the `*` token in module declarations.\n         *\n         *     import*as A from \"./a\"; /*error Expected space(s) after \"import\".\n         *                               error Expected space(s) before \"as\".\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForModuleDeclaration(node) {\n            const firstToken = sourceCode.getFirstToken(node);\n\n            checkSpacingBefore(firstToken, PREV_TOKEN_M);\n            checkSpacingAfter(firstToken, NEXT_TOKEN_M);\n\n            if (node.source) {\n                const fromToken = sourceCode.getTokenBefore(node.source);\n\n                checkSpacingBefore(fromToken, PREV_TOKEN_M);\n                checkSpacingAfter(fromToken, NEXT_TOKEN_M);\n            }\n        }\n\n        /**\n         * Reports `as` keyword of a given node if usage of spacing around this\n         * keyword is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForImportNamespaceSpecifier(node) {\n            const asToken = sourceCode.getFirstToken(node, 1);\n\n            checkSpacingBefore(asToken, PREV_TOKEN_M);\n        }\n\n        /**\n         * Reports `static`, `get`, and `set` keywords of a given node if usage of\n         * spacing around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForProperty(node) {\n            if (node.static) {\n                checkSpacingAroundFirstToken(node);\n            }\n            if (node.kind === \"get\" ||\n                node.kind === \"set\" ||\n                (\n                    (node.method || node.type === \"MethodDefinition\") &&\n                    node.value.async\n                )\n            ) {\n                const token = sourceCode.getTokenBefore(\n                    node.key,\n                    tok => {\n                        switch (tok.value) {\n                            case \"get\":\n                            case \"set\":\n                            case \"async\":\n                                return true;\n                            default:\n                                return false;\n                        }\n                    }\n                );\n\n                if (!token) {\n                    throw new Error(\"Failed to find token get, set, or async beside method name\");\n                }\n\n\n                checkSpacingAround(token);\n            }\n        }\n\n        /**\n         * Reports `await` keyword of a given node if usage of spacing before\n         * this keyword is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForAwaitExpression(node) {\n            checkSpacingBefore(sourceCode.getFirstToken(node));\n        }\n\n        return {\n\n            // Statements\n            DebuggerStatement: checkSpacingAroundFirstToken,\n            WithStatement: checkSpacingAroundFirstToken,\n\n            // Statements - Control flow\n            BreakStatement: checkSpacingAroundFirstToken,\n            ContinueStatement: checkSpacingAroundFirstToken,\n            ReturnStatement: checkSpacingAroundFirstToken,\n            ThrowStatement: checkSpacingAroundFirstToken,\n            TryStatement: checkSpacingForTryStatement,\n\n            // Statements - Choice\n            IfStatement: checkSpacingForIfStatement,\n            SwitchStatement: checkSpacingAroundFirstToken,\n            SwitchCase: checkSpacingAroundFirstToken,\n\n            // Statements - Loops\n            DoWhileStatement: checkSpacingForDoWhileStatement,\n            ForInStatement: checkSpacingForForInStatement,\n            ForOfStatement: checkSpacingForForOfStatement,\n            ForStatement: checkSpacingAroundFirstToken,\n            WhileStatement: checkSpacingAroundFirstToken,\n\n            // Statements - Declarations\n            ClassDeclaration: checkSpacingForClass,\n            ExportNamedDeclaration: checkSpacingForModuleDeclaration,\n            ExportDefaultDeclaration: checkSpacingAroundFirstToken,\n            ExportAllDeclaration: checkSpacingForModuleDeclaration,\n            FunctionDeclaration: checkSpacingForFunction,\n            ImportDeclaration: checkSpacingForModuleDeclaration,\n            VariableDeclaration: checkSpacingAroundFirstToken,\n\n            // Expressions\n            ArrowFunctionExpression: checkSpacingForFunction,\n            AwaitExpression: checkSpacingForAwaitExpression,\n            ClassExpression: checkSpacingForClass,\n            FunctionExpression: checkSpacingForFunction,\n            NewExpression: checkSpacingBeforeFirstToken,\n            Super: checkSpacingBeforeFirstToken,\n            ThisExpression: checkSpacingBeforeFirstToken,\n            UnaryExpression: checkSpacingBeforeFirstToken,\n            YieldExpression: checkSpacingBeforeFirstToken,\n\n            // Others\n            ImportNamespaceSpecifier: checkSpacingForImportNamespaceSpecifier,\n            MethodDefinition: checkSpacingForProperty,\n            Property: checkSpacingForProperty\n        };\n    }\n};\n","line-comment-position.js":"/**\n * @fileoverview Rule to enforce the position of line comments\n * @author Alberto RodrÃ­guez\n */\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce position of line comments\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"above\", \"beside\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            position: {\n                                enum: [\"above\", \"beside\"]\n                            },\n                            ignorePattern: {\n                                type: \"string\"\n                            },\n                            applyDefaultPatterns: {\n                                type: \"boolean\"\n                            },\n                            applyDefaultIgnorePatterns: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const options = context.options[0];\n\n        let above,\n            ignorePattern,\n            applyDefaultIgnorePatterns = true;\n\n        if (!options || typeof options === \"string\") {\n            above = !options || options === \"above\";\n\n        } else {\n            above = options.position === \"above\";\n            ignorePattern = options.ignorePattern;\n\n            if (options.hasOwnProperty(\"applyDefaultIgnorePatterns\")) {\n                applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns !== false;\n            } else {\n                applyDefaultIgnorePatterns = options.applyDefaultPatterns !== false;\n            }\n        }\n\n        const defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;\n        const fallThroughRegExp = /^\\s*falls?\\s?through/;\n        const customIgnoreRegExp = new RegExp(ignorePattern);\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments.filter(token => token.type === \"Line\").forEach(node => {\n                    if (applyDefaultIgnorePatterns && (defaultIgnoreRegExp.test(node.value) || fallThroughRegExp.test(node.value))) {\n                        return;\n                    }\n\n                    if (ignorePattern && customIgnoreRegExp.test(node.value)) {\n                        return;\n                    }\n\n                    const previous = sourceCode.getTokenBefore(node, { includeComments: true });\n                    const isOnSameLine = previous && previous.loc.end.line === node.loc.start.line;\n\n                    if (above) {\n                        if (isOnSameLine) {\n                            context.report({\n                                node,\n                                message: \"Expected comment to be above code.\"\n                            });\n                        }\n                    } else {\n                        if (!isOnSameLine) {\n                            context.report({\n                                node,\n                                message: \"Expected comment to be beside code.\"\n                            });\n                        }\n                    }\n                });\n            }\n        };\n    }\n};\n","linebreak-style.js":"/**\n * @fileoverview Rule to enforce a single linebreak style.\n * @author Erik Mueller\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent linebreak style\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"unix\", \"windows\"]\n            }\n        ]\n    },\n\n    create(context) {\n\n        const EXPECTED_LF_MSG = \"Expected linebreaks to be 'LF' but found 'CRLF'.\",\n            EXPECTED_CRLF_MSG = \"Expected linebreaks to be 'CRLF' but found 'LF'.\";\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Builds a fix function that replaces text at the specified range in the source text.\n         * @param {int[]} range The range to replace\n         * @param {string} text The text to insert.\n         * @returns {Function} Fixer function\n         * @private\n         */\n        function createFix(range, text) {\n            return function(fixer) {\n                return fixer.replaceTextRange(range, text);\n            };\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: function checkForlinebreakStyle(node) {\n                const linebreakStyle = context.options[0] || \"unix\",\n                    expectedLF = linebreakStyle === \"unix\",\n                    expectedLFChars = expectedLF ? \"\\n\" : \"\\r\\n\",\n                    source = sourceCode.getText(),\n                    pattern = astUtils.createGlobalLinebreakMatcher();\n                let match;\n\n                let i = 0;\n\n                while ((match = pattern.exec(source)) !== null) {\n                    i++;\n                    if (match[0] === expectedLFChars) {\n                        continue;\n                    }\n\n                    const index = match.index;\n                    const range = [index, index + match[0].length];\n\n                    context.report({\n                        node,\n                        loc: {\n                            line: i,\n                            column: sourceCode.lines[i - 1].length\n                        },\n                        message: expectedLF ? EXPECTED_LF_MSG : EXPECTED_CRLF_MSG,\n                        fix: createFix(range, expectedLFChars)\n                    });\n                }\n            }\n        };\n    }\n};\n","lines-around-comment.js":"/**\n * @fileoverview Enforces empty lines around comments.\n * @author Jamund Ferguson\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\"),\n    astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Return an array with with any line numbers that are empty.\n * @param {Array} lines An array of each line of the file.\n * @returns {Array} An array of line numbers.\n */\nfunction getEmptyLineNums(lines) {\n    const emptyLines = lines.map((line, i) => ({\n        code: line.trim(),\n        num: i + 1\n    })).filter(line => !line.code).map(line => line.num);\n\n    return emptyLines;\n}\n\n/**\n * Return an array with with any line numbers that contain comments.\n * @param {Array} comments An array of comment tokens.\n * @returns {Array} An array of line numbers.\n */\nfunction getCommentLineNums(comments) {\n    const lines = [];\n\n    comments.forEach(token => {\n        const start = token.loc.start.line;\n        const end = token.loc.end.line;\n\n        lines.push(start, end);\n    });\n    return lines;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require empty lines around comments\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    beforeBlockComment: {\n                        type: \"boolean\"\n                    },\n                    afterBlockComment: {\n                        type: \"boolean\"\n                    },\n                    beforeLineComment: {\n                        type: \"boolean\"\n                    },\n                    afterLineComment: {\n                        type: \"boolean\"\n                    },\n                    allowBlockStart: {\n                        type: \"boolean\"\n                    },\n                    allowBlockEnd: {\n                        type: \"boolean\"\n                    },\n                    allowObjectStart: {\n                        type: \"boolean\"\n                    },\n                    allowObjectEnd: {\n                        type: \"boolean\"\n                    },\n                    allowArrayStart: {\n                        type: \"boolean\"\n                    },\n                    allowArrayEnd: {\n                        type: \"boolean\"\n                    },\n                    ignorePattern: {\n                        type: \"string\"\n                    },\n                    applyDefaultIgnorePatterns: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const options = context.options[0] ? Object.assign({}, context.options[0]) : {};\n        const ignorePattern = options.ignorePattern;\n        const defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;\n        const customIgnoreRegExp = new RegExp(ignorePattern);\n        const applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns !== false;\n\n\n        options.beforeLineComment = options.beforeLineComment || false;\n        options.afterLineComment = options.afterLineComment || false;\n        options.beforeBlockComment = typeof options.beforeBlockComment !== \"undefined\" ? options.beforeBlockComment : true;\n        options.afterBlockComment = options.afterBlockComment || false;\n        options.allowBlockStart = options.allowBlockStart || false;\n        options.allowBlockEnd = options.allowBlockEnd || false;\n\n        const sourceCode = context.getSourceCode();\n\n        const lines = sourceCode.lines,\n            numLines = lines.length + 1,\n            comments = sourceCode.getAllComments(),\n            commentLines = getCommentLineNums(comments),\n            emptyLines = getEmptyLineNums(lines),\n            commentAndEmptyLines = commentLines.concat(emptyLines);\n\n        /**\n         * Returns whether or not comments are on lines starting with or ending with code\n         * @param {token} token The comment token to check.\n         * @returns {boolean} True if the comment is not alone.\n         */\n        function codeAroundComment(token) {\n            let currentToken = token;\n\n            do {\n                currentToken = sourceCode.getTokenBefore(currentToken, { includeComments: true });\n            } while (currentToken && astUtils.isCommentToken(currentToken));\n\n            if (currentToken && astUtils.isTokenOnSameLine(currentToken, token)) {\n                return true;\n            }\n\n            currentToken = token;\n            do {\n                currentToken = sourceCode.getTokenAfter(currentToken, { includeComments: true });\n            } while (currentToken && astUtils.isCommentToken(currentToken));\n\n            if (currentToken && astUtils.isTokenOnSameLine(token, currentToken)) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Returns whether or not comments are inside a node type or not.\n         * @param {ASTNode} parent The Comment parent node.\n         * @param {string} nodeType The parent type to check against.\n         * @returns {boolean} True if the comment is inside nodeType.\n         */\n        function isParentNodeType(parent, nodeType) {\n            return parent.type === nodeType ||\n                (parent.body && parent.body.type === nodeType) ||\n                (parent.consequent && parent.consequent.type === nodeType);\n        }\n\n        /**\n         * Returns the parent node that contains the given token.\n         * @param {token} token The token to check.\n         * @returns {ASTNode} The parent node that contains the given token.\n         */\n        function getParentNodeOfToken(token) {\n            return sourceCode.getNodeByRangeIndex(token.range[0]);\n        }\n\n        /**\n         * Returns whether or not comments are at the parent start or not.\n         * @param {token} token The Comment token.\n         * @param {string} nodeType The parent type to check against.\n         * @returns {boolean} True if the comment is at parent start.\n         */\n        function isCommentAtParentStart(token, nodeType) {\n            const parent = getParentNodeOfToken(token);\n\n            return parent && isParentNodeType(parent, nodeType) &&\n                    token.loc.start.line - parent.loc.start.line === 1;\n        }\n\n        /**\n         * Returns whether or not comments are at the parent end or not.\n         * @param {token} token The Comment token.\n         * @param {string} nodeType The parent type to check against.\n         * @returns {boolean} True if the comment is at parent end.\n         */\n        function isCommentAtParentEnd(token, nodeType) {\n            const parent = getParentNodeOfToken(token);\n\n            return parent && isParentNodeType(parent, nodeType) &&\n                    parent.loc.end.line - token.loc.end.line === 1;\n        }\n\n        /**\n         * Returns whether or not comments are at the block start or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at block start.\n         */\n        function isCommentAtBlockStart(token) {\n            return isCommentAtParentStart(token, \"ClassBody\") || isCommentAtParentStart(token, \"BlockStatement\") || isCommentAtParentStart(token, \"SwitchCase\");\n        }\n\n        /**\n         * Returns whether or not comments are at the block end or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at block end.\n         */\n        function isCommentAtBlockEnd(token) {\n            return isCommentAtParentEnd(token, \"ClassBody\") || isCommentAtParentEnd(token, \"BlockStatement\") || isCommentAtParentEnd(token, \"SwitchCase\") || isCommentAtParentEnd(token, \"SwitchStatement\");\n        }\n\n        /**\n         * Returns whether or not comments are at the object start or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at object start.\n         */\n        function isCommentAtObjectStart(token) {\n            return isCommentAtParentStart(token, \"ObjectExpression\") || isCommentAtParentStart(token, \"ObjectPattern\");\n        }\n\n        /**\n         * Returns whether or not comments are at the object end or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at object end.\n         */\n        function isCommentAtObjectEnd(token) {\n            return isCommentAtParentEnd(token, \"ObjectExpression\") || isCommentAtParentEnd(token, \"ObjectPattern\");\n        }\n\n        /**\n         * Returns whether or not comments are at the array start or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at array start.\n         */\n        function isCommentAtArrayStart(token) {\n            return isCommentAtParentStart(token, \"ArrayExpression\") || isCommentAtParentStart(token, \"ArrayPattern\");\n        }\n\n        /**\n         * Returns whether or not comments are at the array end or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at array end.\n         */\n        function isCommentAtArrayEnd(token) {\n            return isCommentAtParentEnd(token, \"ArrayExpression\") || isCommentAtParentEnd(token, \"ArrayPattern\");\n        }\n\n        /**\n         * Checks if a comment token has lines around it (ignores inline comments)\n         * @param {token} token The Comment token.\n         * @param {Object} opts Options to determine the newline.\n         * @param {boolean} opts.after Should have a newline after this line.\n         * @param {boolean} opts.before Should have a newline before this line.\n         * @returns {void}\n         */\n        function checkForEmptyLine(token, opts) {\n            if (applyDefaultIgnorePatterns && defaultIgnoreRegExp.test(token.value)) {\n                return;\n            }\n\n            if (ignorePattern && customIgnoreRegExp.test(token.value)) {\n                return;\n            }\n\n            let after = opts.after,\n                before = opts.before;\n\n            const prevLineNum = token.loc.start.line - 1,\n                nextLineNum = token.loc.end.line + 1,\n                commentIsNotAlone = codeAroundComment(token);\n\n            const blockStartAllowed = options.allowBlockStart && isCommentAtBlockStart(token),\n                blockEndAllowed = options.allowBlockEnd && isCommentAtBlockEnd(token),\n                objectStartAllowed = options.allowObjectStart && isCommentAtObjectStart(token),\n                objectEndAllowed = options.allowObjectEnd && isCommentAtObjectEnd(token),\n                arrayStartAllowed = options.allowArrayStart && isCommentAtArrayStart(token),\n                arrayEndAllowed = options.allowArrayEnd && isCommentAtArrayEnd(token);\n\n            const exceptionStartAllowed = blockStartAllowed || objectStartAllowed || arrayStartAllowed;\n            const exceptionEndAllowed = blockEndAllowed || objectEndAllowed || arrayEndAllowed;\n\n            // ignore top of the file and bottom of the file\n            if (prevLineNum < 1) {\n                before = false;\n            }\n            if (nextLineNum >= numLines) {\n                after = false;\n            }\n\n            // we ignore all inline comments\n            if (commentIsNotAlone) {\n                return;\n            }\n\n            const previousTokenOrComment = sourceCode.getTokenBefore(token, { includeComments: true });\n            const nextTokenOrComment = sourceCode.getTokenAfter(token, { includeComments: true });\n\n            // check for newline before\n            if (!exceptionStartAllowed && before && !lodash.includes(commentAndEmptyLines, prevLineNum) &&\n                    !(astUtils.isCommentToken(previousTokenOrComment) && astUtils.isTokenOnSameLine(previousTokenOrComment, token))) {\n                const lineStart = token.range[0] - token.loc.start.column;\n                const range = [lineStart, lineStart];\n\n                context.report({\n                    node: token,\n                    message: \"Expected line before comment.\",\n                    fix(fixer) {\n                        return fixer.insertTextBeforeRange(range, \"\\n\");\n                    }\n                });\n            }\n\n            // check for newline after\n            if (!exceptionEndAllowed && after && !lodash.includes(commentAndEmptyLines, nextLineNum) &&\n                    !(astUtils.isCommentToken(nextTokenOrComment) && astUtils.isTokenOnSameLine(token, nextTokenOrComment))) {\n                context.report({\n                    node: token,\n                    message: \"Expected line after comment.\",\n                    fix(fixer) {\n                        return fixer.insertTextAfter(token, \"\\n\");\n                    }\n                });\n            }\n\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program() {\n                comments.forEach(token => {\n                    if (token.type === \"Line\") {\n                        if (options.beforeLineComment || options.afterLineComment) {\n                            checkForEmptyLine(token, {\n                                after: options.afterLineComment,\n                                before: options.beforeLineComment\n                            });\n                        }\n                    } else if (token.type === \"Block\") {\n                        if (options.beforeBlockComment || options.afterBlockComment) {\n                            checkForEmptyLine(token, {\n                                after: options.afterBlockComment,\n                                before: options.beforeBlockComment\n                            });\n                        }\n                    }\n                });\n            }\n        };\n    }\n};\n","lines-around-directive.js":"/**\n * @fileoverview Require or disallow newlines around directives.\n * @author Kai Cataldo\n * @deprecated\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow newlines around directives\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            replacedBy: [\"padding-line-between-statements\"]\n        },\n        schema: [{\n            oneOf: [\n                {\n                    enum: [\"always\", \"never\"]\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        before: {\n                            enum: [\"always\", \"never\"]\n                        },\n                        after: {\n                            enum: [\"always\", \"never\"]\n                        }\n                    },\n                    additionalProperties: false,\n                    minProperties: 2\n                }\n            ]\n        }],\n        fixable: \"whitespace\",\n        deprecated: true\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const config = context.options[0] || \"always\";\n        const expectLineBefore = typeof config === \"string\" ? config : config.before;\n        const expectLineAfter = typeof config === \"string\" ? config : config.after;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Check if node is preceded by a blank newline.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} Whether or not the passed in node is preceded by a blank newline.\n         */\n        function hasNewlineBefore(node) {\n            const tokenBefore = sourceCode.getTokenBefore(node, { includeComments: true });\n            const tokenLineBefore = tokenBefore ? tokenBefore.loc.end.line : 0;\n\n            return node.loc.start.line - tokenLineBefore >= 2;\n        }\n\n        /**\n        * Gets the last token of a node that is on the same line as the rest of the node.\n        * This will usually be the last token of the node, but it will be the second-to-last token if the node has a trailing\n        * semicolon on a different line.\n        * @param {ASTNode} node A directive node\n        * @returns {Token} The last token of the node on the line\n        */\n        function getLastTokenOnLine(node) {\n            const lastToken = sourceCode.getLastToken(node);\n            const secondToLastToken = sourceCode.getTokenBefore(lastToken);\n\n            return astUtils.isSemicolonToken(lastToken) && lastToken.loc.start.line > secondToLastToken.loc.end.line\n                ? secondToLastToken\n                : lastToken;\n        }\n\n        /**\n         * Check if node is followed by a blank newline.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} Whether or not the passed in node is followed by a blank newline.\n         */\n        function hasNewlineAfter(node) {\n            const lastToken = getLastTokenOnLine(node);\n            const tokenAfter = sourceCode.getTokenAfter(lastToken, { includeComments: true });\n\n            return tokenAfter.loc.start.line - lastToken.loc.end.line >= 2;\n        }\n\n        /**\n         * Report errors for newlines around directives.\n         * @param {ASTNode} node Node to check.\n         * @param {string} location Whether the error was found before or after the directive.\n         * @param {boolean} expected Whether or not a newline was expected or unexpected.\n         * @returns {void}\n         */\n        function reportError(node, location, expected) {\n            context.report({\n                node,\n                message: \"{{expected}} newline {{location}} \\\"{{value}}\\\" directive.\",\n                data: {\n                    expected: expected ? \"Expected\" : \"Unexpected\",\n                    value: node.expression.value,\n                    location\n                },\n                fix(fixer) {\n                    const lastToken = getLastTokenOnLine(node);\n\n                    if (expected) {\n                        return location === \"before\" ? fixer.insertTextBefore(node, \"\\n\") : fixer.insertTextAfter(lastToken, \"\\n\");\n                    }\n                    return fixer.removeRange(location === \"before\" ? [node.range[0] - 1, node.range[0]] : [lastToken.range[1], lastToken.range[1] + 1]);\n                }\n            });\n        }\n\n        /**\n         * Check lines around directives in node\n         * @param {ASTNode} node - node to check\n         * @returns {void}\n         */\n        function checkDirectives(node) {\n            const directives = astUtils.getDirectivePrologue(node);\n\n            if (!directives.length) {\n                return;\n            }\n\n            const firstDirective = directives[0];\n            const leadingComments = sourceCode.getCommentsBefore(firstDirective);\n\n            // Only check before the first directive if it is preceded by a comment or if it is at the top of\n            // the file and expectLineBefore is set to \"never\". This is to not force a newline at the top of\n            // the file if there are no comments as well as for compatibility with padded-blocks.\n            if (leadingComments.length) {\n                if (expectLineBefore === \"always\" && !hasNewlineBefore(firstDirective)) {\n                    reportError(firstDirective, \"before\", true);\n                }\n\n                if (expectLineBefore === \"never\" && hasNewlineBefore(firstDirective)) {\n                    reportError(firstDirective, \"before\", false);\n                }\n            } else if (\n                node.type === \"Program\" &&\n                expectLineBefore === \"never\" &&\n                !leadingComments.length &&\n                hasNewlineBefore(firstDirective)\n            ) {\n                reportError(firstDirective, \"before\", false);\n            }\n\n            const lastDirective = directives[directives.length - 1];\n            const statements = node.type === \"Program\" ? node.body : node.body.body;\n\n            // Do not check after the last directive if the body only\n            // contains a directive prologue and isn't followed by a comment to ensure\n            // this rule behaves well with padded-blocks.\n            if (lastDirective === statements[statements.length - 1] && !lastDirective.trailingComments) {\n                return;\n            }\n\n            if (expectLineAfter === \"always\" && !hasNewlineAfter(lastDirective)) {\n                reportError(lastDirective, \"after\", true);\n            }\n\n            if (expectLineAfter === \"never\" && hasNewlineAfter(lastDirective)) {\n                reportError(lastDirective, \"after\", false);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: checkDirectives,\n            FunctionDeclaration: checkDirectives,\n            FunctionExpression: checkDirectives,\n            ArrowFunctionExpression: checkDirectives\n        };\n    }\n};\n","max-depth.js":"/**\n * @fileoverview A rule to set the maximum depth block can be nested in a function.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce a maximum depth that blocks can be nested\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            maximum: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const functionStack = [],\n            option = context.options[0];\n        let maxDepth = 4;\n\n        if (typeof option === \"object\" && option.hasOwnProperty(\"maximum\") && typeof option.maximum === \"number\") {\n            maxDepth = option.maximum;\n        }\n        if (typeof option === \"object\" && option.hasOwnProperty(\"max\") && typeof option.max === \"number\") {\n            maxDepth = option.max;\n        }\n        if (typeof option === \"number\") {\n            maxDepth = option;\n        }\n\n        /**\n         * When parsing a new function, store it in our function stack\n         * @returns {void}\n         * @private\n         */\n        function startFunction() {\n            functionStack.push(0);\n        }\n\n        /**\n         * When parsing is done then pop out the reference\n         * @returns {void}\n         * @private\n         */\n        function endFunction() {\n            functionStack.pop();\n        }\n\n        /**\n         * Save the block and Evaluate the node\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function pushBlock(node) {\n            const len = ++functionStack[functionStack.length - 1];\n\n            if (len > maxDepth) {\n                context.report({ node, message: \"Blocks are nested too deeply ({{depth}}).\", data: { depth: len } });\n            }\n        }\n\n        /**\n         * Pop the saved block\n         * @returns {void}\n         * @private\n         */\n        function popBlock() {\n            functionStack[functionStack.length - 1]--;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: startFunction,\n            FunctionDeclaration: startFunction,\n            FunctionExpression: startFunction,\n            ArrowFunctionExpression: startFunction,\n\n            IfStatement(node) {\n                if (node.parent.type !== \"IfStatement\") {\n                    pushBlock(node);\n                }\n            },\n            SwitchStatement: pushBlock,\n            TryStatement: pushBlock,\n            DoWhileStatement: pushBlock,\n            WhileStatement: pushBlock,\n            WithStatement: pushBlock,\n            ForStatement: pushBlock,\n            ForInStatement: pushBlock,\n            ForOfStatement: pushBlock,\n\n            \"IfStatement:exit\": popBlock,\n            \"SwitchStatement:exit\": popBlock,\n            \"TryStatement:exit\": popBlock,\n            \"DoWhileStatement:exit\": popBlock,\n            \"WhileStatement:exit\": popBlock,\n            \"WithStatement:exit\": popBlock,\n            \"ForStatement:exit\": popBlock,\n            \"ForInStatement:exit\": popBlock,\n            \"ForOfStatement:exit\": popBlock,\n\n            \"FunctionDeclaration:exit\": endFunction,\n            \"FunctionExpression:exit\": endFunction,\n            \"ArrowFunctionExpression:exit\": endFunction,\n            \"Program:exit\": endFunction\n        };\n\n    }\n};\n","max-len.js":"/**\n * @fileoverview Rule to check for max length on a line.\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst OPTIONS_SCHEMA = {\n    type: \"object\",\n    properties: {\n        code: {\n            type: \"integer\",\n            minimum: 0\n        },\n        comments: {\n            type: \"integer\",\n            minimum: 0\n        },\n        tabWidth: {\n            type: \"integer\",\n            minimum: 0\n        },\n        ignorePattern: {\n            type: \"string\"\n        },\n        ignoreComments: {\n            type: \"boolean\"\n        },\n        ignoreStrings: {\n            type: \"boolean\"\n        },\n        ignoreUrls: {\n            type: \"boolean\"\n        },\n        ignoreTemplateLiterals: {\n            type: \"boolean\"\n        },\n        ignoreRegExpLiterals: {\n            type: \"boolean\"\n        },\n        ignoreTrailingComments: {\n            type: \"boolean\"\n        }\n    },\n    additionalProperties: false\n};\n\nconst OPTIONS_OR_INTEGER_SCHEMA = {\n    anyOf: [\n        OPTIONS_SCHEMA,\n        {\n            type: \"integer\",\n            minimum: 0\n        }\n    ]\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce a maximum line length\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            OPTIONS_OR_INTEGER_SCHEMA,\n            OPTIONS_OR_INTEGER_SCHEMA,\n            OPTIONS_SCHEMA\n        ]\n    },\n\n    create(context) {\n\n        /*\n         * Inspired by http://tools.ietf.org/html/rfc3986#appendix-B, however:\n         * - They're matching an entire string that we know is a URI\n         * - We're matching part of a string where we think there *might* be a URL\n         * - We're only concerned about URLs, as picking out any URI would cause\n         *   too many false positives\n         * - We don't care about matching the entire URL, any small segment is fine\n         */\n        const URL_REGEXP = /[^:/?#]:\\/\\/[^?#]/;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Computes the length of a line that may contain tabs. The width of each\n         * tab will be the number of spaces to the next tab stop.\n         * @param {string} line The line.\n         * @param {int} tabWidth The width of each tab stop in spaces.\n         * @returns {int} The computed line length.\n         * @private\n         */\n        function computeLineLength(line, tabWidth) {\n            let extraCharacterCount = 0;\n\n            line.replace(/\\t/g, (match, offset) => {\n                const totalOffset = offset + extraCharacterCount,\n                    previousTabStopOffset = tabWidth ? totalOffset % tabWidth : 0,\n                    spaceCount = tabWidth - previousTabStopOffset;\n\n                extraCharacterCount += spaceCount - 1; // -1 for the replaced tab\n            });\n            return Array.from(line).length + extraCharacterCount;\n        }\n\n        // The options object must be the last option specifiedâ¦\n        const lastOption = context.options[context.options.length - 1];\n        const options = typeof lastOption === \"object\" ? Object.create(lastOption) : {};\n\n        // â¦but max code lengthâ¦\n        if (typeof context.options[0] === \"number\") {\n            options.code = context.options[0];\n        }\n\n        // â¦and tabWidth can be optionally specified directly as integers.\n        if (typeof context.options[1] === \"number\") {\n            options.tabWidth = context.options[1];\n        }\n\n        const maxLength = options.code || 80,\n            tabWidth = options.tabWidth || 4,\n            ignoreComments = options.ignoreComments || false,\n            ignoreStrings = options.ignoreStrings || false,\n            ignoreTemplateLiterals = options.ignoreTemplateLiterals || false,\n            ignoreRegExpLiterals = options.ignoreRegExpLiterals || false,\n            ignoreTrailingComments = options.ignoreTrailingComments || options.ignoreComments || false,\n            ignoreUrls = options.ignoreUrls || false,\n            maxCommentLength = options.comments;\n        let ignorePattern = options.ignorePattern || null;\n\n        if (ignorePattern) {\n            ignorePattern = new RegExp(ignorePattern);\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Tells if a given comment is trailing: it starts on the current line and\n         * extends to or past the end of the current line.\n         * @param {string} line The source line we want to check for a trailing comment on\n         * @param {number} lineNumber The one-indexed line number for line\n         * @param {ASTNode} comment The comment to inspect\n         * @returns {boolean} If the comment is trailing on the given line\n         */\n        function isTrailingComment(line, lineNumber, comment) {\n            return comment &&\n                (comment.loc.start.line === lineNumber && lineNumber <= comment.loc.end.line) &&\n                (comment.loc.end.line > lineNumber || comment.loc.end.column === line.length);\n        }\n\n        /**\n         * Tells if a comment encompasses the entire line.\n         * @param {string} line The source line with a trailing comment\n         * @param {number} lineNumber The one-indexed line number this is on\n         * @param {ASTNode} comment The comment to remove\n         * @returns {boolean} If the comment covers the entire line\n         */\n        function isFullLineComment(line, lineNumber, comment) {\n            const start = comment.loc.start,\n                end = comment.loc.end,\n                isFirstTokenOnLine = !line.slice(0, comment.loc.start.column).trim();\n\n            return comment &&\n                (start.line < lineNumber || (start.line === lineNumber && isFirstTokenOnLine)) &&\n                (end.line > lineNumber || (end.line === lineNumber && end.column === line.length));\n        }\n\n        /**\n         * Gets the line after the comment and any remaining trailing whitespace is\n         * stripped.\n         * @param {string} line The source line with a trailing comment\n         * @param {ASTNode} comment The comment to remove\n         * @returns {string} Line without comment and trailing whitepace\n         */\n        function stripTrailingComment(line, comment) {\n\n            // loc.column is zero-indexed\n            return line.slice(0, comment.loc.start.column).replace(/\\s+$/, \"\");\n        }\n\n        /**\n         * Ensure that an array exists at [key] on `object`, and add `value` to it.\n         *\n         * @param {Object} object the object to mutate\n         * @param {string} key the object's key\n         * @param {*} value the value to add\n         * @returns {void}\n         * @private\n         */\n        function ensureArrayAndPush(object, key, value) {\n            if (!Array.isArray(object[key])) {\n                object[key] = [];\n            }\n            object[key].push(value);\n        }\n\n        /**\n         * Retrieves an array containing all strings (\" or ') in the source code.\n         *\n         * @returns {ASTNode[]} An array of string nodes.\n         */\n        function getAllStrings() {\n            return sourceCode.ast.tokens.filter(token => token.type === \"String\");\n        }\n\n        /**\n         * Retrieves an array containing all template literals in the source code.\n         *\n         * @returns {ASTNode[]} An array of template literal nodes.\n         */\n        function getAllTemplateLiterals() {\n            return sourceCode.ast.tokens.filter(token => token.type === \"Template\");\n        }\n\n\n        /**\n         * Retrieves an array containing all RegExp literals in the source code.\n         *\n         * @returns {ASTNode[]} An array of RegExp literal nodes.\n         */\n        function getAllRegExpLiterals() {\n            return sourceCode.ast.tokens.filter(token => token.type === \"RegularExpression\");\n        }\n\n\n        /**\n         * A reducer to group an AST node by line number, both start and end.\n         *\n         * @param {Object} acc the accumulator\n         * @param {ASTNode} node the AST node in question\n         * @returns {Object} the modified accumulator\n         * @private\n         */\n        function groupByLineNumber(acc, node) {\n            for (let i = node.loc.start.line; i <= node.loc.end.line; ++i) {\n                ensureArrayAndPush(acc, i, node);\n            }\n            return acc;\n        }\n\n        /**\n         * Check the program for max length\n         * @param {ASTNode} node Node to examine\n         * @returns {void}\n         * @private\n         */\n        function checkProgramForMaxLength(node) {\n\n            // split (honors line-ending)\n            const lines = sourceCode.lines,\n\n                // list of comments to ignore\n                comments = ignoreComments || maxCommentLength || ignoreTrailingComments ? sourceCode.getAllComments() : [];\n\n                // we iterate over comments in parallel with the lines\n            let commentsIndex = 0;\n\n            const strings = getAllStrings();\n            const stringsByLine = strings.reduce(groupByLineNumber, {});\n\n            const templateLiterals = getAllTemplateLiterals();\n            const templateLiteralsByLine = templateLiterals.reduce(groupByLineNumber, {});\n\n            const regExpLiterals = getAllRegExpLiterals();\n            const regExpLiteralsByLine = regExpLiterals.reduce(groupByLineNumber, {});\n\n            lines.forEach((line, i) => {\n\n                // i is zero-indexed, line numbers are one-indexed\n                const lineNumber = i + 1;\n\n                /*\n                 * if we're checking comment length; we need to know whether this\n                 * line is a comment\n                 */\n                let lineIsComment = false;\n\n                /*\n                 * We can short-circuit the comment checks if we're already out of\n                 * comments to check.\n                 */\n                if (commentsIndex < comments.length) {\n                    let comment = null;\n\n                    // iterate over comments until we find one past the current line\n                    do {\n                        comment = comments[++commentsIndex];\n                    } while (comment && comment.loc.start.line <= lineNumber);\n\n                    // and step back by one\n                    comment = comments[--commentsIndex];\n\n                    if (isFullLineComment(line, lineNumber, comment)) {\n                        lineIsComment = true;\n                    } else if (ignoreTrailingComments && isTrailingComment(line, lineNumber, comment)) {\n                        line = stripTrailingComment(line, comment);\n                    }\n                }\n                if (ignorePattern && ignorePattern.test(line) ||\n                    ignoreUrls && URL_REGEXP.test(line) ||\n                    ignoreStrings && stringsByLine[lineNumber] ||\n                    ignoreTemplateLiterals && templateLiteralsByLine[lineNumber] ||\n                    ignoreRegExpLiterals && regExpLiteralsByLine[lineNumber]\n                ) {\n\n                    // ignore this line\n                    return;\n                }\n\n                const lineLength = computeLineLength(line, tabWidth);\n                const commentLengthApplies = lineIsComment && maxCommentLength;\n\n                if (lineIsComment && ignoreComments) {\n                    return;\n                }\n\n                if (commentLengthApplies) {\n                    if (lineLength > maxCommentLength) {\n                        context.report({\n                            node,\n                            loc: { line: lineNumber, column: 0 },\n                            message: \"Line {{lineNumber}} exceeds the maximum comment line length of {{maxCommentLength}}.\",\n                            data: {\n                                lineNumber: i + 1,\n                                maxCommentLength\n                            }\n                        });\n                    }\n                } else if (lineLength > maxLength) {\n                    context.report({\n                        node,\n                        loc: { line: lineNumber, column: 0 },\n                        message: \"Line {{lineNumber}} exceeds the maximum line length of {{maxLength}}.\",\n                        data: {\n                            lineNumber: i + 1,\n                            maxLength\n                        }\n                    });\n                }\n            });\n        }\n\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: checkProgramForMaxLength\n        };\n\n    }\n};\n","max-lines.js":"/**\n * @fileoverview enforce a maximum file length\n * @author Alberto RodrÃ­guez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce a maximum number of lines per file\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            skipComments: {\n                                type: \"boolean\"\n                            },\n                            skipBlankLines: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const option = context.options[0];\n        let max = 300;\n\n        if (typeof option === \"object\" && option.hasOwnProperty(\"max\") && typeof option.max === \"number\") {\n            max = option.max;\n        }\n\n        if (typeof option === \"number\") {\n            max = option;\n        }\n\n        const skipComments = option && option.skipComments;\n        const skipBlankLines = option && option.skipBlankLines;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Returns whether or not a token is a comment node type\n         * @param {Token} token The token to check\n         * @returns {boolean} True if the token is a comment node\n         */\n        function isCommentNodeType(token) {\n            return token && (token.type === \"Block\" || token.type === \"Line\");\n        }\n\n        /**\n         * Returns the line numbers of a comment that don't have any code on the same line\n         * @param {Node} comment The comment node to check\n         * @returns {int[]} The line numbers\n         */\n        function getLinesWithoutCode(comment) {\n            let start = comment.loc.start.line;\n            let end = comment.loc.end.line;\n\n            let token;\n\n            token = comment;\n            do {\n                token = sourceCode.getTokenBefore(token, { includeComments: true });\n            } while (isCommentNodeType(token));\n\n            if (token && astUtils.isTokenOnSameLine(token, comment)) {\n                start += 1;\n            }\n\n            token = comment;\n            do {\n                token = sourceCode.getTokenAfter(token, { includeComments: true });\n            } while (isCommentNodeType(token));\n\n            if (token && astUtils.isTokenOnSameLine(comment, token)) {\n                end -= 1;\n            }\n\n            if (start <= end) {\n                return lodash.range(start, end + 1);\n            }\n            return [];\n        }\n\n        return {\n            \"Program:exit\"() {\n                let lines = sourceCode.lines.map((text, i) => ({ lineNumber: i + 1, text }));\n\n                if (skipBlankLines) {\n                    lines = lines.filter(l => l.text.trim() !== \"\");\n                }\n\n                if (skipComments) {\n                    const comments = sourceCode.getAllComments();\n\n                    const commentLines = lodash.flatten(comments.map(comment => getLinesWithoutCode(comment)));\n\n                    lines = lines.filter(l => !lodash.includes(commentLines, l.lineNumber));\n                }\n\n                if (lines.length > max) {\n                    context.report({\n                        loc: { line: 1, column: 0 },\n                        message: \"File must be at most {{max}} lines long. It's {{actual}} lines long.\",\n                        data: {\n                            max,\n                            actual: lines.length\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","max-nested-callbacks.js":"/**\n * @fileoverview Rule to enforce a maximum number of nested callbacks.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce a maximum depth that callbacks can be nested\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            maximum: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Constants\n        //--------------------------------------------------------------------------\n        const option = context.options[0];\n        let THRESHOLD = 10;\n\n        if (typeof option === \"object\" && option.hasOwnProperty(\"maximum\") && typeof option.maximum === \"number\") {\n            THRESHOLD = option.maximum;\n        }\n        if (typeof option === \"object\" && option.hasOwnProperty(\"max\") && typeof option.max === \"number\") {\n            THRESHOLD = option.max;\n        }\n        if (typeof option === \"number\") {\n            THRESHOLD = option;\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const callbackStack = [];\n\n        /**\n         * Checks a given function node for too many callbacks.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkFunction(node) {\n            const parent = node.parent;\n\n            if (parent.type === \"CallExpression\") {\n                callbackStack.push(node);\n            }\n\n            if (callbackStack.length > THRESHOLD) {\n                const opts = { num: callbackStack.length, max: THRESHOLD };\n\n                context.report({ node, message: \"Too many nested callbacks ({{num}}). Maximum allowed is {{max}}.\", data: opts });\n            }\n        }\n\n        /**\n         * Pops the call stack.\n         * @returns {void}\n         * @private\n         */\n        function popStack() {\n            callbackStack.pop();\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            ArrowFunctionExpression: checkFunction,\n            \"ArrowFunctionExpression:exit\": popStack,\n\n            FunctionExpression: checkFunction,\n            \"FunctionExpression:exit\": popStack\n        };\n\n    }\n};\n","max-params.js":"/**\n * @fileoverview Rule to flag when a function has too many parameters\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce a maximum number of parameters in function definitions\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            maximum: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n\n        const option = context.options[0];\n        let numParams = 3;\n\n        if (typeof option === \"object\" && option.hasOwnProperty(\"maximum\") && typeof option.maximum === \"number\") {\n            numParams = option.maximum;\n        }\n        if (typeof option === \"object\" && option.hasOwnProperty(\"max\") && typeof option.max === \"number\") {\n            numParams = option.max;\n        }\n        if (typeof option === \"number\") {\n            numParams = option;\n        }\n\n        /**\n         * Checks a function to see if it has too many parameters.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkFunction(node) {\n            if (node.params.length > numParams) {\n                context.report({\n                    node,\n                    message: \"{{name}} has too many parameters ({{count}}). Maximum allowed is {{max}}.\",\n                    data: {\n                        name: lodash.upperFirst(astUtils.getFunctionNameWithKind(node)),\n                        count: node.params.length,\n                        max: numParams\n                    }\n                });\n            }\n        }\n\n        return {\n            FunctionDeclaration: checkFunction,\n            ArrowFunctionExpression: checkFunction,\n            FunctionExpression: checkFunction\n        };\n\n    }\n};\n","max-statements-per-line.js":"/**\n * @fileoverview Specify the maximum number of statements allowed per line.\n * @author Kenneth Williams\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce a maximum number of statements allowed per line\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    max: {\n                        type: \"integer\",\n                        minimum: 1\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode(),\n            options = context.options[0] || {},\n            maxStatementsPerLine = typeof options.max !== \"undefined\" ? options.max : 1,\n            message = \"This line has {{numberOfStatementsOnThisLine}} {{statements}}. Maximum allowed is {{maxStatementsPerLine}}.\";\n\n        let lastStatementLine = 0,\n            numberOfStatementsOnThisLine = 0,\n            firstExtraStatement;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const SINGLE_CHILD_ALLOWED = /^(?:(?:DoWhile|For|ForIn|ForOf|If|Labeled|While)Statement|Export(?:Default|Named)Declaration)$/;\n\n        /**\n         * Reports with the first extra statement, and clears it.\n         *\n         * @returns {void}\n         */\n        function reportFirstExtraStatementAndClear() {\n            if (firstExtraStatement) {\n                context.report({\n                    node: firstExtraStatement,\n                    message,\n                    data: {\n                        numberOfStatementsOnThisLine,\n                        maxStatementsPerLine,\n                        statements: numberOfStatementsOnThisLine === 1 ? \"statement\" : \"statements\"\n                    }\n                });\n            }\n            firstExtraStatement = null;\n        }\n\n        /**\n         * Gets the actual last token of a given node.\n         *\n         * @param {ASTNode} node - A node to get. This is a node except EmptyStatement.\n         * @returns {Token} The actual last token.\n         */\n        function getActualLastToken(node) {\n            return sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);\n        }\n\n        /**\n         * Addresses a given node.\n         * It updates the state of this rule, then reports the node if the node violated this rule.\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {void}\n         */\n        function enterStatement(node) {\n            const line = node.loc.start.line;\n\n            // Skip to allow non-block statements if this is direct child of control statements.\n            // `if (a) foo();` is counted as 1.\n            // But `if (a) foo(); else foo();` should be counted as 2.\n            if (SINGLE_CHILD_ALLOWED.test(node.parent.type) &&\n                node.parent.alternate !== node\n            ) {\n                return;\n            }\n\n            // Update state.\n            if (line === lastStatementLine) {\n                numberOfStatementsOnThisLine += 1;\n            } else {\n                reportFirstExtraStatementAndClear();\n                numberOfStatementsOnThisLine = 1;\n                lastStatementLine = line;\n            }\n\n            // Reports if the node violated this rule.\n            if (numberOfStatementsOnThisLine === maxStatementsPerLine + 1) {\n                firstExtraStatement = firstExtraStatement || node;\n            }\n        }\n\n        /**\n         * Updates the state of this rule with the end line of leaving node to check with the next statement.\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {void}\n         */\n        function leaveStatement(node) {\n            const line = getActualLastToken(node).loc.end.line;\n\n            // Update state.\n            if (line !== lastStatementLine) {\n                reportFirstExtraStatementAndClear();\n                numberOfStatementsOnThisLine = 1;\n                lastStatementLine = line;\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            BreakStatement: enterStatement,\n            ClassDeclaration: enterStatement,\n            ContinueStatement: enterStatement,\n            DebuggerStatement: enterStatement,\n            DoWhileStatement: enterStatement,\n            ExpressionStatement: enterStatement,\n            ForInStatement: enterStatement,\n            ForOfStatement: enterStatement,\n            ForStatement: enterStatement,\n            FunctionDeclaration: enterStatement,\n            IfStatement: enterStatement,\n            ImportDeclaration: enterStatement,\n            LabeledStatement: enterStatement,\n            ReturnStatement: enterStatement,\n            SwitchStatement: enterStatement,\n            ThrowStatement: enterStatement,\n            TryStatement: enterStatement,\n            VariableDeclaration: enterStatement,\n            WhileStatement: enterStatement,\n            WithStatement: enterStatement,\n            ExportNamedDeclaration: enterStatement,\n            ExportDefaultDeclaration: enterStatement,\n            ExportAllDeclaration: enterStatement,\n\n            \"BreakStatement:exit\": leaveStatement,\n            \"ClassDeclaration:exit\": leaveStatement,\n            \"ContinueStatement:exit\": leaveStatement,\n            \"DebuggerStatement:exit\": leaveStatement,\n            \"DoWhileStatement:exit\": leaveStatement,\n            \"ExpressionStatement:exit\": leaveStatement,\n            \"ForInStatement:exit\": leaveStatement,\n            \"ForOfStatement:exit\": leaveStatement,\n            \"ForStatement:exit\": leaveStatement,\n            \"FunctionDeclaration:exit\": leaveStatement,\n            \"IfStatement:exit\": leaveStatement,\n            \"ImportDeclaration:exit\": leaveStatement,\n            \"LabeledStatement:exit\": leaveStatement,\n            \"ReturnStatement:exit\": leaveStatement,\n            \"SwitchStatement:exit\": leaveStatement,\n            \"ThrowStatement:exit\": leaveStatement,\n            \"TryStatement:exit\": leaveStatement,\n            \"VariableDeclaration:exit\": leaveStatement,\n            \"WhileStatement:exit\": leaveStatement,\n            \"WithStatement:exit\": leaveStatement,\n            \"ExportNamedDeclaration:exit\": leaveStatement,\n            \"ExportDefaultDeclaration:exit\": leaveStatement,\n            \"ExportAllDeclaration:exit\": leaveStatement,\n            \"Program:exit\": reportFirstExtraStatementAndClear\n        };\n    }\n};\n","max-statements.js":"/**\n * @fileoverview A rule to set the maximum number of statements in a function.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce a maximum number of statements allowed in function blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            maximum: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    ignoreTopLevelFunctions: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const functionStack = [],\n            option = context.options[0],\n            ignoreTopLevelFunctions = context.options[1] && context.options[1].ignoreTopLevelFunctions || false,\n            topLevelFunctions = [];\n        let maxStatements = 10;\n\n        if (typeof option === \"object\" && option.hasOwnProperty(\"maximum\") && typeof option.maximum === \"number\") {\n            maxStatements = option.maximum;\n        }\n        if (typeof option === \"object\" && option.hasOwnProperty(\"max\") && typeof option.max === \"number\") {\n            maxStatements = option.max;\n        }\n        if (typeof option === \"number\") {\n            maxStatements = option;\n        }\n\n        /**\n         * Reports a node if it has too many statements\n         * @param {ASTNode} node node to evaluate\n         * @param {int} count Number of statements in node\n         * @param {int} max Maximum number of statements allowed\n         * @returns {void}\n         * @private\n         */\n        function reportIfTooManyStatements(node, count, max) {\n            if (count > max) {\n                const name = lodash.upperFirst(astUtils.getFunctionNameWithKind(node));\n\n                context.report({\n                    node,\n                    message: \"{{name}} has too many statements ({{count}}). Maximum allowed is {{max}}.\",\n                    data: { name, count, max }\n                });\n            }\n        }\n\n        /**\n         * When parsing a new function, store it in our function stack\n         * @returns {void}\n         * @private\n         */\n        function startFunction() {\n            functionStack.push(0);\n        }\n\n        /**\n         * Evaluate the node at the end of function\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function endFunction(node) {\n            const count = functionStack.pop();\n\n            if (ignoreTopLevelFunctions && functionStack.length === 0) {\n                topLevelFunctions.push({ node, count });\n            } else {\n                reportIfTooManyStatements(node, count, maxStatements);\n            }\n        }\n\n        /**\n         * Increment the count of the functions\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function countStatements(node) {\n            functionStack[functionStack.length - 1] += node.body.length;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            FunctionDeclaration: startFunction,\n            FunctionExpression: startFunction,\n            ArrowFunctionExpression: startFunction,\n\n            BlockStatement: countStatements,\n\n            \"FunctionDeclaration:exit\": endFunction,\n            \"FunctionExpression:exit\": endFunction,\n            \"ArrowFunctionExpression:exit\": endFunction,\n\n            \"Program:exit\"() {\n                if (topLevelFunctions.length === 1) {\n                    return;\n                }\n\n                topLevelFunctions.forEach(element => {\n                    const count = element.count;\n                    const node = element.node;\n\n                    reportIfTooManyStatements(node, count, maxStatements);\n                });\n            }\n        };\n\n    }\n};\n","multiline-ternary.js":"/**\n * @fileoverview Enforce newlines between operands of ternary expressions\n * @author Kai Cataldo\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce newlines between operands of ternary expressions\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        schema: [\n            {\n                enum: [\"always\", \"always-multiline\", \"never\"]\n            }\n        ]\n    },\n\n    create(context) {\n        const option = context.options[0];\n        const multiline = option !== \"never\";\n        const allowSingleLine = option === \"always-multiline\";\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Tests whether node is preceded by supplied tokens\n         * @param {ASTNode} node - node to check\n         * @param {ASTNode} parentNode - parent of node to report\n         * @param {boolean} expected - whether newline was expected or not\n         * @returns {void}\n         * @private\n         */\n        function reportError(node, parentNode, expected) {\n            context.report({\n                node,\n                message: \"{{expected}} newline between {{typeOfError}} of ternary expression.\",\n                data: {\n                    expected: expected ? \"Expected\" : \"Unexpected\",\n                    typeOfError: node === parentNode.test ? \"test and consequent\" : \"consequent and alternate\"\n                }\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ConditionalExpression(node) {\n                const areTestAndConsequentOnSameLine = astUtils.isTokenOnSameLine(node.test, node.consequent);\n                const areConsequentAndAlternateOnSameLine = astUtils.isTokenOnSameLine(node.consequent, node.alternate);\n\n                if (!multiline) {\n                    if (!areTestAndConsequentOnSameLine) {\n                        reportError(node.test, node, false);\n                    }\n\n                    if (!areConsequentAndAlternateOnSameLine) {\n                        reportError(node.consequent, node, false);\n                    }\n                } else {\n                    if (allowSingleLine && node.loc.start.line === node.loc.end.line) {\n                        return;\n                    }\n\n                    if (areTestAndConsequentOnSameLine) {\n                        reportError(node.test, node, true);\n                    }\n\n                    if (areConsequentAndAlternateOnSameLine) {\n                        reportError(node.consequent, node, true);\n                    }\n                }\n            }\n        };\n    }\n};\n","new-cap.js":"/**\n * @fileoverview Rule to flag use of constructors without capital letters\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst CAPS_ALLOWED = [\n    \"Array\",\n    \"Boolean\",\n    \"Date\",\n    \"Error\",\n    \"Function\",\n    \"Number\",\n    \"Object\",\n    \"RegExp\",\n    \"String\",\n    \"Symbol\"\n];\n\n/**\n * Ensure that if the key is provided, it must be an array.\n * @param {Object} obj Object to check with `key`.\n * @param {string} key Object key to check on `obj`.\n * @param {*} fallback If obj[key] is not present, this will be returned.\n * @returns {string[]} Returns obj[key] if it's an Array, otherwise `fallback`\n */\nfunction checkArray(obj, key, fallback) {\n\n    /* istanbul ignore if */\n    if (Object.prototype.hasOwnProperty.call(obj, key) && !Array.isArray(obj[key])) {\n        throw new TypeError(`${key}, if provided, must be an Array`);\n    }\n    return obj[key] || fallback;\n}\n\n/**\n * A reducer function to invert an array to an Object mapping the string form of the key, to `true`.\n * @param {Object} map Accumulator object for the reduce.\n * @param {string} key Object key to set to `true`.\n * @returns {Object} Returns the updated Object for further reduction.\n */\nfunction invert(map, key) {\n    map[key] = true;\n    return map;\n}\n\n/**\n * Creates an object with the cap is new exceptions as its keys and true as their values.\n * @param {Object} config Rule configuration\n * @returns {Object} Object with cap is new exceptions.\n */\nfunction calculateCapIsNewExceptions(config) {\n    let capIsNewExceptions = checkArray(config, \"capIsNewExceptions\", CAPS_ALLOWED);\n\n    if (capIsNewExceptions !== CAPS_ALLOWED) {\n        capIsNewExceptions = capIsNewExceptions.concat(CAPS_ALLOWED);\n    }\n\n    return capIsNewExceptions.reduce(invert, {});\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require constructor names to begin with a capital letter\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    newIsCap: {\n                        type: \"boolean\"\n                    },\n                    capIsNew: {\n                        type: \"boolean\"\n                    },\n                    newIsCapExceptions: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    newIsCapExceptionPattern: {\n                        type: \"string\"\n                    },\n                    capIsNewExceptions: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    capIsNewExceptionPattern: {\n                        type: \"string\"\n                    },\n                    properties: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const config = context.options[0] ? Object.assign({}, context.options[0]) : {};\n\n        config.newIsCap = config.newIsCap !== false;\n        config.capIsNew = config.capIsNew !== false;\n        const skipProperties = config.properties === false;\n\n        const newIsCapExceptions = checkArray(config, \"newIsCapExceptions\", []).reduce(invert, {});\n        const newIsCapExceptionPattern = config.newIsCapExceptionPattern ? new RegExp(config.newIsCapExceptionPattern) : null;\n\n        const capIsNewExceptions = calculateCapIsNewExceptions(config);\n        const capIsNewExceptionPattern = config.capIsNewExceptionPattern ? new RegExp(config.capIsNewExceptionPattern) : null;\n\n        const listeners = {};\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Get exact callee name from expression\n         * @param {ASTNode} node CallExpression or NewExpression node\n         * @returns {string} name\n         */\n        function extractNameFromExpression(node) {\n\n            let name = \"\";\n\n            if (node.callee.type === \"MemberExpression\") {\n                const property = node.callee.property;\n\n                if (property.type === \"Literal\" && (typeof property.value === \"string\")) {\n                    name = property.value;\n                } else if (property.type === \"Identifier\" && !node.callee.computed) {\n                    name = property.name;\n                }\n            } else {\n                name = node.callee.name;\n            }\n            return name;\n        }\n\n        /**\n         * Returns the capitalization state of the string -\n         * Whether the first character is uppercase, lowercase, or non-alphabetic\n         * @param {string} str String\n         * @returns {string} capitalization state: \"non-alpha\", \"lower\", or \"upper\"\n         */\n        function getCap(str) {\n            const firstChar = str.charAt(0);\n\n            const firstCharLower = firstChar.toLowerCase();\n            const firstCharUpper = firstChar.toUpperCase();\n\n            if (firstCharLower === firstCharUpper) {\n\n                // char has no uppercase variant, so it's non-alphabetic\n                return \"non-alpha\";\n            } else if (firstChar === firstCharLower) {\n                return \"lower\";\n            }\n            return \"upper\";\n\n        }\n\n        /**\n         * Check if capitalization is allowed for a CallExpression\n         * @param {Object} allowedMap Object mapping calleeName to a Boolean\n         * @param {ASTNode} node CallExpression node\n         * @param {string} calleeName Capitalized callee name from a CallExpression\n         * @param {Object} pattern RegExp object from options pattern\n         * @returns {boolean} Returns true if the callee may be capitalized\n         */\n        function isCapAllowed(allowedMap, node, calleeName, pattern) {\n            const sourceText = sourceCode.getText(node.callee);\n\n            if (allowedMap[calleeName] || allowedMap[sourceText]) {\n                return true;\n            }\n\n            if (pattern && pattern.test(sourceText)) {\n                return true;\n            }\n\n            if (calleeName === \"UTC\" && node.callee.type === \"MemberExpression\") {\n\n                // allow if callee is Date.UTC\n                return node.callee.object.type === \"Identifier\" &&\n                    node.callee.object.name === \"Date\";\n            }\n\n            return skipProperties && node.callee.type === \"MemberExpression\";\n        }\n\n        /**\n         * Reports the given message for the given node. The location will be the start of the property or the callee.\n         * @param {ASTNode} node CallExpression or NewExpression node.\n         * @param {string} message The message to report.\n         * @returns {void}\n         */\n        function report(node, message) {\n            let callee = node.callee;\n\n            if (callee.type === \"MemberExpression\") {\n                callee = callee.property;\n            }\n\n            context.report({ node, loc: callee.loc.start, message });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        if (config.newIsCap) {\n            listeners.NewExpression = function(node) {\n\n                const constructorName = extractNameFromExpression(node);\n\n                if (constructorName) {\n                    const capitalization = getCap(constructorName);\n                    const isAllowed = capitalization !== \"lower\" || isCapAllowed(newIsCapExceptions, node, constructorName, newIsCapExceptionPattern);\n\n                    if (!isAllowed) {\n                        report(node, \"A constructor name should not start with a lowercase letter.\");\n                    }\n                }\n            };\n        }\n\n        if (config.capIsNew) {\n            listeners.CallExpression = function(node) {\n\n                const calleeName = extractNameFromExpression(node);\n\n                if (calleeName) {\n                    const capitalization = getCap(calleeName);\n                    const isAllowed = capitalization !== \"upper\" || isCapAllowed(capIsNewExceptions, node, calleeName, capIsNewExceptionPattern);\n\n                    if (!isAllowed) {\n                        report(node, \"A function with a name starting with an uppercase letter should only be used as a constructor.\");\n                    }\n                }\n            };\n        }\n\n        return listeners;\n    }\n};\n","new-parens.js":"/**\n * @fileoverview Rule to flag when using constructor without parentheses\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require parentheses when invoking a constructor with no arguments\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            NewExpression(node) {\n                if (node.arguments.length !== 0) {\n                    return; // shortcut: if there are arguments, there have to be parens\n                }\n\n                const lastToken = sourceCode.getLastToken(node);\n                const hasLastParen = lastToken && astUtils.isClosingParenToken(lastToken);\n                const hasParens = hasLastParen && astUtils.isOpeningParenToken(sourceCode.getTokenBefore(lastToken));\n\n                if (!hasParens) {\n                    context.report({\n                        node,\n                        message: \"Missing '()' invoking a constructor.\",\n                        fix: fixer => fixer.insertTextAfter(node, \"()\")\n                    });\n                }\n            }\n        };\n    }\n};\n","newline-after-var.js":"/**\n * @fileoverview Rule to check empty newline after \"var\" statement\n * @author Gopal Venkatesan\n * @deprecated\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow an empty line after variable declarations\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            replacedBy: [\"padding-line-between-statements\"]\n        },\n\n        schema: [\n            {\n                enum: [\"never\", \"always\"]\n            }\n        ],\n\n        fixable: \"whitespace\",\n\n        deprecated: true\n    },\n\n    create(context) {\n\n        const ALWAYS_MESSAGE = \"Expected blank line after variable declarations.\",\n            NEVER_MESSAGE = \"Unexpected blank line after variable declarations.\";\n\n        const sourceCode = context.getSourceCode();\n\n        // Default `mode` to \"always\".\n        const mode = context.options[0] === \"never\" ? \"never\" : \"always\";\n\n        // Cache starting and ending line numbers of comments for faster lookup\n        const commentEndLine = sourceCode.getAllComments().reduce((result, token) => {\n            result[token.loc.start.line] = token.loc.end.line;\n            return result;\n        }, {});\n\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Gets a token from the given node to compare line to the next statement.\n         *\n         * In general, the token is the last token of the node. However, the token is the second last token if the following conditions satisfy.\n         *\n         * - The last token is semicolon.\n         * - The semicolon is on a different line from the previous token of the semicolon.\n         *\n         * This behavior would address semicolon-less style code. e.g.:\n         *\n         *     var foo = 1\n         *\n         *     ;(a || b).doSomething()\n         *\n         * @param {ASTNode} node - The node to get.\n         * @returns {Token} The token to compare line to the next statement.\n         */\n        function getLastToken(node) {\n            const lastToken = sourceCode.getLastToken(node);\n\n            if (lastToken.type === \"Punctuator\" && lastToken.value === \";\") {\n                const prevToken = sourceCode.getTokenBefore(lastToken);\n\n                if (prevToken.loc.end.line !== lastToken.loc.start.line) {\n                    return prevToken;\n                }\n            }\n\n            return lastToken;\n        }\n\n        /**\n         * Determine if provided keyword is a variable declaration\n         * @private\n         * @param {string} keyword - keyword to test\n         * @returns {boolean} True if `keyword` is a type of var\n         */\n        function isVar(keyword) {\n            return keyword === \"var\" || keyword === \"let\" || keyword === \"const\";\n        }\n\n        /**\n         * Determine if provided keyword is a variant of for specifiers\n         * @private\n         * @param {string} keyword - keyword to test\n         * @returns {boolean} True if `keyword` is a variant of for specifier\n         */\n        function isForTypeSpecifier(keyword) {\n            return keyword === \"ForStatement\" || keyword === \"ForInStatement\" || keyword === \"ForOfStatement\";\n        }\n\n        /**\n         * Determine if provided keyword is an export specifiers\n         * @private\n         * @param {string} nodeType - nodeType to test\n         * @returns {boolean} True if `nodeType` is an export specifier\n         */\n        function isExportSpecifier(nodeType) {\n            return nodeType === \"ExportNamedDeclaration\" || nodeType === \"ExportSpecifier\" ||\n                nodeType === \"ExportDefaultDeclaration\" || nodeType === \"ExportAllDeclaration\";\n        }\n\n        /**\n         * Determine if provided node is the last of their parent block.\n         * @private\n         * @param {ASTNode} node - node to test\n         * @returns {boolean} True if `node` is last of their parent block.\n         */\n        function isLastNode(node) {\n            const token = sourceCode.getTokenAfter(node);\n\n            return !token || (token.type === \"Punctuator\" && token.value === \"}\");\n        }\n\n        /**\n        * Gets the last line of a group of consecutive comments\n        * @param {number} commentStartLine The starting line of the group\n        * @returns {number} The number of the last comment line of the group\n        */\n        function getLastCommentLineOfBlock(commentStartLine) {\n            const currentCommentEnd = commentEndLine[commentStartLine];\n\n            return commentEndLine[currentCommentEnd + 1] ? getLastCommentLineOfBlock(currentCommentEnd + 1) : currentCommentEnd;\n        }\n\n        /**\n         * Determine if a token starts more than one line after a comment ends\n         * @param  {token}   token            The token being checked\n         * @param {integer}  commentStartLine The line number on which the comment starts\n         * @returns {boolean}                 True if `token` does not start immediately after a comment\n         */\n        function hasBlankLineAfterComment(token, commentStartLine) {\n            return token.loc.start.line > getLastCommentLineOfBlock(commentStartLine) + 1;\n        }\n\n        /**\n         * Checks that a blank line exists after a variable declaration when mode is\n         * set to \"always\", or checks that there is no blank line when mode is set\n         * to \"never\"\n         * @private\n         * @param {ASTNode} node - `VariableDeclaration` node to test\n         * @returns {void}\n         */\n        function checkForBlankLine(node) {\n\n            /*\n             * lastToken is the last token on the node's line. It will usually also be the last token of the node, but it will\n             * sometimes be second-last if there is a semicolon on a different line.\n             */\n            const lastToken = getLastToken(node),\n\n                /*\n                 * If lastToken is the last token of the node, nextToken should be the token after the node. Otherwise, nextToken\n                 * is the last token of the node.\n                 */\n                nextToken = lastToken === sourceCode.getLastToken(node) ? sourceCode.getTokenAfter(node) : sourceCode.getLastToken(node),\n                nextLineNum = lastToken.loc.end.line + 1;\n\n            // Ignore if there is no following statement\n            if (!nextToken) {\n                return;\n            }\n\n            // Ignore if parent of node is a for variant\n            if (isForTypeSpecifier(node.parent.type)) {\n                return;\n            }\n\n            // Ignore if parent of node is an export specifier\n            if (isExportSpecifier(node.parent.type)) {\n                return;\n            }\n\n            // Some coding styles use multiple `var` statements, so do nothing if\n            // the next token is a `var` statement.\n            if (nextToken.type === \"Keyword\" && isVar(nextToken.value)) {\n                return;\n            }\n\n            // Ignore if it is last statement in a block\n            if (isLastNode(node)) {\n                return;\n            }\n\n            // Next statement is not a `var`...\n            const noNextLineToken = nextToken.loc.start.line > nextLineNum;\n            const hasNextLineComment = (typeof commentEndLine[nextLineNum] !== \"undefined\");\n\n            if (mode === \"never\" && noNextLineToken && !hasNextLineComment) {\n                context.report({\n                    node,\n                    message: NEVER_MESSAGE,\n                    data: { identifier: node.name },\n                    fix(fixer) {\n                        const linesBetween = sourceCode.getText().slice(lastToken.range[1], nextToken.range[0]).split(astUtils.LINEBREAK_MATCHER);\n\n                        return fixer.replaceTextRange([lastToken.range[1], nextToken.range[0]], `${linesBetween.slice(0, -1).join(\"\")}\\n${linesBetween[linesBetween.length - 1]}`);\n                    }\n                });\n            }\n\n            // Token on the next line, or comment without blank line\n            if (\n                mode === \"always\" && (\n                    !noNextLineToken ||\n                    hasNextLineComment && !hasBlankLineAfterComment(nextToken, nextLineNum)\n                )\n            ) {\n                context.report({\n                    node,\n                    message: ALWAYS_MESSAGE,\n                    data: { identifier: node.name },\n                    fix(fixer) {\n                        if ((noNextLineToken ? getLastCommentLineOfBlock(nextLineNum) : lastToken.loc.end.line) === nextToken.loc.start.line) {\n                            return fixer.insertTextBefore(nextToken, \"\\n\\n\");\n                        }\n\n                        return fixer.insertTextBeforeRange([nextToken.range[0] - nextToken.loc.start.column, nextToken.range[1]], \"\\n\");\n                    }\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclaration: checkForBlankLine\n        };\n\n    }\n};\n","newline-before-return.js":"/**\n * @fileoverview Rule to require newlines before `return` statement\n * @author Kai Cataldo\n * @deprecated\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require an empty line before `return` statements\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            replacedBy: [\"padding-line-between-statements\"]\n        },\n        fixable: \"whitespace\",\n        schema: [],\n        deprecated: true\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Tests whether node is preceded by supplied tokens\n         * @param {ASTNode} node - node to check\n         * @param {array} testTokens - array of tokens to test against\n         * @returns {boolean} Whether or not the node is preceded by one of the supplied tokens\n         * @private\n         */\n        function isPrecededByTokens(node, testTokens) {\n            const tokenBefore = sourceCode.getTokenBefore(node);\n\n            return testTokens.some(token => tokenBefore.value === token);\n        }\n\n        /**\n         * Checks whether node is the first node after statement or in block\n         * @param {ASTNode} node - node to check\n         * @returns {boolean} Whether or not the node is the first node after statement or in block\n         * @private\n         */\n        function isFirstNode(node) {\n            const parentType = node.parent.type;\n\n            if (node.parent.body) {\n                return Array.isArray(node.parent.body)\n                    ? node.parent.body[0] === node\n                    : node.parent.body === node;\n            }\n\n            if (parentType === \"IfStatement\") {\n                return isPrecededByTokens(node, [\"else\", \")\"]);\n            } else if (parentType === \"DoWhileStatement\") {\n                return isPrecededByTokens(node, [\"do\"]);\n            } else if (parentType === \"SwitchCase\") {\n                return isPrecededByTokens(node, [\":\"]);\n            }\n            return isPrecededByTokens(node, [\")\"]);\n\n        }\n\n        /**\n         * Returns the number of lines of comments that precede the node\n         * @param {ASTNode} node - node to check for overlapping comments\n         * @param {number} lineNumTokenBefore - line number of previous token, to check for overlapping comments\n         * @returns {number} Number of lines of comments that precede the node\n         * @private\n         */\n        function calcCommentLines(node, lineNumTokenBefore) {\n            const comments = sourceCode.getCommentsBefore(node);\n            let numLinesComments = 0;\n\n            if (!comments.length) {\n                return numLinesComments;\n            }\n\n            comments.forEach(comment => {\n                numLinesComments++;\n\n                if (comment.type === \"Block\") {\n                    numLinesComments += comment.loc.end.line - comment.loc.start.line;\n                }\n\n                // avoid counting lines with inline comments twice\n                if (comment.loc.start.line === lineNumTokenBefore) {\n                    numLinesComments--;\n                }\n\n                if (comment.loc.end.line === node.loc.start.line) {\n                    numLinesComments--;\n                }\n            });\n\n            return numLinesComments;\n        }\n\n        /**\n         * Returns the line number of the token before the node that is passed in as an argument\n         * @param {ASTNode} node - The node to use as the start of the calculation\n         * @returns {number} Line number of the token before `node`\n         * @private\n         */\n        function getLineNumberOfTokenBefore(node) {\n            const tokenBefore = sourceCode.getTokenBefore(node);\n            let lineNumTokenBefore;\n\n            /**\n             * Global return (at the beginning of a script) is a special case.\n             * If there is no token before `return`, then we expect no line\n             * break before the return. Comments are allowed to occupy lines\n             * before the global return, just no blank lines.\n             * Setting lineNumTokenBefore to zero in that case results in the\n             * desired behavior.\n             */\n            if (tokenBefore) {\n                lineNumTokenBefore = tokenBefore.loc.end.line;\n            } else {\n                lineNumTokenBefore = 0; // global return at beginning of script\n            }\n\n            return lineNumTokenBefore;\n        }\n\n        /**\n         * Checks whether node is preceded by a newline\n         * @param {ASTNode} node - node to check\n         * @returns {boolean} Whether or not the node is preceded by a newline\n         * @private\n         */\n        function hasNewlineBefore(node) {\n            const lineNumNode = node.loc.start.line;\n            const lineNumTokenBefore = getLineNumberOfTokenBefore(node);\n            const commentLines = calcCommentLines(node, lineNumTokenBefore);\n\n            return (lineNumNode - lineNumTokenBefore - commentLines) > 1;\n        }\n\n        /**\n         * Checks whether it is safe to apply a fix to a given return statement.\n         *\n         * The fix is not considered safe if the given return statement has leading comments,\n         * as we cannot safely determine if the newline should be added before or after the comments.\n         * For more information, see: https://github.com/eslint/eslint/issues/5958#issuecomment-222767211\n         *\n         * @param {ASTNode} node - The return statement node to check.\n         * @returns {boolean} `true` if it can fix the node.\n         * @private\n         */\n        function canFix(node) {\n            const leadingComments = sourceCode.getCommentsBefore(node);\n            const lastLeadingComment = leadingComments[leadingComments.length - 1];\n            const tokenBefore = sourceCode.getTokenBefore(node);\n\n            if (leadingComments.length === 0) {\n                return true;\n            }\n\n            // if the last leading comment ends in the same line as the previous token and\n            // does not share a line with the `return` node, we can consider it safe to fix.\n            // Example:\n            // function a() {\n            //     var b; //comment\n            //     return;\n            // }\n            if (lastLeadingComment.loc.end.line === tokenBefore.loc.end.line &&\n                lastLeadingComment.loc.end.line !== node.loc.start.line) {\n                return true;\n            }\n\n            return false;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ReturnStatement(node) {\n                if (!isFirstNode(node) && !hasNewlineBefore(node)) {\n                    context.report({\n                        node,\n                        message: \"Expected newline before return statement.\",\n                        fix(fixer) {\n                            if (canFix(node)) {\n                                const tokenBefore = sourceCode.getTokenBefore(node);\n                                const newlines = node.loc.start.line === tokenBefore.loc.end.line ? \"\\n\\n\" : \"\\n\";\n\n                                return fixer.insertTextBefore(node, newlines);\n                            }\n                            return null;\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","newline-per-chained-call.js":"/**\n * @fileoverview Rule to ensure newline per method call when chaining calls\n * @author Rajendra Patil\n * @author Burak Yigit Kaya\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require a newline after each call in a method chain\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        fixable: \"whitespace\",\n        schema: [{\n            type: \"object\",\n            properties: {\n                ignoreChainWithDepth: {\n                    type: \"integer\",\n                    minimum: 1,\n                    maximum: 10\n                }\n            },\n            additionalProperties: false\n        }]\n    },\n\n    create(context) {\n\n        const options = context.options[0] || {},\n            ignoreChainWithDepth = options.ignoreChainWithDepth || 2;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Get the prefix of a given MemberExpression node.\n         * If the MemberExpression node is a computed value it returns a\n         * left bracket. If not it returns a period.\n         *\n         * @param  {ASTNode} node - A MemberExpression node to get\n         * @returns {string} The prefix of the node.\n         */\n        function getPrefix(node) {\n            return node.computed ? \"[\" : \".\";\n        }\n\n        /**\n         * Gets the property text of a given MemberExpression node.\n         * If the text is multiline, this returns only the first line.\n         *\n         * @param {ASTNode} node - A MemberExpression node to get.\n         * @returns {string} The property text of the node.\n         */\n        function getPropertyText(node) {\n            const prefix = getPrefix(node);\n            const lines = sourceCode.getText(node.property).split(astUtils.LINEBREAK_MATCHER);\n            const suffix = node.computed && lines.length === 1 ? \"]\" : \"\";\n\n            return prefix + lines[0] + suffix;\n        }\n\n        return {\n            \"CallExpression:exit\"(node) {\n                if (!node.callee || node.callee.type !== \"MemberExpression\") {\n                    return;\n                }\n\n                const callee = node.callee;\n                let parent = callee.object;\n                let depth = 1;\n\n                while (parent && parent.callee) {\n                    depth += 1;\n                    parent = parent.callee.object;\n                }\n\n                if (depth > ignoreChainWithDepth && astUtils.isTokenOnSameLine(callee.object, callee.property)) {\n                    context.report({\n                        node: callee.property,\n                        loc: callee.property.loc.start,\n                        message: \"Expected line break before `{{callee}}`.\",\n                        data: {\n                            callee: getPropertyText(callee)\n                        },\n                        fix(fixer) {\n                            const firstTokenAfterObject = sourceCode.getTokenAfter(callee.object, astUtils.isNotClosingParenToken);\n\n                            return fixer.insertTextBefore(firstTokenAfterObject, \"\\n\");\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","no-alert.js":"/**\n * @fileoverview Rule to flag use of alert, confirm, prompt\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst getPropertyName = require(\"../ast-utils\").getStaticPropertyName;\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks if the given name is a prohibited identifier.\n * @param {string} name The name to check\n * @returns {boolean} Whether or not the name is prohibited.\n */\nfunction isProhibitedIdentifier(name) {\n    return /^(alert|confirm|prompt)$/.test(name);\n}\n\n/**\n * Reports the given node and identifier name.\n * @param {RuleContext} context The ESLint rule context.\n * @param {ASTNode} node The node to report on.\n * @param {string} identifierName The name of the identifier.\n * @returns {void}\n */\nfunction report(context, node, identifierName) {\n    context.report(node, \"Unexpected {{name}}.\", { name: identifierName });\n}\n\n/**\n * Finds the eslint-scope reference in the given scope.\n * @param {Object} scope The scope to search.\n * @param {ASTNode} node The identifier node.\n * @returns {Reference|null} Returns the found reference or null if none were found.\n */\nfunction findReference(scope, node) {\n    const references = scope.references.filter(reference => reference.identifier.range[0] === node.range[0] &&\n            reference.identifier.range[1] === node.range[1]);\n\n    if (references.length === 1) {\n        return references[0];\n    }\n    return null;\n}\n\n/**\n * Checks if the given identifier node is shadowed in the given scope.\n * @param {Object} scope The current scope.\n * @param {string} node The identifier node to check\n * @returns {boolean} Whether or not the name is shadowed.\n */\nfunction isShadowed(scope, node) {\n    const reference = findReference(scope, node);\n\n    return reference && reference.resolved && reference.resolved.defs.length > 0;\n}\n\n/**\n * Checks if the given identifier node is a ThisExpression in the global scope or the global window property.\n * @param {Object} scope The current scope.\n * @param {string} node The identifier node to check\n * @returns {boolean} Whether or not the node is a reference to the global object.\n */\nfunction isGlobalThisReferenceOrGlobalWindow(scope, node) {\n    if (scope.type === \"global\" && node.type === \"ThisExpression\") {\n        return true;\n    } else if (node.name === \"window\") {\n        return !isShadowed(scope, node);\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of `alert`, `confirm`, and `prompt`\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        return {\n            CallExpression(node) {\n                const callee = node.callee,\n                    currentScope = context.getScope();\n\n                // without window.\n                if (callee.type === \"Identifier\") {\n                    const identifierName = callee.name;\n\n                    if (!isShadowed(currentScope, callee) && isProhibitedIdentifier(callee.name)) {\n                        report(context, node, identifierName);\n                    }\n\n                } else if (callee.type === \"MemberExpression\" && isGlobalThisReferenceOrGlobalWindow(currentScope, callee.object)) {\n                    const identifierName = getPropertyName(callee);\n\n                    if (isProhibitedIdentifier(identifierName)) {\n                        report(context, node, identifierName);\n                    }\n                }\n\n            }\n        };\n\n    }\n};\n","no-array-constructor.js":"/**\n * @fileoverview Disallow construction of dense arrays using the Array constructor\n * @author Matt DuVall <http://www.mattduvall.com/>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `Array` constructors\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Disallow construction of dense arrays using the Array constructor\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function check(node) {\n            if (\n                node.arguments.length !== 1 &&\n                node.callee.type === \"Identifier\" &&\n                node.callee.name === \"Array\"\n            ) {\n                context.report({ node, message: \"The array literal notation [] is preferrable.\" });\n            }\n        }\n\n        return {\n            CallExpression: check,\n            NewExpression: check\n        };\n\n    }\n};\n","no-await-in-loop.js":"/**\n * @fileoverview Rule to disallow uses of await inside of loops.\n * @author Nat Mote (nmote)\n */\n\"use strict\";\n\n// Node types which are considered loops.\nconst loopTypes = new Set([\n    \"ForStatement\",\n    \"ForOfStatement\",\n    \"ForInStatement\",\n    \"WhileStatement\",\n    \"DoWhileStatement\"\n]);\n\n// Node types at which we should stop looking for loops. For example, it is fine to declare an async\n// function within a loop, and use await inside of that.\nconst boundaryTypes = new Set([\n    \"FunctionDeclaration\",\n    \"FunctionExpression\",\n    \"ArrowFunctionExpression\"\n]);\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `await` inside of loops\",\n            category: \"Possible Errors\",\n            recommended: false\n        },\n        schema: []\n    },\n    create(context) {\n        return {\n            AwaitExpression(node) {\n                const ancestors = context.getAncestors();\n\n                // Reverse so that we can traverse from the deepest node upwards.\n                ancestors.reverse();\n\n                // Create a set of all the ancestors plus this node so that we can check\n                // if this use of await appears in the body of the loop as opposed to\n                // the right-hand side of a for...of, for example.\n                const ancestorSet = new Set(ancestors).add(node);\n\n                for (let i = 0; i < ancestors.length; i++) {\n                    const ancestor = ancestors[i];\n\n                    if (boundaryTypes.has(ancestor.type)) {\n\n                        // Short-circuit out if we encounter a boundary type. Loops above\n                        // this do not matter.\n                        return;\n                    }\n                    if (loopTypes.has(ancestor.type)) {\n\n                        // Only report if we are actually in the body or another part that gets executed on\n                        // every iteration.\n                        if (\n                            ancestorSet.has(ancestor.body) ||\n                            ancestorSet.has(ancestor.test) ||\n                            ancestorSet.has(ancestor.update)\n                        ) {\n                            context.report({\n                                node,\n                                message: \"Unexpected `await` inside a loop.\"\n                            });\n                            return;\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n","no-bitwise.js":"/**\n * @fileoverview Rule to flag bitwise identifiers\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//\n// Set of bitwise operators.\n//\nconst BITWISE_OPERATORS = [\n    \"^\", \"|\", \"&\", \"<<\", \">>\", \">>>\",\n    \"^=\", \"|=\", \"&=\", \"<<=\", \">>=\", \">>>=\",\n    \"~\"\n];\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow bitwise operators\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allow: {\n                        type: \"array\",\n                        items: {\n                            enum: BITWISE_OPERATORS\n                        },\n                        uniqueItems: true\n                    },\n                    int32Hint: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const allowed = options.allow || [];\n        const int32Hint = options.int32Hint === true;\n\n        /**\n         * Reports an unexpected use of a bitwise operator.\n         * @param   {ASTNode} node Node which contains the bitwise operator.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({ node, message: \"Unexpected use of '{{operator}}'.\", data: { operator: node.operator } });\n        }\n\n        /**\n         * Checks if the given node has a bitwise operator.\n         * @param   {ASTNode} node The node to check.\n         * @returns {boolean} Whether or not the node has a bitwise operator.\n         */\n        function hasBitwiseOperator(node) {\n            return BITWISE_OPERATORS.indexOf(node.operator) !== -1;\n        }\n\n        /**\n         * Checks if exceptions were provided, e.g. `{ allow: ['~', '|'] }`.\n         * @param   {ASTNode} node The node to check.\n         * @returns {boolean} Whether or not the node has a bitwise operator.\n         */\n        function allowedOperator(node) {\n            return allowed.indexOf(node.operator) !== -1;\n        }\n\n        /**\n         * Checks if the given bitwise operator is used for integer typecasting, i.e. \"|0\"\n         * @param   {ASTNode} node The node to check.\n         * @returns {boolean} whether the node is used in integer typecasting.\n         */\n        function isInt32Hint(node) {\n            return int32Hint && node.operator === \"|\" && node.right &&\n              node.right.type === \"Literal\" && node.right.value === 0;\n        }\n\n        /**\n         * Report if the given node contains a bitwise operator.\n         * @param   {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkNodeForBitwiseOperator(node) {\n            if (hasBitwiseOperator(node) && !allowedOperator(node) && !isInt32Hint(node)) {\n                report(node);\n            }\n        }\n\n        return {\n            AssignmentExpression: checkNodeForBitwiseOperator,\n            BinaryExpression: checkNodeForBitwiseOperator,\n            UnaryExpression: checkNodeForBitwiseOperator\n        };\n\n    }\n};\n","no-buffer-constructor.js":"/**\n * @fileoverview disallow use of the Buffer() constructor\n * @author Teddy Katz\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow use of the Buffer() constructor\",\n            category: \"Node.js and CommonJS\",\n            recommended: false\n        },\n        schema: []\n    },\n\n    create(context) {\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            \"CallExpression[callee.name='Buffer'], NewExpression[callee.name='Buffer']\"(node) {\n                context.report({\n                    node,\n                    message: \"{{example}} is deprecated. Use Buffer.from(), Buffer.alloc(), or Buffer.allocUnsafe() instead.\",\n                    data: { example: node.type === \"CallExpression\" ? \"Buffer()\" : \"new Buffer()\" }\n                });\n            }\n        };\n    }\n};\n","no-caller.js":"/**\n * @fileoverview Rule to flag use of arguments.callee and arguments.caller.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of `arguments.caller` or `arguments.callee`\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            MemberExpression(node) {\n                const objectName = node.object.name,\n                    propertyName = node.property.name;\n\n                if (objectName === \"arguments\" && !node.computed && propertyName && propertyName.match(/^calle[er]$/)) {\n                    context.report({ node, message: \"Avoid arguments.{{property}}.\", data: { property: propertyName } });\n                }\n\n            }\n        };\n\n    }\n};\n","no-case-declarations.js":"/**\n * @fileoverview Rule to flag use of an lexical declarations inside a case clause\n * @author Erik Arvidsson\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow lexical declarations in case clauses\",\n            category: \"Best Practices\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Checks whether or not a node is a lexical declaration.\n         * @param {ASTNode} node A direct child statement of a switch case.\n         * @returns {boolean} Whether or not the node is a lexical declaration.\n         */\n        function isLexicalDeclaration(node) {\n            switch (node.type) {\n                case \"FunctionDeclaration\":\n                case \"ClassDeclaration\":\n                    return true;\n                case \"VariableDeclaration\":\n                    return node.kind !== \"var\";\n                default:\n                    return false;\n            }\n        }\n\n        return {\n            SwitchCase(node) {\n                for (let i = 0; i < node.consequent.length; i++) {\n                    const statement = node.consequent[i];\n\n                    if (isLexicalDeclaration(statement)) {\n                        context.report({\n                            node,\n                            message: \"Unexpected lexical declaration in case block.\"\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","no-catch-shadow.js":"/**\n * @fileoverview Rule to flag variable leak in CatchClauses in IE 8 and earlier\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `catch` clause parameters from shadowing variables in the outer scope\",\n            category: \"Variables\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Check if the parameters are been shadowed\n         * @param {Object} scope current scope\n         * @param {string} name parameter name\n         * @returns {boolean} True is its been shadowed\n         */\n        function paramIsShadowing(scope, name) {\n            return astUtils.getVariableByName(scope, name) !== null;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n\n            CatchClause(node) {\n                let scope = context.getScope();\n\n                // When blockBindings is enabled, CatchClause creates its own scope\n                // so start from one upper scope to exclude the current node\n                if (scope.block === node) {\n                    scope = scope.upper;\n                }\n\n                if (paramIsShadowing(scope, node.param.name)) {\n                    context.report({ node, message: \"Value of '{{name}}' may be overwritten in IE 8 and earlier.\", data: { name: node.param.name } });\n                }\n            }\n        };\n\n    }\n};\n","no-class-assign.js":"/**\n * @fileoverview A rule to disallow modifying variables of class declarations\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow reassigning class members\",\n            category: \"ECMAScript 6\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {Variable} variable - A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            astUtils.getModifyingReferences(variable.references).forEach(reference => {\n                context.report({ node: reference.identifier, message: \"'{{name}}' is a class.\", data: { name: reference.identifier.name } });\n\n            });\n        }\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {ASTNode} node - A ClassDeclaration/ClassExpression node to check.\n         * @returns {void}\n         */\n        function checkForClass(node) {\n            context.getDeclaredVariables(node).forEach(checkVariable);\n        }\n\n        return {\n            ClassDeclaration: checkForClass,\n            ClassExpression: checkForClass\n        };\n\n    }\n};\n","no-compare-neg-zero.js":"/**\n * @fileoverview The rule should warn against code that tries to compare against -0.\n * @author Aladdin-ADD <hh_2013@foxmail.com>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow comparing against -0\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n        fixable: null,\n        schema: []\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Checks a given node is -0\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {boolean} `true` if the node is -0.\n         */\n        function isNegZero(node) {\n            return node.type === \"UnaryExpression\" && node.operator === \"-\" && node.argument.type === \"Literal\" && node.argument.value === 0;\n        }\n        const OPERATORS_TO_CHECK = new Set([\">\", \">=\", \"<\", \"<=\", \"==\", \"===\", \"!=\", \"!==\"]);\n\n        return {\n            BinaryExpression(node) {\n                if (OPERATORS_TO_CHECK.has(node.operator)) {\n                    if (isNegZero(node.left) || isNegZero(node.right)) {\n                        context.report({\n                            node,\n                            message: \"Do not use the '{{operator}}' operator to compare against -0.\",\n                            data: { operator: node.operator }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n","no-cond-assign.js":"/**\n * @fileoverview Rule to flag assignment in a conditional statement's test expression\n * @author Stephen Murray <spmurrayzzz>\n */\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\nconst NODE_DESCRIPTIONS = {\n    DoWhileStatement: \"a 'do...while' statement\",\n    ForStatement: \"a 'for' statement\",\n    IfStatement: \"an 'if' statement\",\n    WhileStatement: \"a 'while' statement\"\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow assignment operators in conditional expressions\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                enum: [\"except-parens\", \"always\"]\n            }\n        ]\n    },\n\n    create(context) {\n\n        const prohibitAssign = (context.options[0] || \"except-parens\");\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Check whether an AST node is the test expression for a conditional statement.\n         * @param {!Object} node The node to test.\n         * @returns {boolean} `true` if the node is the text expression for a conditional statement; otherwise, `false`.\n         */\n        function isConditionalTestExpression(node) {\n            return node.parent &&\n                node.parent.test &&\n                node === node.parent.test;\n        }\n\n        /**\n         * Given an AST node, perform a bottom-up search for the first ancestor that represents a conditional statement.\n         * @param {!Object} node The node to use at the start of the search.\n         * @returns {?Object} The closest ancestor node that represents a conditional statement.\n         */\n        function findConditionalAncestor(node) {\n            let currentAncestor = node;\n\n            do {\n                if (isConditionalTestExpression(currentAncestor)) {\n                    return currentAncestor.parent;\n                }\n            } while ((currentAncestor = currentAncestor.parent) && !astUtils.isFunction(currentAncestor));\n\n            return null;\n        }\n\n        /**\n         * Check whether the code represented by an AST node is enclosed in two sets of parentheses.\n         * @param {!Object} node The node to test.\n         * @returns {boolean} `true` if the code is enclosed in two sets of parentheses; otherwise, `false`.\n         */\n        function isParenthesisedTwice(node) {\n            const previousToken = sourceCode.getTokenBefore(node, 1),\n                nextToken = sourceCode.getTokenAfter(node, 1);\n\n            return astUtils.isParenthesised(sourceCode, node) &&\n                astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] &&\n                astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];\n        }\n\n        /**\n         * Check a conditional statement's test expression for top-level assignments that are not enclosed in parentheses.\n         * @param {!Object} node The node for the conditional statement.\n         * @returns {void}\n         */\n        function testForAssign(node) {\n            if (node.test &&\n                (node.test.type === \"AssignmentExpression\") &&\n                (node.type === \"ForStatement\"\n                    ? !astUtils.isParenthesised(sourceCode, node.test)\n                    : !isParenthesisedTwice(node.test)\n                )\n            ) {\n\n                // must match JSHint's error message\n                context.report({\n                    node,\n                    loc: node.test.loc.start,\n                    message: \"Expected a conditional expression and instead saw an assignment.\"\n                });\n            }\n        }\n\n        /**\n         * Check whether an assignment expression is descended from a conditional statement's test expression.\n         * @param {!Object} node The node for the assignment expression.\n         * @returns {void}\n         */\n        function testForConditionalAncestor(node) {\n            const ancestor = findConditionalAncestor(node);\n\n            if (ancestor) {\n                context.report({\n                    node: ancestor,\n                    message: \"Unexpected assignment within {{type}}.\",\n                    data: {\n                        type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type\n                    }\n                });\n            }\n        }\n\n        if (prohibitAssign === \"always\") {\n            return {\n                AssignmentExpression: testForConditionalAncestor\n            };\n        }\n\n        return {\n            DoWhileStatement: testForAssign,\n            ForStatement: testForAssign,\n            IfStatement: testForAssign,\n            WhileStatement: testForAssign\n        };\n\n    }\n};\n","no-confusing-arrow.js":"/**\n * @fileoverview A rule to warn against using arrow functions when they could be\n * confused with comparisions\n * @author Jxck <https://github.com/Jxck>\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils.js\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a node is a conditional expression.\n * @param {ASTNode} node - node to test\n * @returns {boolean} `true` if the node is a conditional expression.\n */\nfunction isConditional(node) {\n    return node && node.type === \"ConditionalExpression\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow arrow functions where they could be confused with comparisons\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        fixable: \"code\",\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                allowParens: { type: \"boolean\" }\n            },\n            additionalProperties: false\n        }]\n    },\n\n    create(context) {\n        const config = context.options[0] || {};\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports if an arrow function contains an ambiguous conditional.\n         * @param {ASTNode} node - A node to check and report.\n         * @returns {void}\n         */\n        function checkArrowFunc(node) {\n            const body = node.body;\n\n            if (isConditional(body) && !(config.allowParens && astUtils.isParenthesised(sourceCode, body))) {\n                context.report({\n                    node,\n                    message: \"Arrow function used ambiguously with a conditional expression.\",\n                    fix(fixer) {\n\n                        // if `allowParens` is not set to true dont bother wrapping in parens\n                        return config.allowParens && fixer.replaceText(node.body, `(${sourceCode.getText(node.body)})`);\n                    }\n                });\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: checkArrowFunc\n        };\n    }\n};\n","no-console.js":"/**\n * @fileoverview Rule to flag use of console object\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of `console`\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allow: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        },\n                        minItems: 1,\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const allowed = options.allow || [];\n\n        /**\n         * Checks whether the given reference is 'console' or not.\n         *\n         * @param {eslint-scope.Reference} reference - The reference to check.\n         * @returns {boolean} `true` if the reference is 'console'.\n         */\n        function isConsole(reference) {\n            const id = reference.identifier;\n\n            return id && id.name === \"console\";\n        }\n\n        /**\n         * Checks whether the property name of the given MemberExpression node\n         * is allowed by options or not.\n         *\n         * @param {ASTNode} node - The MemberExpression node to check.\n         * @returns {boolean} `true` if the property name of the node is allowed.\n         */\n        function isAllowed(node) {\n            const propertyName = astUtils.getStaticPropertyName(node);\n\n            return propertyName && allowed.indexOf(propertyName) !== -1;\n        }\n\n        /**\n         * Checks whether the given reference is a member access which is not\n         * allowed by options or not.\n         *\n         * @param {eslint-scope.Reference} reference - The reference to check.\n         * @returns {boolean} `true` if the reference is a member access which\n         *      is not allowed by options.\n         */\n        function isMemberAccessExceptAllowed(reference) {\n            const node = reference.identifier;\n            const parent = node.parent;\n\n            return (\n                parent.type === \"MemberExpression\" &&\n                parent.object === node &&\n                !isAllowed(parent)\n            );\n        }\n\n        /**\n         * Reports the given reference as a violation.\n         *\n         * @param {eslint-scope.Reference} reference - The reference to report.\n         * @returns {void}\n         */\n        function report(reference) {\n            const node = reference.identifier.parent;\n\n            context.report({\n                node,\n                loc: node.loc,\n                message: \"Unexpected console statement.\"\n            });\n        }\n\n        return {\n            \"Program:exit\"() {\n                const scope = context.getScope();\n                const consoleVar = astUtils.getVariableByName(scope, \"console\");\n                const shadowed = consoleVar && consoleVar.defs.length > 0;\n\n                /* 'scope.through' includes all references to undefined\n                 * variables. If the variable 'console' is not defined, it uses\n                 * 'scope.through'.\n                 */\n                const references = consoleVar\n                    ? consoleVar.references\n                    : scope.through.filter(isConsole);\n\n                if (!shadowed) {\n                    references\n                        .filter(isMemberAccessExceptAllowed)\n                        .forEach(report);\n                }\n            }\n        };\n    }\n};\n","no-const-assign.js":"/**\n * @fileoverview A rule to disallow modifying variables that are declared using `const`\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow reassigning `const` variables\",\n            category: \"ECMAScript 6\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {Variable} variable - A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            astUtils.getModifyingReferences(variable.references).forEach(reference => {\n                context.report({ node: reference.identifier, message: \"'{{name}}' is constant.\", data: { name: reference.identifier.name } });\n            });\n        }\n\n        return {\n            VariableDeclaration(node) {\n                if (node.kind === \"const\") {\n                    context.getDeclaredVariables(node).forEach(checkVariable);\n                }\n            }\n        };\n\n    }\n};\n","no-constant-condition.js":"/**\n * @fileoverview Rule to flag use constant conditions\n * @author Christian Schulz <http://rndm.de>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow constant expressions in conditions\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    checkLoops: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n\n        ]\n    },\n\n    create(context) {\n        const options = context.options[0] || {},\n            checkLoops = options.checkLoops !== false,\n            loopSetStack = [];\n\n        let loopsInCurrentScope = new Set();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n\n        /**\n         * Checks if a branch node of LogicalExpression short circuits the whole condition\n         * @param {ASTNode} node The branch of main condition which needs to be checked\n         * @param {string} operator The operator of the main LogicalExpression.\n         * @returns {boolean} true when condition short circuits whole condition\n         */\n        function isLogicalIdentity(node, operator) {\n            switch (node.type) {\n                case \"Literal\":\n                    return (operator === \"||\" && node.value === true) ||\n                           (operator === \"&&\" && node.value === false);\n\n                case \"UnaryExpression\":\n                    return (operator === \"&&\" && node.operator === \"void\");\n\n                case \"LogicalExpression\":\n                    return isLogicalIdentity(node.left, node.operator) ||\n                             isLogicalIdentity(node.right, node.operator);\n\n                // no default\n            }\n            return false;\n        }\n\n        /**\n         * Checks if a node has a constant truthiness value.\n         * @param {ASTNode} node The AST node to check.\n         * @param {boolean} inBooleanPosition `false` if checking branch of a condition.\n         *  `true` in all other cases\n         * @returns {Bool} true when node's truthiness is constant\n         * @private\n         */\n        function isConstant(node, inBooleanPosition) {\n            switch (node.type) {\n                case \"Literal\":\n                case \"ArrowFunctionExpression\":\n                case \"FunctionExpression\":\n                case \"ObjectExpression\":\n                case \"ArrayExpression\":\n                    return true;\n\n                case \"UnaryExpression\":\n                    if (node.operator === \"void\") {\n                        return true;\n                    }\n\n                    return (node.operator === \"typeof\" && inBooleanPosition) ||\n                        isConstant(node.argument, true);\n\n                case \"BinaryExpression\":\n                    return isConstant(node.left, false) &&\n                            isConstant(node.right, false) &&\n                            node.operator !== \"in\";\n\n                case \"LogicalExpression\": {\n                    const isLeftConstant = isConstant(node.left, inBooleanPosition);\n                    const isRightConstant = isConstant(node.right, inBooleanPosition);\n                    const isLeftShortCircuit = (isLeftConstant && isLogicalIdentity(node.left, node.operator));\n                    const isRightShortCircuit = (isRightConstant && isLogicalIdentity(node.right, node.operator));\n\n                    return (isLeftConstant && isRightConstant) || isLeftShortCircuit || isRightShortCircuit;\n                }\n\n                case \"AssignmentExpression\":\n                    return (node.operator === \"=\") && isConstant(node.right, inBooleanPosition);\n\n                case \"SequenceExpression\":\n                    return isConstant(node.expressions[node.expressions.length - 1], inBooleanPosition);\n\n                // no default\n            }\n            return false;\n        }\n\n        /**\n         * Tracks when the given node contains a constant condition.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function trackConstantConditionLoop(node) {\n            if (node.test && isConstant(node.test, true)) {\n                loopsInCurrentScope.add(node);\n            }\n        }\n\n        /**\n         * Reports when the set contains the given constant condition node\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkConstantConditionLoopInSet(node) {\n            if (loopsInCurrentScope.has(node)) {\n                loopsInCurrentScope.delete(node);\n                context.report({ node, message: \"Unexpected constant condition.\" });\n            }\n        }\n\n        /**\n         * Reports when the given node contains a constant condition.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function reportIfConstant(node) {\n            if (node.test && isConstant(node.test, true)) {\n                context.report({ node, message: \"Unexpected constant condition.\" });\n            }\n        }\n\n        /**\n         * Stores current set of constant loops in loopSetStack temporarily\n         * and uses a new set to track constant loops\n         * @returns {void}\n         * @private\n         */\n        function enterFunction() {\n            loopSetStack.push(loopsInCurrentScope);\n            loopsInCurrentScope = new Set();\n        }\n\n        /**\n         * Reports when the set still contains stored constant conditions\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function exitFunction() {\n            loopsInCurrentScope = loopSetStack.pop();\n        }\n\n        /**\n         * Checks node when checkLoops option is enabled\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkLoop(node) {\n            if (checkLoops) {\n                trackConstantConditionLoop(node);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ConditionalExpression: reportIfConstant,\n            IfStatement: reportIfConstant,\n            WhileStatement: checkLoop,\n            \"WhileStatement:exit\": checkConstantConditionLoopInSet,\n            DoWhileStatement: checkLoop,\n            \"DoWhileStatement:exit\": checkConstantConditionLoopInSet,\n            ForStatement: checkLoop,\n            \"ForStatement > .test\": node => checkLoop(node.parent),\n            \"ForStatement:exit\": checkConstantConditionLoopInSet,\n            FunctionDeclaration: enterFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            YieldExpression: () => loopsInCurrentScope.clear()\n        };\n\n    }\n};\n","no-continue.js":"/**\n * @fileoverview Rule to flag use of continue statement\n * @author Borislav Zhivkov\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `continue` statements\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n            ContinueStatement(node) {\n                context.report({ node, message: \"Unexpected use of continue statement.\" });\n            }\n        };\n\n    }\n};\n","no-control-regex.js":"/**\n * @fileoverview Rule to forbid control charactes from regular expressions.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow control characters in regular expressions\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Get the regex expression\n         * @param {ASTNode} node node to evaluate\n         * @returns {*} Regex if found else null\n         * @private\n         */\n        function getRegExp(node) {\n            if (node.value instanceof RegExp) {\n                return node.value;\n            } else if (typeof node.value === \"string\") {\n\n                const parent = context.getAncestors().pop();\n\n                if ((parent.type === \"NewExpression\" || parent.type === \"CallExpression\") &&\n                    parent.callee.type === \"Identifier\" && parent.callee.name === \"RegExp\"\n                ) {\n\n                    // there could be an invalid regular expression string\n                    try {\n                        return new RegExp(node.value);\n                    } catch (ex) {\n                        return null;\n                    }\n                }\n            }\n\n            return null;\n        }\n\n\n        const controlChar = /[\\x00-\\x1f]/g; // eslint-disable-line no-control-regex\n        const consecutiveSlashes = /\\\\+/g;\n        const consecutiveSlashesAtEnd = /\\\\+$/g;\n        const stringControlChar = /\\\\x[01][0-9a-f]/ig;\n        const stringControlCharWithoutSlash = /x[01][0-9a-f]/ig;\n\n        /**\n         * Return a list of the control characters in the given regex string\n         * @param {string} regexStr regex as string to check\n         * @returns {array} returns a list of found control characters on given string\n         * @private\n         */\n        function getControlCharacters(regexStr) {\n\n            // check control characters, if RegExp object used\n            const controlChars = regexStr.match(controlChar) || [];\n\n            let stringControlChars = [];\n\n            // check substr, if regex literal used\n            const subStrIndex = regexStr.search(stringControlChar);\n\n            if (subStrIndex > -1) {\n\n                // is it escaped, check backslash count\n                const possibleEscapeCharacters = regexStr.slice(0, subStrIndex).match(consecutiveSlashesAtEnd);\n\n                const hasControlChars = possibleEscapeCharacters === null || !(possibleEscapeCharacters[0].length % 2);\n\n                if (hasControlChars) {\n                    stringControlChars = regexStr.slice(subStrIndex, -1)\n                        .split(consecutiveSlashes)\n                        .filter(Boolean)\n                        .map(x => {\n                            const match = x.match(stringControlCharWithoutSlash) || [x];\n\n                            return `\\\\${match[0]}`;\n                        });\n                }\n            }\n\n            return controlChars.map(x => {\n                const hexCode = `0${x.charCodeAt(0).toString(16)}`.slice(-2);\n\n                return `\\\\x${hexCode}`;\n            }).concat(stringControlChars);\n        }\n\n        return {\n            Literal(node) {\n                const regex = getRegExp(node);\n\n                if (regex) {\n                    const computedValue = regex.toString();\n\n                    const controlCharacters = getControlCharacters(computedValue);\n\n                    if (controlCharacters.length > 0) {\n                        context.report({\n                            node,\n                            message: \"Unexpected control character(s) in regular expression: {{controlChars}}.\",\n                            data: {\n                                controlChars: controlCharacters.join(\", \")\n                            }\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","no-debugger.js":"/**\n * @fileoverview Rule to flag use of a debugger statement\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of `debugger`\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n        fixable: \"code\",\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n            DebuggerStatement(node) {\n                context.report({\n                    node,\n                    message: \"Unexpected 'debugger' statement.\",\n                    fix(fixer) {\n                        if (astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\n                            return fixer.remove(node);\n                        }\n                        return null;\n                    }\n                });\n            }\n        };\n\n    }\n};\n","no-delete-var.js":"/**\n * @fileoverview Rule to flag when deleting variables\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow deleting variables\",\n            category: \"Variables\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            UnaryExpression(node) {\n                if (node.operator === \"delete\" && node.argument.type === \"Identifier\") {\n                    context.report({ node, message: \"Variables should not be deleted.\" });\n                }\n            }\n        };\n\n    }\n};\n","no-div-regex.js":"/**\n * @fileoverview Rule to check for ambiguous div operator in regexes\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow division operators explicitly at the beginning of regular expressions\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n\n            Literal(node) {\n                const token = sourceCode.getFirstToken(node);\n\n                if (token.type === \"RegularExpression\" && token.value[1] === \"=\") {\n                    context.report({ node, message: \"A regular expression literal can be confused with '/='.\" });\n                }\n            }\n        };\n\n    }\n};\n","no-dupe-args.js":"/**\n * @fileoverview Rule to flag duplicate arguments\n * @author Jamund Ferguson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow duplicate arguments in `function` definitions\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Checks whether or not a given definition is a parameter's.\n         * @param {eslint-scope.DefEntry} def - A definition to check.\n         * @returns {boolean} `true` if the definition is a parameter's.\n         */\n        function isParameter(def) {\n            return def.type === \"Parameter\";\n        }\n\n        /**\n         * Determines if a given node has duplicate parameters.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkParams(node) {\n            const variables = context.getDeclaredVariables(node);\n\n            for (let i = 0; i < variables.length; ++i) {\n                const variable = variables[i];\n\n                // Checks and reports duplications.\n                const defs = variable.defs.filter(isParameter);\n\n                if (defs.length >= 2) {\n                    context.report({\n                        node,\n                        message: \"Duplicate param '{{name}}'.\",\n                        data: { name: variable.name }\n                    });\n                }\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            FunctionDeclaration: checkParams,\n            FunctionExpression: checkParams\n        };\n\n    }\n};\n","no-dupe-class-members.js":"/**\n * @fileoverview A rule to disallow duplicate name in class members.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow duplicate class members\",\n            category: \"ECMAScript 6\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        let stack = [];\n\n        /**\n         * Gets state of a given member name.\n         * @param {string} name - A name of a member.\n         * @param {boolean} isStatic - A flag which specifies that is a static member.\n         * @returns {Object} A state of a given member name.\n         *   - retv.init {boolean} A flag which shows the name is declared as normal member.\n         *   - retv.get {boolean} A flag which shows the name is declared as getter.\n         *   - retv.set {boolean} A flag which shows the name is declared as setter.\n         */\n        function getState(name, isStatic) {\n            const stateMap = stack[stack.length - 1];\n            const key = `$${name}`; // to avoid \"__proto__\".\n\n            if (!stateMap[key]) {\n                stateMap[key] = {\n                    nonStatic: { init: false, get: false, set: false },\n                    static: { init: false, get: false, set: false }\n                };\n            }\n\n            return stateMap[key][isStatic ? \"static\" : \"nonStatic\"];\n        }\n\n        /**\n         * Gets the name text of a given node.\n         *\n         * @param {ASTNode} node - A node to get the name.\n         * @returns {string} The name text of the node.\n         */\n        function getName(node) {\n            switch (node.type) {\n                case \"Identifier\": return node.name;\n                case \"Literal\": return String(node.value);\n\n                /* istanbul ignore next: syntax error */\n                default: return \"\";\n            }\n        }\n\n        return {\n\n            // Initializes the stack of state of member declarations.\n            Program() {\n                stack = [];\n            },\n\n            // Initializes state of member declarations for the class.\n            ClassBody() {\n                stack.push(Object.create(null));\n            },\n\n            // Disposes the state for the class.\n            \"ClassBody:exit\"() {\n                stack.pop();\n            },\n\n            // Reports the node if its name has been declared already.\n            MethodDefinition(node) {\n                if (node.computed) {\n                    return;\n                }\n\n                const name = getName(node.key);\n                const state = getState(name, node.static);\n                let isDuplicate = false;\n\n                if (node.kind === \"get\") {\n                    isDuplicate = (state.init || state.get);\n                    state.get = true;\n                } else if (node.kind === \"set\") {\n                    isDuplicate = (state.init || state.set);\n                    state.set = true;\n                } else {\n                    isDuplicate = (state.init || state.get || state.set);\n                    state.init = true;\n                }\n\n                if (isDuplicate) {\n                    context.report({ node, message: \"Duplicate name '{{name}}'.\", data: { name } });\n                }\n            }\n        };\n    }\n};\n","no-dupe-keys.js":"/**\n * @fileoverview Rule to flag use of duplicate keys in an object.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst GET_KIND = /^(?:init|get)$/;\nconst SET_KIND = /^(?:init|set)$/;\n\n/**\n * The class which stores properties' information of an object.\n */\nclass ObjectInfo {\n\n    /**\n     * @param {ObjectInfo|null} upper - The information of the outer object.\n     * @param {ASTNode} node - The ObjectExpression node of this information.\n     */\n    constructor(upper, node) {\n        this.upper = upper;\n        this.node = node;\n        this.properties = new Map();\n    }\n\n    /**\n     * Gets the information of the given Property node.\n     * @param {ASTNode} node - The Property node to get.\n     * @returns {{get: boolean, set: boolean}} The information of the property.\n     */\n    getPropertyInfo(node) {\n        const name = astUtils.getStaticPropertyName(node);\n\n        if (!this.properties.has(name)) {\n            this.properties.set(name, { get: false, set: false });\n        }\n        return this.properties.get(name);\n    }\n\n    /**\n     * Checks whether the given property has been defined already or not.\n     * @param {ASTNode} node - The Property node to check.\n     * @returns {boolean} `true` if the property has been defined.\n     */\n    isPropertyDefined(node) {\n        const entry = this.getPropertyInfo(node);\n\n        return (\n            (GET_KIND.test(node.kind) && entry.get) ||\n            (SET_KIND.test(node.kind) && entry.set)\n        );\n    }\n\n    /**\n     * Defines the given property.\n     * @param {ASTNode} node - The Property node to define.\n     * @returns {void}\n     */\n    defineProperty(node) {\n        const entry = this.getPropertyInfo(node);\n\n        if (GET_KIND.test(node.kind)) {\n            entry.get = true;\n        }\n        if (SET_KIND.test(node.kind)) {\n            entry.set = true;\n        }\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow duplicate keys in object literals\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        let info = null;\n\n        return {\n            ObjectExpression(node) {\n                info = new ObjectInfo(info, node);\n            },\n            \"ObjectExpression:exit\"() {\n                info = info.upper;\n            },\n\n            Property(node) {\n                const name = astUtils.getStaticPropertyName(node);\n\n                // Skip destructuring.\n                if (node.parent.type !== \"ObjectExpression\") {\n                    return;\n                }\n\n                // Skip if the name is not static.\n                if (!name) {\n                    return;\n                }\n\n                // Reports if the name is defined already.\n                if (info.isPropertyDefined(node)) {\n                    context.report({\n                        node: info.node,\n                        loc: node.key.loc,\n                        message: \"Duplicate key '{{name}}'.\",\n                        data: { name }\n                    });\n                }\n\n                // Update info.\n                info.defineProperty(node);\n            }\n        };\n    }\n};\n","no-duplicate-case.js":"/**\n * @fileoverview Rule to disallow a duplicate case label.\n * @author Dieter Oberkofler\n * @author Burak Yigit Kaya\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow duplicate case labels\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            SwitchStatement(node) {\n                const mapping = {};\n\n                node.cases.forEach(switchCase => {\n                    const key = sourceCode.getText(switchCase.test);\n\n                    if (mapping[key]) {\n                        context.report({ node: switchCase, message: \"Duplicate case label.\" });\n                    } else {\n                        mapping[key] = switchCase;\n                    }\n                });\n            }\n        };\n    }\n};\n","no-duplicate-imports.js":"/**\n * @fileoverview Restrict usage of duplicate imports.\n * @author Simen Bekkhus\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Returns the name of the module imported or re-exported.\n *\n * @param {ASTNode} node - A node to get.\n * @returns {string} the name of the module, or empty string if no name.\n */\nfunction getValue(node) {\n    if (node && node.source && node.source.value) {\n        return node.source.value.trim();\n    }\n\n    return \"\";\n}\n\n/**\n * Checks if the name of the import or export exists in the given array, and reports if so.\n *\n * @param {RuleContext} context - The ESLint rule context object.\n * @param {ASTNode} node - A node to get.\n * @param {string} value - The name of the imported or exported module.\n * @param {string[]} array - The array containing other imports or exports in the file.\n * @param {string} message - A message to be reported after the name of the module\n *\n * @returns {void} No return value\n */\nfunction checkAndReport(context, node, value, array, message) {\n    if (array.indexOf(value) !== -1) {\n        context.report({\n            node,\n            message: \"'{{module}}' {{message}}\",\n            data: {\n                module: value,\n                message\n            }\n        });\n    }\n}\n\n/**\n * @callback nodeCallback\n * @param {ASTNode} node - A node to handle.\n */\n\n/**\n * Returns a function handling the imports of a given file\n *\n * @param {RuleContext} context - The ESLint rule context object.\n * @param {boolean} includeExports - Whether or not to check for exports in addition to imports.\n * @param {string[]} importsInFile - The array containing other imports in the file.\n * @param {string[]} exportsInFile - The array containing other exports in the file.\n *\n * @returns {nodeCallback} A function passed to ESLint to handle the statement.\n */\nfunction handleImports(context, includeExports, importsInFile, exportsInFile) {\n    return function(node) {\n        const value = getValue(node);\n\n        if (value) {\n            checkAndReport(context, node, value, importsInFile, \"import is duplicated.\");\n\n            if (includeExports) {\n                checkAndReport(context, node, value, exportsInFile, \"import is duplicated as export.\");\n            }\n\n            importsInFile.push(value);\n        }\n    };\n}\n\n/**\n * Returns a function handling the exports of a given file\n *\n * @param {RuleContext} context - The ESLint rule context object.\n * @param {string[]} importsInFile - The array containing other imports in the file.\n * @param {string[]} exportsInFile - The array containing other exports in the file.\n *\n * @returns {nodeCallback} A function passed to ESLint to handle the statement.\n */\nfunction handleExports(context, importsInFile, exportsInFile) {\n    return function(node) {\n        const value = getValue(node);\n\n        if (value) {\n            checkAndReport(context, node, value, exportsInFile, \"export is duplicated.\");\n            checkAndReport(context, node, value, importsInFile, \"export is duplicated as import.\");\n\n            exportsInFile.push(value);\n        }\n    };\n}\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow duplicate module imports\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                includeExports: {\n                    type: \"boolean\"\n                }\n            },\n            additionalProperties: false\n        }]\n    },\n\n    create(context) {\n        const includeExports = (context.options[0] || {}).includeExports,\n            importsInFile = [],\n            exportsInFile = [];\n\n        const handlers = {\n            ImportDeclaration: handleImports(context, includeExports, importsInFile, exportsInFile)\n        };\n\n        if (includeExports) {\n            handlers.ExportNamedDeclaration = handleExports(context, importsInFile, exportsInFile);\n            handlers.ExportAllDeclaration = handleExports(context, importsInFile, exportsInFile);\n        }\n\n        return handlers;\n    }\n};\n","no-else-return.js":"/**\n * @fileoverview Rule to flag `else` after a `return` in `if`\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\nconst FixTracker = require(\"../util/fix-tracker\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `else` blocks after `return` statements in `if` statements\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Display the context report if rule is violated\n         *\n         * @param {Node} node The 'else' node\n         * @returns {void}\n         */\n        function displayReport(node) {\n            context.report({\n                node,\n                message: \"Unnecessary 'else' after 'return'.\",\n                fix: fixer => {\n                    const sourceCode = context.getSourceCode();\n                    const startToken = sourceCode.getFirstToken(node);\n                    const elseToken = sourceCode.getTokenBefore(startToken);\n                    const source = sourceCode.getText(node);\n                    const lastIfToken = sourceCode.getTokenBefore(elseToken);\n                    let fixedSource, firstTokenOfElseBlock;\n\n                    if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\n                        firstTokenOfElseBlock = sourceCode.getTokenAfter(startToken);\n                    } else {\n                        firstTokenOfElseBlock = startToken;\n                    }\n\n                    // If the if block does not have curly braces and does not end in a semicolon\n                    // and the else block starts with (, [, /, +, ` or -, then it is not\n                    // safe to remove the else keyword, because ASI will not add a semicolon\n                    // after the if block\n                    const ifBlockMaybeUnsafe = node.parent.consequent.type !== \"BlockStatement\" && lastIfToken.value !== \";\";\n                    const elseBlockUnsafe = /^[([/+`-]/.test(firstTokenOfElseBlock.value);\n\n                    if (ifBlockMaybeUnsafe && elseBlockUnsafe) {\n                        return null;\n                    }\n\n                    const endToken = sourceCode.getLastToken(node);\n                    const lastTokenOfElseBlock = sourceCode.getTokenBefore(endToken);\n\n                    if (lastTokenOfElseBlock.value !== \";\") {\n                        const nextToken = sourceCode.getTokenAfter(endToken);\n\n                        const nextTokenUnsafe = nextToken && /^[([/+`-]/.test(nextToken.value);\n                        const nextTokenOnSameLine = nextToken && nextToken.loc.start.line === lastTokenOfElseBlock.loc.start.line;\n\n                        // If the else block contents does not end in a semicolon,\n                        // and the else block starts with (, [, /, +, ` or -, then it is not\n                        // safe to remove the else block, because ASI will not add a semicolon\n                        // after the remaining else block contents\n                        if (nextTokenUnsafe || (nextTokenOnSameLine && nextToken.value !== \"}\")) {\n                            return null;\n                        }\n                    }\n\n                    if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\n                        fixedSource = source.slice(1, -1);\n                    } else {\n                        fixedSource = source;\n                    }\n\n                    // Extend the replacement range to include the entire\n                    // function to avoid conflicting with no-useless-return.\n                    // https://github.com/eslint/eslint/issues/8026\n                    return new FixTracker(fixer, sourceCode)\n                        .retainEnclosingFunction(node)\n                        .replaceTextRange([elseToken.range[0], node.range[1]], fixedSource);\n                }\n            });\n        }\n\n        /**\n         * Check to see if the node is a ReturnStatement\n         *\n         * @param {Node} node The node being evaluated\n         * @returns {boolean} True if node is a return\n         */\n        function checkForReturn(node) {\n            return node.type === \"ReturnStatement\";\n        }\n\n        /**\n         * Naive return checking, does not iterate through the whole\n         * BlockStatement because we make the assumption that the ReturnStatement\n         * will be the last node in the body of the BlockStatement.\n         *\n         * @param {Node} node The consequent/alternate node\n         * @returns {boolean} True if it has a return\n         */\n        function naiveHasReturn(node) {\n            if (node.type === \"BlockStatement\") {\n                const body = node.body,\n                    lastChildNode = body[body.length - 1];\n\n                return lastChildNode && checkForReturn(lastChildNode);\n            }\n            return checkForReturn(node);\n        }\n\n        /**\n         * Check to see if the node is valid for evaluation,\n         * meaning it has an else and not an else-if\n         *\n         * @param {Node} node The node being evaluated\n         * @returns {boolean} True if the node is valid\n         */\n        function hasElse(node) {\n            return node.alternate && node.consequent && node.alternate.type !== \"IfStatement\";\n        }\n\n        /**\n         * If the consequent is an IfStatement, check to see if it has an else\n         * and both its consequent and alternate path return, meaning this is\n         * a nested case of rule violation.  If-Else not considered currently.\n         *\n         * @param {Node} node The consequent node\n         * @returns {boolean} True if this is a nested rule violation\n         */\n        function checkForIf(node) {\n            return node.type === \"IfStatement\" && hasElse(node) &&\n                naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);\n        }\n\n        /**\n         * Check the consequent/body node to make sure it is not\n         * a ReturnStatement or an IfStatement that returns on both\n         * code paths.\n         *\n         * @param {Node} node The consequent or body node\n         * @param {Node} alternate The alternate node\n         * @returns {boolean} `true` if it is a Return/If node that always returns.\n         */\n        function checkForReturnOrIf(node) {\n            return checkForReturn(node) || checkForIf(node);\n        }\n\n\n        /**\n         * Check whether a node returns in every codepath.\n         * @param {Node} node The node to be checked\n         * @returns {boolean} `true` if it returns on every codepath.\n         */\n        function alwaysReturns(node) {\n            if (node.type === \"BlockStatement\") {\n\n                // If we have a BlockStatement, check each consequent body node.\n                return node.body.some(checkForReturnOrIf);\n            }\n\n            /*\n             * If not a block statement, make sure the consequent isn't a\n             * ReturnStatement or an IfStatement with returns on both paths.\n             */\n            return checkForReturnOrIf(node);\n        }\n\n        /**\n         * Check the if statement\n         * @returns {void}\n         * @param {Node} node The node for the if statement to check\n         * @private\n         */\n        function IfStatement(node) {\n            const parent = context.getAncestors().pop();\n            let consequents,\n                alternate;\n\n            /*\n             * Fixing this would require splitting one statement into two, so no error should\n             * be reported if this node is in a position where only one statement is allowed.\n             */\n            if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {\n                return;\n            }\n\n            for (consequents = []; node.type === \"IfStatement\"; node = node.alternate) {\n                if (!node.alternate) {\n                    return;\n                }\n                consequents.push(node.consequent);\n                alternate = node.alternate;\n            }\n\n            if (consequents.every(alwaysReturns)) {\n                displayReport(alternate);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n\n            \"IfStatement:exit\": IfStatement\n\n        };\n\n    }\n};\n","no-empty-character-class.js":"/**\n * @fileoverview Rule to flag the use of empty character classes in regular expressions\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/*\nplain-English description of the following regexp:\n0. `^` fix the match at the beginning of the string\n1. `\\/`: the `/` that begins the regexp\n2. `([^\\\\[]|\\\\.|\\[([^\\\\\\]]|\\\\.)+\\])*`: regexp contents; 0 or more of the following\n  2.0. `[^\\\\[]`: any character that's not a `\\` or a `[` (anything but escape sequences and character classes)\n  2.1. `\\\\.`: an escape sequence\n  2.2. `\\[([^\\\\\\]]|\\\\.)+\\]`: a character class that isn't empty\n3. `\\/` the `/` that ends the regexp\n4. `[gimuy]*`: optional regexp flags\n5. `$`: fix the match at the end of the string\n*/\nconst regex = /^\\/([^\\\\[]|\\\\.|\\[([^\\\\\\]]|\\\\.)+])*\\/[gimuy]*$/;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow empty character classes in regular expressions\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n\n            Literal(node) {\n                const token = sourceCode.getFirstToken(node);\n\n                if (token.type === \"RegularExpression\" && !regex.test(token.value)) {\n                    context.report({ node, message: \"Empty class.\" });\n                }\n            }\n\n        };\n\n    }\n};\n","no-empty-function.js":"/**\n * @fileoverview Rule to disallow empty functions.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst ALLOW_OPTIONS = Object.freeze([\n    \"functions\",\n    \"arrowFunctions\",\n    \"generatorFunctions\",\n    \"methods\",\n    \"generatorMethods\",\n    \"getters\",\n    \"setters\",\n    \"constructors\"\n]);\n\n/**\n * Gets the kind of a given function node.\n *\n * @param {ASTNode} node - A function node to get. This is one of\n *      an ArrowFunctionExpression, a FunctionDeclaration, or a\n *      FunctionExpression.\n * @returns {string} The kind of the function. This is one of \"functions\",\n *      \"arrowFunctions\", \"generatorFunctions\", \"asyncFunctions\", \"methods\",\n *      \"generatorMethods\", \"asyncMethods\", \"getters\", \"setters\", and\n *      \"constructors\".\n */\nfunction getKind(node) {\n    const parent = node.parent;\n    let kind = \"\";\n\n    if (node.type === \"ArrowFunctionExpression\") {\n        return \"arrowFunctions\";\n    }\n\n    // Detects main kind.\n    if (parent.type === \"Property\") {\n        if (parent.kind === \"get\") {\n            return \"getters\";\n        }\n        if (parent.kind === \"set\") {\n            return \"setters\";\n        }\n        kind = parent.method ? \"methods\" : \"functions\";\n\n    } else if (parent.type === \"MethodDefinition\") {\n        if (parent.kind === \"get\") {\n            return \"getters\";\n        }\n        if (parent.kind === \"set\") {\n            return \"setters\";\n        }\n        if (parent.kind === \"constructor\") {\n            return \"constructors\";\n        }\n        kind = \"methods\";\n\n    } else {\n        kind = \"functions\";\n    }\n\n    // Detects prefix.\n    let prefix = \"\";\n\n    if (node.generator) {\n        prefix = \"generator\";\n    } else if (node.async) {\n        prefix = \"async\";\n    } else {\n        return kind;\n    }\n    return prefix + kind[0].toUpperCase() + kind.slice(1);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow empty functions\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allow: {\n                        type: \"array\",\n                        items: { enum: ALLOW_OPTIONS },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const allowed = options.allow || [];\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports a given function node if the node matches the following patterns.\n         *\n         * - Not allowed by options.\n         * - The body is empty.\n         * - The body doesn't have any comments.\n         *\n         * @param {ASTNode} node - A function node to report. This is one of\n         *      an ArrowFunctionExpression, a FunctionDeclaration, or a\n         *      FunctionExpression.\n         * @returns {void}\n         */\n        function reportIfEmpty(node) {\n            const kind = getKind(node);\n            const name = astUtils.getFunctionNameWithKind(node);\n            const innerComments = sourceCode.getTokens(node.body, {\n                includeComments: true,\n                filter: astUtils.isCommentToken\n            });\n\n            if (allowed.indexOf(kind) === -1 &&\n                node.body.type === \"BlockStatement\" &&\n                node.body.body.length === 0 &&\n                innerComments.length === 0\n            ) {\n                context.report({\n                    node,\n                    loc: node.body.loc.start,\n                    message: \"Unexpected empty {{name}}.\",\n                    data: { name }\n                });\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: reportIfEmpty,\n            FunctionDeclaration: reportIfEmpty,\n            FunctionExpression: reportIfEmpty\n        };\n    }\n};\n","no-empty-pattern.js":"/**\n * @fileoverview Rule to disallow an empty pattern\n * @author Alberto RodrÃ­guez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow empty destructuring patterns\",\n            category: \"Best Practices\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        return {\n            ObjectPattern(node) {\n                if (node.properties.length === 0) {\n                    context.report({ node, message: \"Unexpected empty object pattern.\" });\n                }\n            },\n            ArrayPattern(node) {\n                if (node.elements.length === 0) {\n                    context.report({ node, message: \"Unexpected empty array pattern.\" });\n                }\n            }\n        };\n    }\n};\n","no-empty.js":"/**\n * @fileoverview Rule to flag use of an empty block statement\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow empty block statements\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowEmptyCatch: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = context.options[0] || {},\n            allowEmptyCatch = options.allowEmptyCatch || false;\n\n        const sourceCode = context.getSourceCode();\n\n        return {\n            BlockStatement(node) {\n\n                // if the body is not empty, we can just return immediately\n                if (node.body.length !== 0) {\n                    return;\n                }\n\n                // a function is generally allowed to be empty\n                if (astUtils.isFunction(node.parent)) {\n                    return;\n                }\n\n                if (allowEmptyCatch && node.parent.type === \"CatchClause\") {\n                    return;\n                }\n\n                // any other block is only allowed to be empty, if it contains a comment\n                if (sourceCode.getCommentsInside(node).length > 0) {\n                    return;\n                }\n\n                context.report({ node, message: \"Empty block statement.\" });\n            },\n\n            SwitchStatement(node) {\n\n                if (typeof node.cases === \"undefined\" || node.cases.length === 0) {\n                    context.report({ node, message: \"Empty switch statement.\" });\n                }\n            }\n        };\n\n    }\n};\n","no-eq-null.js":"/**\n * @fileoverview Rule to flag comparisons to null without a type-checking\n * operator.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `null` comparisons without type-checking operators\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            BinaryExpression(node) {\n                const badOperator = node.operator === \"==\" || node.operator === \"!=\";\n\n                if (node.right.type === \"Literal\" && node.right.raw === \"null\" && badOperator ||\n                        node.left.type === \"Literal\" && node.left.raw === \"null\" && badOperator) {\n                    context.report({ node, message: \"Use â===â to compare with ânullâ.\" });\n                }\n            }\n        };\n\n    }\n};\n","no-eval.js":"/**\n * @fileoverview Rule to flag use of eval() statement\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst candidatesOfGlobalObject = Object.freeze([\n    \"global\",\n    \"window\"\n]);\n\n/**\n * Checks a given node is a Identifier node of the specified name.\n *\n * @param {ASTNode} node - A node to check.\n * @param {string} name - A name to check.\n * @returns {boolean} `true` if the node is a Identifier node of the name.\n */\nfunction isIdentifier(node, name) {\n    return node.type === \"Identifier\" && node.name === name;\n}\n\n/**\n * Checks a given node is a Literal node of the specified string value.\n *\n * @param {ASTNode} node - A node to check.\n * @param {string} name - A name to check.\n * @returns {boolean} `true` if the node is a Literal node of the name.\n */\nfunction isConstant(node, name) {\n    switch (node.type) {\n        case \"Literal\":\n            return node.value === name;\n\n        case \"TemplateLiteral\":\n            return (\n                node.expressions.length === 0 &&\n                node.quasis[0].value.cooked === name\n            );\n\n        default:\n            return false;\n    }\n}\n\n/**\n * Checks a given node is a MemberExpression node which has the specified name's\n * property.\n *\n * @param {ASTNode} node - A node to check.\n * @param {string} name - A name to check.\n * @returns {boolean} `true` if the node is a MemberExpression node which has\n *      the specified name's property\n */\nfunction isMember(node, name) {\n    return (\n        node.type === \"MemberExpression\" &&\n        (node.computed ? isConstant : isIdentifier)(node.property, name)\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of `eval()`\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowIndirect: { type: \"boolean\" }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const allowIndirect = Boolean(\n            context.options[0] &&\n            context.options[0].allowIndirect\n        );\n        const sourceCode = context.getSourceCode();\n        let funcInfo = null;\n\n        /**\n         * Pushs a variable scope (Program or Function) information to the stack.\n         *\n         * This is used in order to check whether or not `this` binding is a\n         * reference to the global object.\n         *\n         * @param {ASTNode} node - A node of the scope. This is one of Program,\n         *      FunctionDeclaration, FunctionExpression, and ArrowFunctionExpression.\n         * @returns {void}\n         */\n        function enterVarScope(node) {\n            const strict = context.getScope().isStrict;\n\n            funcInfo = {\n                upper: funcInfo,\n                node,\n                strict,\n                defaultThis: false,\n                initialized: strict\n            };\n        }\n\n        /**\n         * Pops a variable scope from the stack.\n         *\n         * @returns {void}\n         */\n        function exitVarScope() {\n            funcInfo = funcInfo.upper;\n        }\n\n        /**\n         * Reports a given node.\n         *\n         * `node` is `Identifier` or `MemberExpression`.\n         * The parent of `node` might be `CallExpression`.\n         *\n         * The location of the report is always `eval` `Identifier` (or possibly\n         * `Literal`). The type of the report is `CallExpression` if the parent is\n         * `CallExpression`. Otherwise, it's the given node type.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            let locationNode = node;\n            const parent = node.parent;\n\n            if (node.type === \"MemberExpression\") {\n                locationNode = node.property;\n            }\n            if (parent.type === \"CallExpression\" && parent.callee === node) {\n                node = parent;\n            }\n\n            context.report({\n                node,\n                loc: locationNode.loc.start,\n                message: \"eval can be harmful.\"\n            });\n        }\n\n        /**\n         * Reports accesses of `eval` via the global object.\n         *\n         * @param {eslint-scope.Scope} globalScope - The global scope.\n         * @returns {void}\n         */\n        function reportAccessingEvalViaGlobalObject(globalScope) {\n            for (let i = 0; i < candidatesOfGlobalObject.length; ++i) {\n                const name = candidatesOfGlobalObject[i];\n                const variable = astUtils.getVariableByName(globalScope, name);\n\n                if (!variable) {\n                    continue;\n                }\n\n                const references = variable.references;\n\n                for (let j = 0; j < references.length; ++j) {\n                    const identifier = references[j].identifier;\n                    let node = identifier.parent;\n\n                    // To detect code like `window.window.eval`.\n                    while (isMember(node, name)) {\n                        node = node.parent;\n                    }\n\n                    // Reports.\n                    if (isMember(node, \"eval\")) {\n                        report(node);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Reports all accesses of `eval` (excludes direct calls to eval).\n         *\n         * @param {eslint-scope.Scope} globalScope - The global scope.\n         * @returns {void}\n         */\n        function reportAccessingEval(globalScope) {\n            const variable = astUtils.getVariableByName(globalScope, \"eval\");\n\n            if (!variable) {\n                return;\n            }\n\n            const references = variable.references;\n\n            for (let i = 0; i < references.length; ++i) {\n                const reference = references[i];\n                const id = reference.identifier;\n\n                if (id.name === \"eval\" && !astUtils.isCallee(id)) {\n\n                    // Is accessing to eval (excludes direct calls to eval)\n                    report(id);\n                }\n            }\n        }\n\n        if (allowIndirect) {\n\n            // Checks only direct calls to eval. It's simple!\n            return {\n                \"CallExpression:exit\"(node) {\n                    const callee = node.callee;\n\n                    if (isIdentifier(callee, \"eval\")) {\n                        report(callee);\n                    }\n                }\n            };\n        }\n\n        return {\n            \"CallExpression:exit\"(node) {\n                const callee = node.callee;\n\n                if (isIdentifier(callee, \"eval\")) {\n                    report(callee);\n                }\n            },\n\n            Program(node) {\n                const scope = context.getScope(),\n                    features = context.parserOptions.ecmaFeatures || {},\n                    strict =\n                        scope.isStrict ||\n                        node.sourceType === \"module\" ||\n                        (features.globalReturn && scope.childScopes[0].isStrict);\n\n                funcInfo = {\n                    upper: null,\n                    node,\n                    strict,\n                    defaultThis: true,\n                    initialized: true\n                };\n            },\n\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n\n                exitVarScope();\n                reportAccessingEval(globalScope);\n                reportAccessingEvalViaGlobalObject(globalScope);\n            },\n\n            FunctionDeclaration: enterVarScope,\n            \"FunctionDeclaration:exit\": exitVarScope,\n            FunctionExpression: enterVarScope,\n            \"FunctionExpression:exit\": exitVarScope,\n            ArrowFunctionExpression: enterVarScope,\n            \"ArrowFunctionExpression:exit\": exitVarScope,\n\n            ThisExpression(node) {\n                if (!isMember(node.parent, \"eval\")) {\n                    return;\n                }\n\n                /*\n                 * `this.eval` is found.\n                 * Checks whether or not the value of `this` is the global object.\n                 */\n                if (!funcInfo.initialized) {\n                    funcInfo.initialized = true;\n                    funcInfo.defaultThis = astUtils.isDefaultThisBinding(\n                        funcInfo.node,\n                        sourceCode\n                    );\n                }\n\n                if (!funcInfo.strict && funcInfo.defaultThis) {\n\n                    // `this.eval` is possible built-in `eval`.\n                    report(node.parent);\n                }\n            }\n        };\n\n    }\n};\n","no-ex-assign.js":"/**\n * @fileoverview Rule to flag assignment of the exception parameter\n * @author Stephen Murray <spmurrayzzz>\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow reassigning exceptions in `catch` clauses\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {Variable} variable - A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            astUtils.getModifyingReferences(variable.references).forEach(reference => {\n                context.report({ node: reference.identifier, message: \"Do not assign to the exception parameter.\" });\n            });\n        }\n\n        return {\n            CatchClause(node) {\n                context.getDeclaredVariables(node).forEach(checkVariable);\n            }\n        };\n\n    }\n};\n","no-extend-native.js":"/**\n * @fileoverview Rule to flag adding properties to native object's prototypes.\n * @author David Nelson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\nconst globals = require(\"globals\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst propertyDefinitionMethods = new Set([\"defineProperty\", \"defineProperties\"]);\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow extending native types\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const config = context.options[0] || {};\n        const exceptions = new Set(config.exceptions || []);\n        const modifiedBuiltins = new Set(\n            Object.keys(globals.builtin)\n                .filter(builtin => builtin[0].toUpperCase() === builtin[0])\n                .filter(builtin => !exceptions.has(builtin))\n        );\n\n        /**\n         * Reports a lint error for the given node.\n         * @param {ASTNode} node The node to report.\n         * @param {string} builtin The name of the native builtin being extended.\n         * @returns {void}\n         */\n        function reportNode(node, builtin) {\n            context.report({\n                node,\n                message: \"{{builtin}} prototype is read only, properties should not be added.\",\n                data: {\n                    builtin\n                }\n            });\n        }\n\n        /**\n         * Check to see if the `prototype` property of the given object\n         * identifier node is being accessed.\n         * @param {ASTNode} identifierNode The Identifier representing the object\n         * to check.\n         * @returns {boolean} True if the identifier is the object of a\n         * MemberExpression and its `prototype` property is being accessed,\n         * false otherwise.\n         */\n        function isPrototypePropertyAccessed(identifierNode) {\n            return Boolean(\n                identifierNode &&\n                identifierNode.parent &&\n                identifierNode.parent.type === \"MemberExpression\" &&\n                identifierNode.parent.object === identifierNode &&\n                astUtils.getStaticPropertyName(identifierNode.parent) === \"prototype\"\n            );\n        }\n\n        /**\n         * Checks that an identifier is an object of a prototype whose member\n         * is being assigned in an AssignmentExpression.\n         * Example: Object.prototype.foo = \"bar\"\n         * @param {ASTNode} identifierNode The identifier to check.\n         * @returns {boolean} True if the identifier's prototype is modified.\n         */\n        function isInPrototypePropertyAssignment(identifierNode) {\n            return Boolean(\n                isPrototypePropertyAccessed(identifierNode) &&\n                identifierNode.parent.parent.type === \"MemberExpression\" &&\n                identifierNode.parent.parent.parent.type === \"AssignmentExpression\" &&\n                identifierNode.parent.parent.parent.left === identifierNode.parent.parent\n            );\n        }\n\n        /**\n         * Checks that an identifier is an object of a prototype whose member\n         * is being extended via the Object.defineProperty() or\n         * Object.defineProperties() methods.\n         * Example: Object.defineProperty(Array.prototype, \"foo\", ...)\n         * Example: Object.defineProperties(Array.prototype, ...)\n         * @param {ASTNode} identifierNode The identifier to check.\n         * @returns {boolean} True if the identifier's prototype is modified.\n         */\n        function isInDefinePropertyCall(identifierNode) {\n            return Boolean(\n                isPrototypePropertyAccessed(identifierNode) &&\n                identifierNode.parent.parent.type === \"CallExpression\" &&\n                identifierNode.parent.parent.arguments[0] === identifierNode.parent &&\n                identifierNode.parent.parent.callee.type === \"MemberExpression\" &&\n                identifierNode.parent.parent.callee.object.type === \"Identifier\" &&\n                identifierNode.parent.parent.callee.object.name === \"Object\" &&\n                identifierNode.parent.parent.callee.property.type === \"Identifier\" &&\n                propertyDefinitionMethods.has(identifierNode.parent.parent.callee.property.name)\n            );\n        }\n\n        /**\n         * Check to see if object prototype access is part of a prototype\n         * extension. There are three ways a prototype can be extended:\n         * 1. Assignment to prototype property (Object.prototype.foo = 1)\n         * 2. Object.defineProperty()/Object.defineProperties() on a prototype\n         * If prototype extension is detected, report the AssignmentExpression\n         * or CallExpression node.\n         * @param {ASTNode} identifierNode The Identifier representing the object\n         * which prototype is being accessed and possibly extended.\n         * @returns {void}\n         */\n        function checkAndReportPrototypeExtension(identifierNode) {\n            if (isInPrototypePropertyAssignment(identifierNode)) {\n\n                // Identifier --> MemberExpression --> MemberExpression --> AssignmentExpression\n                reportNode(identifierNode.parent.parent.parent, identifierNode.name);\n            } else if (isInDefinePropertyCall(identifierNode)) {\n\n                // Identifier --> MemberExpression --> CallExpression\n                reportNode(identifierNode.parent.parent, identifierNode.name);\n            }\n        }\n\n        return {\n\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n\n                modifiedBuiltins.forEach(builtin => {\n                    const builtinVar = globalScope.set.get(builtin);\n\n                    if (builtinVar && builtinVar.references) {\n                        builtinVar.references\n                            .map(ref => ref.identifier)\n                            .forEach(checkAndReportPrototypeExtension);\n                    }\n                });\n            }\n        };\n\n    }\n};\n","no-extra-bind.js":"/**\n * @fileoverview Rule to flag unnecessary bind calls\n * @author Bence DÃ¡nyi <bence@danyi.me>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary calls to `.bind()`\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        let scopeInfo = null;\n\n        /**\n         * Reports a given function node.\n         *\n         * @param {ASTNode} node - A node to report. This is a FunctionExpression or\n         *      an ArrowFunctionExpression.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node: node.parent.parent,\n                message: \"The function binding is unnecessary.\",\n                loc: node.parent.property.loc.start,\n                fix(fixer) {\n                    const firstTokenToRemove = context.getSourceCode()\n                        .getFirstTokenBetween(node.parent.object, node.parent.property, astUtils.isNotClosingParenToken);\n\n                    return fixer.removeRange([firstTokenToRemove.range[0], node.parent.parent.range[1]]);\n                }\n            });\n        }\n\n        /**\n         * Checks whether or not a given function node is the callee of `.bind()`\n         * method.\n         *\n         * e.g. `(function() {}.bind(foo))`\n         *\n         * @param {ASTNode} node - A node to report. This is a FunctionExpression or\n         *      an ArrowFunctionExpression.\n         * @returns {boolean} `true` if the node is the callee of `.bind()` method.\n         */\n        function isCalleeOfBindMethod(node) {\n            const parent = node.parent;\n            const grandparent = parent.parent;\n\n            return (\n                grandparent &&\n                grandparent.type === \"CallExpression\" &&\n                grandparent.callee === parent &&\n                grandparent.arguments.length === 1 &&\n                parent.type === \"MemberExpression\" &&\n                parent.object === node &&\n                astUtils.getStaticPropertyName(parent) === \"bind\"\n            );\n        }\n\n        /**\n         * Adds a scope information object to the stack.\n         *\n         * @param {ASTNode} node - A node to add. This node is a FunctionExpression\n         *      or a FunctionDeclaration node.\n         * @returns {void}\n         */\n        function enterFunction(node) {\n            scopeInfo = {\n                isBound: isCalleeOfBindMethod(node),\n                thisFound: false,\n                upper: scopeInfo\n            };\n        }\n\n        /**\n         * Removes the scope information object from the top of the stack.\n         * At the same time, this reports the function node if the function has\n         * `.bind()` and the `this` keywords found.\n         *\n         * @param {ASTNode} node - A node to remove. This node is a\n         *      FunctionExpression or a FunctionDeclaration node.\n         * @returns {void}\n         */\n        function exitFunction(node) {\n            if (scopeInfo.isBound && !scopeInfo.thisFound) {\n                report(node);\n            }\n\n            scopeInfo = scopeInfo.upper;\n        }\n\n        /**\n         * Reports a given arrow function if the function is callee of `.bind()`\n         * method.\n         *\n         * @param {ASTNode} node - A node to report. This node is an\n         *      ArrowFunctionExpression.\n         * @returns {void}\n         */\n        function exitArrowFunction(node) {\n            if (isCalleeOfBindMethod(node)) {\n                report(node);\n            }\n        }\n\n        /**\n         * Set the mark as the `this` keyword was found in this scope.\n         *\n         * @returns {void}\n         */\n        function markAsThisFound() {\n            if (scopeInfo) {\n                scopeInfo.thisFound = true;\n            }\n        }\n\n        return {\n            \"ArrowFunctionExpression:exit\": exitArrowFunction,\n            FunctionDeclaration: enterFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            FunctionExpression: enterFunction,\n            \"FunctionExpression:exit\": exitFunction,\n            ThisExpression: markAsThisFound\n        };\n    }\n};\n","no-extra-boolean-cast.js":"/**\n * @fileoverview Rule to flag unnecessary double negation in Boolean contexts\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary boolean casts\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        // Node types which have a test which will coerce values to booleans.\n        const BOOLEAN_NODE_TYPES = [\n            \"IfStatement\",\n            \"DoWhileStatement\",\n            \"WhileStatement\",\n            \"ConditionalExpression\",\n            \"ForStatement\"\n        ];\n\n        /**\n         * Check if a node is in a context where its value would be coerced to a boolean at runtime.\n         *\n         * @param {Object} node The node\n         * @param {Object} parent Its parent\n         * @returns {boolean} If it is in a boolean context\n         */\n        function isInBooleanContext(node, parent) {\n            return (\n                (BOOLEAN_NODE_TYPES.indexOf(parent.type) !== -1 &&\n                    node === parent.test) ||\n\n                // !<bool>\n                (parent.type === \"UnaryExpression\" &&\n                    parent.operator === \"!\")\n            );\n        }\n\n\n        return {\n            UnaryExpression(node) {\n                const ancestors = context.getAncestors(),\n                    parent = ancestors.pop(),\n                    grandparent = ancestors.pop();\n\n                // Exit early if it's guaranteed not to match\n                if (node.operator !== \"!\" ||\n                        parent.type !== \"UnaryExpression\" ||\n                        parent.operator !== \"!\") {\n                    return;\n                }\n\n                if (isInBooleanContext(parent, grandparent) ||\n\n                    // Boolean(<bool>) and new Boolean(<bool>)\n                    ((grandparent.type === \"CallExpression\" || grandparent.type === \"NewExpression\") &&\n                        grandparent.callee.type === \"Identifier\" &&\n                        grandparent.callee.name === \"Boolean\")\n                ) {\n                    context.report({\n                        node,\n                        message: \"Redundant double negation.\",\n                        fix: fixer => fixer.replaceText(parent, sourceCode.getText(node.argument))\n                    });\n                }\n            },\n            CallExpression(node) {\n                const parent = node.parent;\n\n                if (node.callee.type !== \"Identifier\" || node.callee.name !== \"Boolean\") {\n                    return;\n                }\n\n                if (isInBooleanContext(node, parent)) {\n                    context.report({\n                        node,\n                        message: \"Redundant Boolean call.\",\n                        fix: fixer => {\n                            if (!node.arguments.length) {\n                                return fixer.replaceText(parent, \"true\");\n                            }\n\n                            if (node.arguments.length > 1 || node.arguments[0].type === \"SpreadElement\") {\n                                return null;\n                            }\n\n                            const argument = node.arguments[0];\n\n                            if (astUtils.getPrecedence(argument) < astUtils.getPrecedence(node.parent)) {\n                                return fixer.replaceText(node, `(${sourceCode.getText(argument)})`);\n                            }\n                            return fixer.replaceText(node, sourceCode.getText(argument));\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","no-extra-label.js":"/**\n * @fileoverview Rule to disallow unnecessary labels\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary labels\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        let scopeInfo = null;\n\n        /**\n         * Creates a new scope with a breakable statement.\n         *\n         * @param {ASTNode} node - A node to create. This is a BreakableStatement.\n         * @returns {void}\n         */\n        function enterBreakableStatement(node) {\n            scopeInfo = {\n                label: node.parent.type === \"LabeledStatement\" ? node.parent.label : null,\n                breakable: true,\n                upper: scopeInfo\n            };\n        }\n\n        /**\n         * Removes the top scope of the stack.\n         *\n         * @returns {void}\n         */\n        function exitBreakableStatement() {\n            scopeInfo = scopeInfo.upper;\n        }\n\n        /**\n         * Creates a new scope with a labeled statement.\n         *\n         * This ignores it if the body is a breakable statement.\n         * In this case it's handled in the `enterBreakableStatement` function.\n         *\n         * @param {ASTNode} node - A node to create. This is a LabeledStatement.\n         * @returns {void}\n         */\n        function enterLabeledStatement(node) {\n            if (!astUtils.isBreakableStatement(node.body)) {\n                scopeInfo = {\n                    label: node.label,\n                    breakable: false,\n                    upper: scopeInfo\n                };\n            }\n        }\n\n        /**\n         * Removes the top scope of the stack.\n         *\n         * This ignores it if the body is a breakable statement.\n         * In this case it's handled in the `exitBreakableStatement` function.\n         *\n         * @param {ASTNode} node - A node. This is a LabeledStatement.\n         * @returns {void}\n         */\n        function exitLabeledStatement(node) {\n            if (!astUtils.isBreakableStatement(node.body)) {\n                scopeInfo = scopeInfo.upper;\n            }\n        }\n\n        /**\n         * Reports a given control node if it's unnecessary.\n         *\n         * @param {ASTNode} node - A node. This is a BreakStatement or a\n         *      ContinueStatement.\n         * @returns {void}\n         */\n        function reportIfUnnecessary(node) {\n            if (!node.label) {\n                return;\n            }\n\n            const labelNode = node.label;\n\n            for (let info = scopeInfo; info !== null; info = info.upper) {\n                if (info.breakable || info.label && info.label.name === labelNode.name) {\n                    if (info.breakable && info.label && info.label.name === labelNode.name) {\n                        context.report({\n                            node: labelNode,\n                            message: \"This label '{{name}}' is unnecessary.\",\n                            data: labelNode,\n                            fix: fixer => fixer.removeRange([sourceCode.getFirstToken(node).range[1], labelNode.range[1]])\n                        });\n                    }\n                    return;\n                }\n            }\n        }\n\n        return {\n            WhileStatement: enterBreakableStatement,\n            \"WhileStatement:exit\": exitBreakableStatement,\n            DoWhileStatement: enterBreakableStatement,\n            \"DoWhileStatement:exit\": exitBreakableStatement,\n            ForStatement: enterBreakableStatement,\n            \"ForStatement:exit\": exitBreakableStatement,\n            ForInStatement: enterBreakableStatement,\n            \"ForInStatement:exit\": exitBreakableStatement,\n            ForOfStatement: enterBreakableStatement,\n            \"ForOfStatement:exit\": exitBreakableStatement,\n            SwitchStatement: enterBreakableStatement,\n            \"SwitchStatement:exit\": exitBreakableStatement,\n            LabeledStatement: enterLabeledStatement,\n            \"LabeledStatement:exit\": exitLabeledStatement,\n            BreakStatement: reportIfUnnecessary,\n            ContinueStatement: reportIfUnnecessary\n        };\n    }\n};\n","no-extra-parens.js":"/**\n * @fileoverview Disallow parenthesising higher precedence subexpressions.\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils.js\");\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary parentheses\",\n            category: \"Possible Errors\",\n            recommended: false\n        },\n\n        fixable: \"code\",\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"functions\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"all\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                conditionalAssign: { type: \"boolean\" },\n                                nestedBinaryExpressions: { type: \"boolean\" },\n                                returnAssign: { type: \"boolean\" },\n                                ignoreJSX: { enum: [\"none\", \"all\", \"single-line\", \"multi-line\"] },\n                                enforceForArrowConditionals: { type: \"boolean\" }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const tokensToIgnore = new WeakSet();\n        const isParenthesised = astUtils.isParenthesised.bind(astUtils, sourceCode);\n        const precedence = astUtils.getPrecedence;\n        const ALL_NODES = context.options[0] !== \"functions\";\n        const EXCEPT_COND_ASSIGN = ALL_NODES && context.options[1] && context.options[1].conditionalAssign === false;\n        const NESTED_BINARY = ALL_NODES && context.options[1] && context.options[1].nestedBinaryExpressions === false;\n        const EXCEPT_RETURN_ASSIGN = ALL_NODES && context.options[1] && context.options[1].returnAssign === false;\n        const IGNORE_JSX = ALL_NODES && context.options[1] && context.options[1].ignoreJSX;\n        const IGNORE_ARROW_CONDITIONALS = ALL_NODES && context.options[1] &&\n            context.options[1].enforceForArrowConditionals === false;\n\n        const PRECEDENCE_OF_ASSIGNMENT_EXPR = precedence({ type: \"AssignmentExpression\" });\n        const PRECEDENCE_OF_UPDATE_EXPR = precedence({ type: \"UpdateExpression\" });\n\n        /**\n         * Determines if this rule should be enforced for a node given the current configuration.\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the rule should be enforced for this node.\n         * @private\n         */\n        function ruleApplies(node) {\n            if (node.type === \"JSXElement\") {\n                const isSingleLine = node.loc.start.line === node.loc.end.line;\n\n                switch (IGNORE_JSX) {\n\n                    // Exclude this JSX element from linting\n                    case \"all\":\n                        return false;\n\n                    // Exclude this JSX element if it is multi-line element\n                    case \"multi-line\":\n                        return isSingleLine;\n\n                    // Exclude this JSX element if it is single-line element\n                    case \"single-line\":\n                        return !isSingleLine;\n\n                    // Nothing special to be done for JSX elements\n                    case \"none\":\n                        break;\n\n                    // no default\n                }\n            }\n\n            return ALL_NODES || node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\";\n        }\n\n        /**\n         * Determines if a node is surrounded by parentheses twice.\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the node is doubly parenthesised.\n         * @private\n         */\n        function isParenthesisedTwice(node) {\n            const previousToken = sourceCode.getTokenBefore(node, 1),\n                nextToken = sourceCode.getTokenAfter(node, 1);\n\n            return isParenthesised(node) && previousToken && nextToken &&\n                astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] &&\n                astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];\n        }\n\n        /**\n         * Determines if a node is surrounded by (potentially) invalid parentheses.\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the node is incorrectly parenthesised.\n         * @private\n         */\n        function hasExcessParens(node) {\n            return ruleApplies(node) && isParenthesised(node);\n        }\n\n        /**\n         * Determines if a node that is expected to be parenthesised is surrounded by\n         * (potentially) invalid extra parentheses.\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the node is has an unexpected extra pair of parentheses.\n         * @private\n         */\n        function hasDoubleExcessParens(node) {\n            return ruleApplies(node) && isParenthesisedTwice(node);\n        }\n\n        /**\n         * Determines if a node test expression is allowed to have a parenthesised assignment\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the assignment can be parenthesised.\n         * @private\n         */\n        function isCondAssignException(node) {\n            return EXCEPT_COND_ASSIGN && node.test.type === \"AssignmentExpression\";\n        }\n\n        /**\n         * Determines if a node is in a return statement\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the node is in a return statement.\n         * @private\n         */\n        function isInReturnStatement(node) {\n            while (node) {\n                if (node.type === \"ReturnStatement\" ||\n                        (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\")) {\n                    return true;\n                }\n                node = node.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a constructor function is newed-up with parens\n         * @param {ASTNode} newExpression - The NewExpression node to be checked.\n         * @returns {boolean} True if the constructor is called with parens.\n         * @private\n         */\n        function isNewExpressionWithParens(newExpression) {\n            const lastToken = sourceCode.getLastToken(newExpression);\n            const penultimateToken = sourceCode.getTokenBefore(lastToken);\n\n            return newExpression.arguments.length > 0 || astUtils.isOpeningParenToken(penultimateToken) && astUtils.isClosingParenToken(lastToken);\n        }\n\n        /**\n         * Determines if a node is or contains an assignment expression\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the node is or contains an assignment expression.\n         * @private\n         */\n        function containsAssignment(node) {\n            if (node.type === \"AssignmentExpression\") {\n                return true;\n            } else if (node.type === \"ConditionalExpression\" &&\n                    (node.consequent.type === \"AssignmentExpression\" || node.alternate.type === \"AssignmentExpression\")) {\n                return true;\n            } else if ((node.left && node.left.type === \"AssignmentExpression\") ||\n                    (node.right && node.right.type === \"AssignmentExpression\")) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a node is contained by or is itself a return statement and is allowed to have a parenthesised assignment\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the assignment can be parenthesised.\n         * @private\n         */\n        function isReturnAssignException(node) {\n            if (!EXCEPT_RETURN_ASSIGN || !isInReturnStatement(node)) {\n                return false;\n            }\n\n            if (node.type === \"ReturnStatement\") {\n                return node.argument && containsAssignment(node.argument);\n            } else if (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\") {\n                return containsAssignment(node.body);\n            }\n            return containsAssignment(node);\n\n        }\n\n        /**\n         * Determines if a node following a [no LineTerminator here] restriction is\n         * surrounded by (potentially) invalid extra parentheses.\n         * @param {Token} token - The token preceding the [no LineTerminator here] restriction.\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the node is incorrectly parenthesised.\n         * @private\n         */\n        function hasExcessParensNoLineTerminator(token, node) {\n            if (token.loc.end.line === node.loc.start.line) {\n                return hasExcessParens(node);\n            }\n\n            return hasDoubleExcessParens(node);\n        }\n\n        /**\n         * Determines whether a node should be preceded by an additional space when removing parens\n         * @param {ASTNode} node node to evaluate; must be surrounded by parentheses\n         * @returns {boolean} `true` if a space should be inserted before the node\n         * @private\n         */\n        function requiresLeadingSpace(node) {\n            const leftParenToken = sourceCode.getTokenBefore(node);\n            const tokenBeforeLeftParen = sourceCode.getTokenBefore(node, 1);\n            const firstToken = sourceCode.getFirstToken(node);\n\n            return tokenBeforeLeftParen &&\n                tokenBeforeLeftParen.range[1] === leftParenToken.range[0] &&\n                leftParenToken.range[1] === firstToken.range[0] &&\n                !astUtils.canTokensBeAdjacent(tokenBeforeLeftParen, firstToken);\n        }\n\n        /**\n         * Determines whether a node should be followed by an additional space when removing parens\n         * @param {ASTNode} node node to evaluate; must be surrounded by parentheses\n         * @returns {boolean} `true` if a space should be inserted after the node\n         * @private\n         */\n        function requiresTrailingSpace(node) {\n            const nextTwoTokens = sourceCode.getTokensAfter(node, { count: 2 });\n            const rightParenToken = nextTwoTokens[0];\n            const tokenAfterRightParen = nextTwoTokens[1];\n            const tokenBeforeRightParen = sourceCode.getLastToken(node);\n\n            return rightParenToken && tokenAfterRightParen &&\n                !sourceCode.isSpaceBetweenTokens(rightParenToken, tokenAfterRightParen) &&\n                !astUtils.canTokensBeAdjacent(tokenBeforeRightParen, tokenAfterRightParen);\n        }\n\n        /**\n         * Determines if a given expression node is an IIFE\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} `true` if the given node is an IIFE\n         */\n        function isIIFE(node) {\n            return node.type === \"CallExpression\" && node.callee.type === \"FunctionExpression\";\n        }\n\n        /**\n         * Report the node\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            const leftParenToken = sourceCode.getTokenBefore(node);\n            const rightParenToken = sourceCode.getTokenAfter(node);\n\n            if (!isParenthesisedTwice(node)) {\n                if (tokensToIgnore.has(sourceCode.getFirstToken(node))) {\n                    return;\n                }\n\n                if (isIIFE(node) && !isParenthesised(node.callee)) {\n                    return;\n                }\n            }\n\n            context.report({\n                node,\n                loc: leftParenToken.loc.start,\n                message: \"Gratuitous parentheses around expression.\",\n                fix(fixer) {\n                    const parenthesizedSource = sourceCode.text.slice(leftParenToken.range[1], rightParenToken.range[0]);\n\n                    return fixer.replaceTextRange([\n                        leftParenToken.range[0],\n                        rightParenToken.range[1]\n                    ], (requiresLeadingSpace(node) ? \" \" : \"\") + parenthesizedSource + (requiresTrailingSpace(node) ? \" \" : \"\"));\n                }\n            });\n        }\n\n        /**\n         * Evaluate Unary update\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkUnaryUpdate(node) {\n            if (node.type === \"UnaryExpression\" && node.argument.type === \"BinaryExpression\" && node.argument.operator === \"**\") {\n                return;\n            }\n\n            if (hasExcessParens(node.argument) && precedence(node.argument) >= precedence(node)) {\n                report(node.argument);\n            }\n        }\n\n        /**\n         * Check if a member expression contains a call expression\n         * @param {ASTNode} node MemberExpression node to evaluate\n         * @returns {boolean} true if found, false if not\n         */\n        function doesMemberExpressionContainCallExpression(node) {\n            let currentNode = node.object;\n            let currentNodeType = node.object.type;\n\n            while (currentNodeType === \"MemberExpression\") {\n                currentNode = currentNode.object;\n                currentNodeType = currentNode.type;\n            }\n\n            return currentNodeType === \"CallExpression\";\n        }\n\n        /**\n         * Evaluate a new call\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkCallNew(node) {\n            const callee = node.callee;\n\n            if (hasExcessParens(callee) && precedence(callee) >= precedence(node)) {\n                const hasNewParensException = callee.type === \"NewExpression\" && !isNewExpressionWithParens(callee);\n\n                if (\n                    hasDoubleExcessParens(callee) ||\n                    !isIIFE(node) && !hasNewParensException && !(\n\n                        // Allow extra parens around a new expression if\n                        // there are intervening parentheses.\n                        callee.type === \"MemberExpression\" &&\n                        doesMemberExpressionContainCallExpression(callee)\n                    )\n                ) {\n                    report(node.callee);\n                }\n            }\n            if (node.arguments.length === 1) {\n                if (hasDoubleExcessParens(node.arguments[0]) && precedence(node.arguments[0]) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n                    report(node.arguments[0]);\n                }\n            } else {\n                node.arguments\n                    .filter(arg => hasExcessParens(arg) && precedence(arg) >= PRECEDENCE_OF_ASSIGNMENT_EXPR)\n                    .forEach(report);\n            }\n        }\n\n        /**\n         * Evaluate binary logicals\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkBinaryLogical(node) {\n            const prec = precedence(node);\n            const leftPrecedence = precedence(node.left);\n            const rightPrecedence = precedence(node.right);\n            const isExponentiation = node.operator === \"**\";\n            const shouldSkipLeft = (NESTED_BINARY && (node.left.type === \"BinaryExpression\" || node.left.type === \"LogicalExpression\")) ||\n              node.left.type === \"UnaryExpression\" && isExponentiation;\n            const shouldSkipRight = NESTED_BINARY && (node.right.type === \"BinaryExpression\" || node.right.type === \"LogicalExpression\");\n\n            if (!shouldSkipLeft && hasExcessParens(node.left) && (leftPrecedence > prec || (leftPrecedence === prec && !isExponentiation))) {\n                report(node.left);\n            }\n            if (!shouldSkipRight && hasExcessParens(node.right) && (rightPrecedence > prec || (rightPrecedence === prec && isExponentiation))) {\n                report(node.right);\n            }\n        }\n\n        /**\n         * Check the parentheses around the super class of the given class definition.\n         * @param {ASTNode} node The node of class declarations to check.\n         * @returns {void}\n         */\n        function checkClass(node) {\n            if (!node.superClass) {\n                return;\n            }\n\n            // If `node.superClass` is a LeftHandSideExpression, parentheses are extra.\n            // Otherwise, parentheses are needed.\n            const hasExtraParens = precedence(node.superClass) > PRECEDENCE_OF_UPDATE_EXPR\n                ? hasExcessParens(node.superClass)\n                : hasDoubleExcessParens(node.superClass);\n\n            if (hasExtraParens) {\n                report(node.superClass);\n            }\n        }\n\n        /**\n         * Check the parentheses around the argument of the given spread operator.\n         * @param {ASTNode} node The node of spread elements/properties to check.\n         * @returns {void}\n         */\n        function checkSpreadOperator(node) {\n            const hasExtraParens = precedence(node.argument) >= PRECEDENCE_OF_ASSIGNMENT_EXPR\n                ? hasExcessParens(node.argument)\n                : hasDoubleExcessParens(node.argument);\n\n            if (hasExtraParens) {\n                report(node.argument);\n            }\n        }\n\n        /**\n         * Checks the parentheses for an ExpressionStatement or ExportDefaultDeclaration\n         * @param {ASTNode} node The ExpressionStatement.expression or ExportDefaultDeclaration.declaration node\n         * @returns {void}\n         */\n        function checkExpressionOrExportStatement(node) {\n            const firstToken = isParenthesised(node) ? sourceCode.getTokenBefore(node) : sourceCode.getFirstToken(node);\n            const secondToken = sourceCode.getTokenAfter(firstToken, astUtils.isNotOpeningParenToken);\n            const thirdToken = secondToken ? sourceCode.getTokenAfter(secondToken) : null;\n\n            if (\n                astUtils.isOpeningParenToken(firstToken) &&\n                (\n                    astUtils.isOpeningBraceToken(secondToken) ||\n                    secondToken.type === \"Keyword\" && (\n                        secondToken.value === \"function\" ||\n                        secondToken.value === \"class\" ||\n                        secondToken.value === \"let\" && astUtils.isOpeningBracketToken(sourceCode.getTokenAfter(secondToken, astUtils.isNotClosingParenToken))\n                    ) ||\n                    secondToken && secondToken.type === \"Identifier\" && secondToken.value === \"async\" && thirdToken && thirdToken.type === \"Keyword\" && thirdToken.value === \"function\"\n                )\n            ) {\n                tokensToIgnore.add(secondToken);\n            }\n\n            if (hasExcessParens(node)) {\n                report(node);\n            }\n        }\n\n        return {\n            ArrayExpression(node) {\n                node.elements\n                    .filter(e => e && hasExcessParens(e) && precedence(e) >= PRECEDENCE_OF_ASSIGNMENT_EXPR)\n                    .forEach(report);\n            },\n\n            ArrowFunctionExpression(node) {\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                if (node.body.type === \"ConditionalExpression\" &&\n                    IGNORE_ARROW_CONDITIONALS &&\n                    !isParenthesisedTwice(node.body)\n                ) {\n                    return;\n                }\n\n                if (node.body.type !== \"BlockStatement\") {\n                    const firstBodyToken = sourceCode.getFirstToken(node.body, astUtils.isNotOpeningParenToken);\n                    const tokenBeforeFirst = sourceCode.getTokenBefore(firstBodyToken);\n\n                    if (astUtils.isOpeningParenToken(tokenBeforeFirst) && astUtils.isOpeningBraceToken(firstBodyToken)) {\n                        tokensToIgnore.add(firstBodyToken);\n                    }\n                    if (hasExcessParens(node.body) && precedence(node.body) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n                        report(node.body);\n                    }\n                }\n            },\n\n            AssignmentExpression(node) {\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                if (hasExcessParens(node.right) && precedence(node.right) >= precedence(node)) {\n                    report(node.right);\n                }\n            },\n\n            BinaryExpression: checkBinaryLogical,\n            CallExpression: checkCallNew,\n\n            ConditionalExpression(node) {\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                if (hasExcessParens(node.test) && precedence(node.test) >= precedence({ type: \"LogicalExpression\", operator: \"||\" })) {\n                    report(node.test);\n                }\n\n                if (hasExcessParens(node.consequent) && precedence(node.consequent) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n                    report(node.consequent);\n                }\n\n                if (hasExcessParens(node.alternate) && precedence(node.alternate) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n                    report(node.alternate);\n                }\n            },\n\n            DoWhileStatement(node) {\n                if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n            },\n\n            ExportDefaultDeclaration: node => checkExpressionOrExportStatement(node.declaration),\n            ExpressionStatement: node => checkExpressionOrExportStatement(node.expression),\n\n            \"ForInStatement, ForOfStatement\"(node) {\n                if (node.left.type !== \"VariableDeclarator\") {\n                    const firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);\n\n                    if (\n                        firstLeftToken.value === \"let\" && (\n\n                            // If `let` is the only thing on the left side of the loop, it's the loop variable: `for ((let) of foo);`\n                            // Removing it will cause a syntax error, because it will be parsed as the start of a VariableDeclarator.\n                            firstLeftToken.range[1] === node.left.range[1] ||\n\n                            // If `let` is followed by a `[` token, it's a property access on the `let` value: `for ((let[foo]) of bar);`\n                            // Removing it will cause the property access to be parsed as a destructuring declaration of `foo` instead.\n                            astUtils.isOpeningBracketToken(\n                                sourceCode.getTokenAfter(firstLeftToken, astUtils.isNotClosingParenToken)\n                            )\n                        )\n                    ) {\n                        tokensToIgnore.add(firstLeftToken);\n                    }\n                }\n                if (hasExcessParens(node.right)) {\n                    report(node.right);\n                }\n                if (hasExcessParens(node.left)) {\n                    report(node.left);\n                }\n            },\n\n            ForStatement(node) {\n                if (node.init && hasExcessParens(node.init)) {\n                    report(node.init);\n                }\n\n                if (node.test && hasExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n\n                if (node.update && hasExcessParens(node.update)) {\n                    report(node.update);\n                }\n            },\n\n            IfStatement(node) {\n                if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n            },\n\n            LogicalExpression: checkBinaryLogical,\n\n            MemberExpression(node) {\n                const nodeObjHasExcessParens = hasExcessParens(node.object);\n\n                if (\n                    nodeObjHasExcessParens &&\n                    precedence(node.object) >= precedence(node) &&\n                    (\n                        node.computed ||\n                        !(\n                            astUtils.isDecimalInteger(node.object) ||\n\n                            // RegExp literal is allowed to have parens (#1589)\n                            (node.object.type === \"Literal\" && node.object.regex)\n                        )\n                    )\n                ) {\n                    report(node.object);\n                }\n\n                if (nodeObjHasExcessParens &&\n                  node.object.type === \"CallExpression\" &&\n                  node.parent.type !== \"NewExpression\") {\n                    report(node.object);\n                }\n\n                if (node.computed && hasExcessParens(node.property)) {\n                    report(node.property);\n                }\n            },\n\n            NewExpression: checkCallNew,\n\n            ObjectExpression(node) {\n                node.properties\n                    .filter(property => {\n                        const value = property.value;\n\n                        return value && hasExcessParens(value) && precedence(value) >= PRECEDENCE_OF_ASSIGNMENT_EXPR;\n                    }).forEach(property => report(property.value));\n            },\n\n            ReturnStatement(node) {\n                const returnToken = sourceCode.getFirstToken(node);\n\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                if (node.argument &&\n                        hasExcessParensNoLineTerminator(returnToken, node.argument) &&\n\n                        // RegExp literal is allowed to have parens (#1589)\n                        !(node.argument.type === \"Literal\" && node.argument.regex)) {\n                    report(node.argument);\n                }\n            },\n\n            SequenceExpression(node) {\n                node.expressions\n                    .filter(e => hasExcessParens(e) && precedence(e) >= precedence(node))\n                    .forEach(report);\n            },\n\n            SwitchCase(node) {\n                if (node.test && hasExcessParens(node.test)) {\n                    report(node.test);\n                }\n            },\n\n            SwitchStatement(node) {\n                if (hasDoubleExcessParens(node.discriminant)) {\n                    report(node.discriminant);\n                }\n            },\n\n            ThrowStatement(node) {\n                const throwToken = sourceCode.getFirstToken(node);\n\n                if (hasExcessParensNoLineTerminator(throwToken, node.argument)) {\n                    report(node.argument);\n                }\n            },\n\n            UnaryExpression: checkUnaryUpdate,\n            UpdateExpression: checkUnaryUpdate,\n            AwaitExpression: checkUnaryUpdate,\n\n            VariableDeclarator(node) {\n                if (node.init && hasExcessParens(node.init) &&\n                        precedence(node.init) >= PRECEDENCE_OF_ASSIGNMENT_EXPR &&\n\n                        // RegExp literal is allowed to have parens (#1589)\n                        !(node.init.type === \"Literal\" && node.init.regex)) {\n                    report(node.init);\n                }\n            },\n\n            WhileStatement(node) {\n                if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n            },\n\n            WithStatement(node) {\n                if (hasDoubleExcessParens(node.object)) {\n                    report(node.object);\n                }\n            },\n\n            YieldExpression(node) {\n                if (node.argument) {\n                    const yieldToken = sourceCode.getFirstToken(node);\n\n                    if ((precedence(node.argument) >= precedence(node) &&\n                            hasExcessParensNoLineTerminator(yieldToken, node.argument)) ||\n                            hasDoubleExcessParens(node.argument)) {\n                        report(node.argument);\n                    }\n                }\n            },\n\n            ClassDeclaration: checkClass,\n            ClassExpression: checkClass,\n\n            SpreadElement: checkSpreadOperator,\n            SpreadProperty: checkSpreadOperator,\n            ExperimentalSpreadProperty: checkSpreadOperator\n        };\n\n    }\n};\n","no-extra-semi.js":"/**\n * @fileoverview Rule to flag use of unnecessary semicolons\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst FixTracker = require(\"../util/fix-tracker\");\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary semicolons\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        fixable: \"code\",\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports an unnecessary semicolon error.\n         * @param {Node|Token} nodeOrToken - A node or a token to be reported.\n         * @returns {void}\n         */\n        function report(nodeOrToken) {\n            context.report({\n                node: nodeOrToken,\n                message: \"Unnecessary semicolon.\",\n                fix(fixer) {\n\n                    // Expand the replacement range to include the surrounding\n                    // tokens to avoid conflicting with semi.\n                    // https://github.com/eslint/eslint/issues/7928\n                    return new FixTracker(fixer, context.getSourceCode())\n                        .retainSurroundingTokens(nodeOrToken)\n                        .remove(nodeOrToken);\n                }\n            });\n        }\n\n        /**\n         * Checks for a part of a class body.\n         * This checks tokens from a specified token to a next MethodDefinition or the end of class body.\n         *\n         * @param {Token} firstToken - The first token to check.\n         * @returns {void}\n         */\n        function checkForPartOfClassBody(firstToken) {\n            for (let token = firstToken;\n                token.type === \"Punctuator\" && !astUtils.isClosingBraceToken(token);\n                token = sourceCode.getTokenAfter(token)\n            ) {\n                if (astUtils.isSemicolonToken(token)) {\n                    report(token);\n                }\n            }\n        }\n\n        return {\n\n            /**\n             * Reports this empty statement, except if the parent node is a loop.\n             * @param {Node} node - A EmptyStatement node to be reported.\n             * @returns {void}\n             */\n            EmptyStatement(node) {\n                const parent = node.parent,\n                    allowedParentTypes = [\n                        \"ForStatement\",\n                        \"ForInStatement\",\n                        \"ForOfStatement\",\n                        \"WhileStatement\",\n                        \"DoWhileStatement\",\n                        \"IfStatement\",\n                        \"LabeledStatement\",\n                        \"WithStatement\"\n                    ];\n\n                if (allowedParentTypes.indexOf(parent.type) === -1) {\n                    report(node);\n                }\n            },\n\n            /**\n             * Checks tokens from the head of this class body to the first MethodDefinition or the end of this class body.\n             * @param {Node} node - A ClassBody node to check.\n             * @returns {void}\n             */\n            ClassBody(node) {\n                checkForPartOfClassBody(sourceCode.getFirstToken(node, 1)); // 0 is `{`.\n            },\n\n            /**\n             * Checks tokens from this MethodDefinition to the next MethodDefinition or the end of this class body.\n             * @param {Node} node - A MethodDefinition node of the start point.\n             * @returns {void}\n             */\n            MethodDefinition(node) {\n                checkForPartOfClassBody(sourceCode.getTokenAfter(node));\n            }\n        };\n\n    }\n};\n","no-fallthrough.js":"/**\n * @fileoverview Rule to flag fall-through cases in switch statements.\n * @author Matt DuVall <http://mattduvall.com/>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_FALLTHROUGH_COMMENT = /falls?\\s?through/i;\n\n/**\n * Checks whether or not a given node has a fallthrough comment.\n * @param {ASTNode} node - A SwitchCase node to get comments.\n * @param {RuleContext} context - A rule context which stores comments.\n * @param {RegExp} fallthroughCommentPattern - A pattern to match comment to.\n * @returns {boolean} `true` if the node has a valid fallthrough comment.\n */\nfunction hasFallthroughComment(node, context, fallthroughCommentPattern) {\n    const sourceCode = context.getSourceCode();\n    const comment = lodash.last(sourceCode.getCommentsBefore(node));\n\n    return Boolean(comment && fallthroughCommentPattern.test(comment.value));\n}\n\n/**\n * Checks whether or not a given code path segment is reachable.\n * @param {CodePathSegment} segment - A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Checks whether a node and a token are separated by blank lines\n * @param {ASTNode} node - The node to check\n * @param {Token} token - The token to compare against\n * @returns {boolean} `true` if there are blank lines between node and token\n */\nfunction hasBlankLinesBetween(node, token) {\n    return token.loc.start.line > node.loc.end.line + 1;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow fallthrough of `case` statements\",\n            category: \"Best Practices\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    commentPattern: {\n                        type: \"string\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        let currentCodePath = null;\n        const sourceCode = context.getSourceCode();\n\n        /*\n         * We need to use leading comments of the next SwitchCase node because\n         * trailing comments is wrong if semicolons are omitted.\n         */\n        let fallthroughCase = null;\n        let fallthroughCommentPattern = null;\n\n        if (options.commentPattern) {\n            fallthroughCommentPattern = new RegExp(options.commentPattern);\n        } else {\n            fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;\n        }\n\n        return {\n            onCodePathStart(codePath) {\n                currentCodePath = codePath;\n            },\n            onCodePathEnd() {\n                currentCodePath = currentCodePath.upper;\n            },\n\n            SwitchCase(node) {\n\n                /*\n                 * Checks whether or not there is a fallthrough comment.\n                 * And reports the previous fallthrough node if that does not exist.\n                 */\n                if (fallthroughCase && !hasFallthroughComment(node, context, fallthroughCommentPattern)) {\n                    context.report({\n                        message: \"Expected a 'break' statement before '{{type}}'.\",\n                        data: { type: node.test ? \"case\" : \"default\" },\n                        node\n                    });\n                }\n                fallthroughCase = null;\n            },\n\n            \"SwitchCase:exit\"(node) {\n                const nextToken = sourceCode.getTokenAfter(node);\n\n                /*\n                 * `reachable` meant fall through because statements preceded by\n                 * `break`, `return`, or `throw` are unreachable.\n                 * And allows empty cases and the last case.\n                 */\n                if (currentCodePath.currentSegments.some(isReachable) &&\n                    (node.consequent.length > 0 || hasBlankLinesBetween(node, nextToken)) &&\n                    lodash.last(node.parent.cases) !== node) {\n                    fallthroughCase = node;\n                }\n            }\n        };\n    }\n};\n","no-floating-decimal.js":"/**\n * @fileoverview Rule to flag use of a leading/trailing decimal point in a numeric literal\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow leading or trailing decimal points in numeric literals\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            Literal(node) {\n\n                if (typeof node.value === \"number\") {\n                    if (node.raw.startsWith(\".\")) {\n                        context.report({\n                            node,\n                            message: \"A leading decimal point can be confused with a dot.\",\n                            fix(fixer) {\n                                const tokenBefore = sourceCode.getTokenBefore(node);\n                                const needsSpaceBefore = tokenBefore &&\n                                    tokenBefore.range[1] === node.range[0] &&\n                                    !astUtils.canTokensBeAdjacent(tokenBefore, `0${node.raw}`);\n\n                                return fixer.insertTextBefore(node, needsSpaceBefore ? \" 0\" : \"0\");\n                            }\n                        });\n                    }\n                    if (node.raw.indexOf(\".\") === node.raw.length - 1) {\n                        context.report({\n                            node,\n                            message: \"A trailing decimal point can be confused with a dot.\",\n                            fix: fixer => fixer.insertTextAfter(node, \"0\")\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","no-func-assign.js":"/**\n * @fileoverview Rule to flag use of function declaration identifiers as variables.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow reassigning `function` declarations\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Reports a reference if is non initializer and writable.\n         * @param {References} references - Collection of reference to check.\n         * @returns {void}\n         */\n        function checkReference(references) {\n            astUtils.getModifyingReferences(references).forEach(reference => {\n                context.report({ node: reference.identifier, message: \"'{{name}}' is a function.\", data: { name: reference.identifier.name } });\n            });\n        }\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {Variable} variable - A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            if (variable.defs[0].type === \"FunctionName\") {\n                checkReference(variable.references);\n            }\n        }\n\n        /**\n         * Checks parameters of a given function node.\n         * @param {ASTNode} node - A function node to check.\n         * @returns {void}\n         */\n        function checkForFunction(node) {\n            context.getDeclaredVariables(node).forEach(checkVariable);\n        }\n\n        return {\n            FunctionDeclaration: checkForFunction,\n            FunctionExpression: checkForFunction\n        };\n    }\n};\n","no-global-assign.js":"/**\n * @fileoverview Rule to disallow assignments to native objects or read-only global variables\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow assignments to native objects or read-only global variables\",\n            category: \"Best Practices\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: { type: \"string\" },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const config = context.options[0];\n        const exceptions = (config && config.exceptions) || [];\n\n        /**\n         * Reports write references.\n         * @param {Reference} reference - A reference to check.\n         * @param {int} index - The index of the reference in the references.\n         * @param {Reference[]} references - The array that the reference belongs to.\n         * @returns {void}\n         */\n        function checkReference(reference, index, references) {\n            const identifier = reference.identifier;\n\n            if (reference.init === false &&\n                reference.isWrite() &&\n\n                // Destructuring assignments can have multiple default value,\n                // so possibly there are multiple writeable references for the same identifier.\n                (index === 0 || references[index - 1].identifier !== identifier)\n            ) {\n                context.report({\n                    node: identifier,\n                    message: \"Read-only global '{{name}}' should not be modified.\",\n                    data: identifier\n                });\n            }\n        }\n\n        /**\n         * Reports write references if a given variable is read-only builtin.\n         * @param {Variable} variable - A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            if (variable.writeable === false && exceptions.indexOf(variable.name) === -1) {\n                variable.references.forEach(checkReference);\n            }\n        }\n\n        return {\n            Program() {\n                const globalScope = context.getScope();\n\n                globalScope.variables.forEach(checkVariable);\n            }\n        };\n    }\n};\n","no-implicit-coercion.js":"/**\n * @fileoverview A rule to disallow the type conversions with shorter notations.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/;\nconst ALLOWABLE_OPERATORS = [\"~\", \"!!\", \"+\", \"*\"];\n\n/**\n * Parses and normalizes an option object.\n * @param {Object} options - An option object to parse.\n * @returns {Object} The parsed and normalized option object.\n */\nfunction parseOptions(options) {\n    options = options || {};\n    return {\n        boolean: \"boolean\" in options ? Boolean(options.boolean) : true,\n        number: \"number\" in options ? Boolean(options.number) : true,\n        string: \"string\" in options ? Boolean(options.string) : true,\n        allow: options.allow || []\n    };\n}\n\n/**\n * Checks whether or not a node is a double logical nigating.\n * @param {ASTNode} node - An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a double logical nigating.\n */\nfunction isDoubleLogicalNegating(node) {\n    return (\n        node.operator === \"!\" &&\n        node.argument.type === \"UnaryExpression\" &&\n        node.argument.operator === \"!\"\n    );\n}\n\n/**\n * Checks whether or not a node is a binary negating of `.indexOf()` method calling.\n * @param {ASTNode} node - An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a binary negating of `.indexOf()` method calling.\n */\nfunction isBinaryNegatingOfIndexOf(node) {\n    return (\n        node.operator === \"~\" &&\n        node.argument.type === \"CallExpression\" &&\n        node.argument.callee.type === \"MemberExpression\" &&\n        node.argument.callee.property.type === \"Identifier\" &&\n        INDEX_OF_PATTERN.test(node.argument.callee.property.name)\n    );\n}\n\n/**\n * Checks whether or not a node is a multiplying by one.\n * @param {BinaryExpression} node - A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a multiplying by one.\n */\nfunction isMultiplyByOne(node) {\n    return node.operator === \"*\" && (\n        node.left.type === \"Literal\" && node.left.value === 1 ||\n        node.right.type === \"Literal\" && node.right.value === 1\n    );\n}\n\n/**\n * Checks whether the result of a node is numeric or not\n * @param {ASTNode} node The node to test\n * @returns {boolean} true if the node is a number literal or a `Number()`, `parseInt` or `parseFloat` call\n */\nfunction isNumeric(node) {\n    return (\n        node.type === \"Literal\" && typeof node.value === \"number\" ||\n        node.type === \"CallExpression\" && (\n            node.callee.name === \"Number\" ||\n            node.callee.name === \"parseInt\" ||\n            node.callee.name === \"parseFloat\"\n        )\n    );\n}\n\n/**\n * Returns the first non-numeric operand in a BinaryExpression. Designed to be\n * used from bottom to up since it walks up the BinaryExpression trees using\n * node.parent to find the result.\n * @param {BinaryExpression} node The BinaryExpression node to be walked up on\n * @returns {ASTNode|null} The first non-numeric item in the BinaryExpression tree or null\n */\nfunction getNonNumericOperand(node) {\n    const left = node.left,\n        right = node.right;\n\n    if (right.type !== \"BinaryExpression\" && !isNumeric(right)) {\n        return right;\n    }\n\n    if (left.type !== \"BinaryExpression\" && !isNumeric(left)) {\n        return left;\n    }\n\n    return null;\n}\n\n/**\n * Checks whether a node is an empty string literal or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} Whether or not the passed in node is an\n * empty string literal or not.\n */\nfunction isEmptyString(node) {\n    return astUtils.isStringLiteral(node) && (node.value === \"\" || (node.type === \"TemplateLiteral\" && node.quasis.length === 1 && node.quasis[0].value.cooked === \"\"));\n}\n\n/**\n * Checks whether or not a node is a concatenating with an empty string.\n * @param {ASTNode} node - A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a concatenating with an empty string.\n */\nfunction isConcatWithEmptyString(node) {\n    return node.operator === \"+\" && (\n        (isEmptyString(node.left) && !astUtils.isStringLiteral(node.right)) ||\n        (isEmptyString(node.right) && !astUtils.isStringLiteral(node.left))\n    );\n}\n\n/**\n * Checks whether or not a node is appended with an empty string.\n * @param {ASTNode} node - An AssignmentExpression node to check.\n * @returns {boolean} Whether or not the node is appended with an empty string.\n */\nfunction isAppendEmptyString(node) {\n    return node.operator === \"+=\" && isEmptyString(node.right);\n}\n\n/**\n * Returns the operand that is not an empty string from a flagged BinaryExpression.\n * @param {ASTNode} node - The flagged BinaryExpression node to check.\n * @returns {ASTNode} The operand that is not an empty string from a flagged BinaryExpression.\n */\nfunction getNonEmptyOperand(node) {\n    return isEmptyString(node.left) ? node.right : node.left;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow shorthand type conversions\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        fixable: \"code\",\n        schema: [{\n            type: \"object\",\n            properties: {\n                boolean: {\n                    type: \"boolean\"\n                },\n                number: {\n                    type: \"boolean\"\n                },\n                string: {\n                    type: \"boolean\"\n                },\n                allow: {\n                    type: \"array\",\n                    items: {\n                        enum: ALLOWABLE_OPERATORS\n                    },\n                    uniqueItems: true\n                }\n            },\n            additionalProperties: false\n        }]\n    },\n\n    create(context) {\n        const options = parseOptions(context.options[0]);\n        const sourceCode = context.getSourceCode();\n\n        /**\n        * Reports an error and autofixes the node\n        * @param {ASTNode} node - An ast node to report the error on.\n        * @param {string} recommendation - The recommended code for the issue\n        * @param {bool} shouldFix - Whether this report should fix the node\n        * @returns {void}\n        */\n        function report(node, recommendation, shouldFix) {\n            shouldFix = typeof shouldFix === \"undefined\" ? true : shouldFix;\n\n            context.report({\n                node,\n                message: \"use `{{recommendation}}` instead.\",\n                data: {\n                    recommendation\n                },\n                fix(fixer) {\n                    if (!shouldFix) {\n                        return null;\n                    }\n\n                    const tokenBefore = sourceCode.getTokenBefore(node);\n\n                    if (\n                        tokenBefore &&\n                        tokenBefore.range[1] === node.range[0] &&\n                        !astUtils.canTokensBeAdjacent(tokenBefore, recommendation)\n                    ) {\n                        return fixer.replaceText(node, ` ${recommendation}`);\n                    }\n                    return fixer.replaceText(node, recommendation);\n                }\n            });\n        }\n\n        return {\n            UnaryExpression(node) {\n                let operatorAllowed;\n\n                // !!foo\n                operatorAllowed = options.allow.indexOf(\"!!\") >= 0;\n                if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) {\n                    const recommendation = `Boolean(${sourceCode.getText(node.argument.argument)})`;\n\n                    report(node, recommendation);\n                }\n\n                // ~foo.indexOf(bar)\n                operatorAllowed = options.allow.indexOf(\"~\") >= 0;\n                if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) {\n                    const recommendation = `${sourceCode.getText(node.argument)} !== -1`;\n\n                    report(node, recommendation, false);\n                }\n\n                // +foo\n                operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n                if (!operatorAllowed && options.number && node.operator === \"+\" && !isNumeric(node.argument)) {\n                    const recommendation = `Number(${sourceCode.getText(node.argument)})`;\n\n                    report(node, recommendation);\n                }\n            },\n\n            // Use `:exit` to prevent double reporting\n            \"BinaryExpression:exit\"(node) {\n                let operatorAllowed;\n\n                // 1 * foo\n                operatorAllowed = options.allow.indexOf(\"*\") >= 0;\n                const nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && getNonNumericOperand(node);\n\n                if (nonNumericOperand) {\n                    const recommendation = `Number(${sourceCode.getText(nonNumericOperand)})`;\n\n                    report(node, recommendation);\n                }\n\n                // \"\" + foo\n                operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n                if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) {\n                    const recommendation = `String(${sourceCode.getText(getNonEmptyOperand(node))})`;\n\n                    report(node, recommendation);\n                }\n            },\n\n            AssignmentExpression(node) {\n\n                // foo += \"\"\n                const operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n\n                if (!operatorAllowed && options.string && isAppendEmptyString(node)) {\n                    const code = sourceCode.getText(getNonEmptyOperand(node));\n                    const recommendation = `${code} = String(${code})`;\n\n                    report(node, recommendation);\n                }\n            }\n        };\n    }\n};\n","no-implicit-globals.js":"/**\n * @fileoverview Rule to check for implicit global variables and functions.\n * @author Joshua Peek\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow variable and `function` declarations in the global scope\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        return {\n            Program() {\n                const scope = context.getScope();\n\n                scope.variables.forEach(variable => {\n                    if (variable.writeable) {\n                        return;\n                    }\n\n                    variable.defs.forEach(def => {\n                        if (def.type === \"FunctionName\" || (def.type === \"Variable\" && def.parent.kind === \"var\")) {\n                            context.report({ node: def.node, message: \"Implicit global variable, assign as global property instead.\" });\n                        }\n                    });\n                });\n\n                scope.implicit.variables.forEach(variable => {\n                    const scopeVariable = scope.set.get(variable.name);\n\n                    if (scopeVariable && scopeVariable.writeable) {\n                        return;\n                    }\n\n                    variable.defs.forEach(def => {\n                        context.report({ node: def.node, message: \"Implicit global variable, assign as global property instead.\" });\n                    });\n                });\n            }\n        };\n\n    }\n};\n","no-implied-eval.js":"/**\n * @fileoverview Rule to flag use of implied eval via setTimeout and setInterval\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of `eval()`-like methods\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const CALLEE_RE = /^(setTimeout|setInterval|execScript)$/;\n\n        /*\n         * Figures out if we should inspect a given binary expression. Is a stack\n         * of stacks, where the first element in each substack is a CallExpression.\n         */\n        const impliedEvalAncestorsStack = [];\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Get the last element of an array, without modifying arr, like pop(), but non-destructive.\n         * @param {array} arr What to inspect\n         * @returns {*} The last element of arr\n         * @private\n         */\n        function last(arr) {\n            return arr ? arr[arr.length - 1] : null;\n        }\n\n        /**\n         * Checks if the given MemberExpression node is a potentially implied eval identifier on window.\n         * @param {ASTNode} node The MemberExpression node to check.\n         * @returns {boolean} Whether or not the given node is potentially an implied eval.\n         * @private\n         */\n        function isImpliedEvalMemberExpression(node) {\n            const object = node.object,\n                property = node.property,\n                hasImpliedEvalName = CALLEE_RE.test(property.name) || CALLEE_RE.test(property.value);\n\n            return object.name === \"window\" && hasImpliedEvalName;\n        }\n\n        /**\n         * Determines if a node represents a call to a potentially implied eval.\n         *\n         * This checks the callee name and that there's an argument, but not the type of the argument.\n         *\n         * @param {ASTNode} node The CallExpression to check.\n         * @returns {boolean} True if the node matches, false if not.\n         * @private\n         */\n        function isImpliedEvalCallExpression(node) {\n            const isMemberExpression = (node.callee.type === \"MemberExpression\"),\n                isIdentifier = (node.callee.type === \"Identifier\"),\n                isImpliedEvalCallee =\n                    (isIdentifier && CALLEE_RE.test(node.callee.name)) ||\n                    (isMemberExpression && isImpliedEvalMemberExpression(node.callee));\n\n            return isImpliedEvalCallee && node.arguments.length;\n        }\n\n        /**\n         * Checks that the parent is a direct descendent of an potential implied eval CallExpression, and if the parent is a CallExpression, that we're the first argument.\n         * @param {ASTNode} node The node to inspect the parent of.\n         * @returns {boolean} Was the parent a direct descendent, and is the child therefore potentially part of a dangerous argument?\n         * @private\n         */\n        function hasImpliedEvalParent(node) {\n\n            // make sure our parent is marked\n            return node.parent === last(last(impliedEvalAncestorsStack)) &&\n\n                // if our parent is a CallExpression, make sure we're the first argument\n                (node.parent.type !== \"CallExpression\" || node === node.parent.arguments[0]);\n        }\n\n        /**\n         * Checks if our parent is marked as part of an implied eval argument. If\n         * so, collapses the top of impliedEvalAncestorsStack and reports on the\n         * original CallExpression.\n         * @param {ASTNode} node The CallExpression to check.\n         * @returns {boolean} True if the node matches, false if not.\n         * @private\n         */\n        function checkString(node) {\n            if (hasImpliedEvalParent(node)) {\n\n                // remove the entire substack, to avoid duplicate reports\n                const substack = impliedEvalAncestorsStack.pop();\n\n                context.report({ node: substack[0], message: \"Implied eval. Consider passing a function instead of a string.\" });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            CallExpression(node) {\n                if (isImpliedEvalCallExpression(node)) {\n\n                    // call expressions create a new substack\n                    impliedEvalAncestorsStack.push([node]);\n                }\n            },\n\n            \"CallExpression:exit\"(node) {\n                if (node === last(last(impliedEvalAncestorsStack))) {\n\n                    /* Destroys the entire sub-stack, rather than just using\n                     * last(impliedEvalAncestorsStack).pop(), as a CallExpression is\n                     * always the bottom of a impliedEvalAncestorsStack substack.\n                     */\n                    impliedEvalAncestorsStack.pop();\n                }\n            },\n\n            BinaryExpression(node) {\n                if (node.operator === \"+\" && hasImpliedEvalParent(node)) {\n                    last(impliedEvalAncestorsStack).push(node);\n                }\n            },\n\n            \"BinaryExpression:exit\"(node) {\n                if (node === last(last(impliedEvalAncestorsStack))) {\n                    last(impliedEvalAncestorsStack).pop();\n                }\n            },\n\n            Literal(node) {\n                if (typeof node.value === \"string\") {\n                    checkString(node);\n                }\n            },\n\n            TemplateLiteral(node) {\n                checkString(node);\n            }\n        };\n\n    }\n};\n","no-inline-comments.js":"/**\n * @fileoverview Enforces or disallows inline comments.\n * @author Greg Cochard\n */\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow inline comments after code\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Will check that comments are not on lines starting with or ending with code\n         * @param {ASTNode} node The comment node to check\n         * @private\n         * @returns {void}\n         */\n        function testCodeAroundComment(node) {\n\n            // Get the whole line and cut it off at the start of the comment\n            const startLine = String(sourceCode.lines[node.loc.start.line - 1]);\n            const endLine = String(sourceCode.lines[node.loc.end.line - 1]);\n\n            const preamble = startLine.slice(0, node.loc.start.column).trim();\n\n            // Also check after the comment\n            const postamble = endLine.slice(node.loc.end.column).trim();\n\n            // Check that this comment isn't an ESLint directive\n            const isDirective = astUtils.isDirectiveComment(node);\n\n            // Should be empty if there was only whitespace around the comment\n            if (!isDirective && (preamble || postamble)) {\n                context.report({ node, message: \"Unexpected comment inline with code.\" });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments.filter(token => token.type !== \"Shebang\").forEach(testCodeAroundComment);\n            }\n        };\n    }\n};\n","no-inner-declarations.js":"/**\n * @fileoverview Rule to enforce declarations in program or function body root.\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow variable or `function` declarations in nested blocks\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                enum: [\"functions\", \"both\"]\n            }\n        ]\n    },\n\n    create(context) {\n\n        /**\n         * Find the nearest Program or Function ancestor node.\n         * @returns {Object} Ancestor's type and distance from node.\n         */\n        function nearestBody() {\n            const ancestors = context.getAncestors();\n            let ancestor = ancestors.pop(),\n                generation = 1;\n\n            while (ancestor && [\"Program\", \"FunctionDeclaration\",\n                \"FunctionExpression\", \"ArrowFunctionExpression\"\n            ].indexOf(ancestor.type) < 0) {\n                generation += 1;\n                ancestor = ancestors.pop();\n            }\n\n            return {\n\n                // Type of containing ancestor\n                type: ancestor.type,\n\n                // Separation between ancestor and node\n                distance: generation\n            };\n        }\n\n        /**\n         * Ensure that a given node is at a program or function body's root.\n         * @param {ASTNode} node Declaration node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            const body = nearestBody(),\n                valid = ((body.type === \"Program\" && body.distance === 1) ||\n                    body.distance === 2);\n\n            if (!valid) {\n                context.report({\n                    node,\n                    message: \"Move {{type}} declaration to {{body}} root.\",\n                    data: {\n                        type: (node.type === \"FunctionDeclaration\" ? \"function\" : \"variable\"),\n                        body: (body.type === \"Program\" ? \"program\" : \"function body\")\n                    }\n                });\n            }\n        }\n\n        return {\n\n            FunctionDeclaration: check,\n            VariableDeclaration(node) {\n                if (context.options[0] === \"both\" && node.kind === \"var\") {\n                    check(node);\n                }\n            }\n\n        };\n\n    }\n};\n","no-invalid-regexp.js":"/**\n * @fileoverview Validate strings passed to the RegExp constructor\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst espree = require(\"espree\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow invalid regular expression strings in `RegExp` constructors\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                allowConstructorFlags: {\n                    type: \"array\",\n                    items: {\n                        type: \"string\"\n                    }\n                }\n            },\n            additionalProperties: false\n        }]\n    },\n\n    create(context) {\n\n        const options = context.options[0];\n        let allowedFlags = \"\";\n\n        if (options && options.allowConstructorFlags) {\n            allowedFlags = options.allowConstructorFlags.join(\"\");\n        }\n\n        /**\n         * Check if node is a string\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} True if its a string\n         * @private\n         */\n        function isString(node) {\n            return node && node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        /**\n         * Validate strings passed to the RegExp constructor\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function check(node) {\n            if (node.callee.type === \"Identifier\" && node.callee.name === \"RegExp\" && isString(node.arguments[0])) {\n                let flags = isString(node.arguments[1]) ? node.arguments[1].value : \"\";\n\n                if (allowedFlags) {\n                    flags = flags.replace(new RegExp(`[${allowedFlags}]`, \"gi\"), \"\");\n                }\n\n                try {\n                    void new RegExp(node.arguments[0].value);\n                } catch (e) {\n                    context.report({\n                        node,\n                        message: \"{{message}}.\",\n                        data: e\n                    });\n                }\n\n                if (flags) {\n\n                    try {\n                        espree.parse(`/./${flags}`, context.parserOptions);\n                    } catch (ex) {\n                        context.report({\n                            node,\n                            message: \"Invalid flags supplied to RegExp constructor '{{flags}}'.\",\n                            data: {\n                                flags\n                            }\n                        });\n                    }\n                }\n\n            }\n        }\n\n        return {\n            CallExpression: check,\n            NewExpression: check\n        };\n\n    }\n};\n","no-invalid-this.js":"/**\n * @fileoverview A rule to disallow `this` keywords outside of classes or class-like objects.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `this` keywords outside of classes or class-like objects\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const stack = [],\n            sourceCode = context.getSourceCode();\n\n        /**\n         * Gets the current checking context.\n         *\n         * The return value has a flag that whether or not `this` keyword is valid.\n         * The flag is initialized when got at the first time.\n         *\n         * @returns {{valid: boolean}}\n         *   an object which has a flag that whether or not `this` keyword is valid.\n         */\n        stack.getCurrent = function() {\n            const current = this[this.length - 1];\n\n            if (!current.init) {\n                current.init = true;\n                current.valid = !astUtils.isDefaultThisBinding(\n                    current.node,\n                    sourceCode\n                );\n            }\n            return current;\n        };\n\n        /**\n         * Pushs new checking context into the stack.\n         *\n         * The checking context is not initialized yet.\n         * Because most functions don't have `this` keyword.\n         * When `this` keyword was found, the checking context is initialized.\n         *\n         * @param {ASTNode} node - A function node that was entered.\n         * @returns {void}\n         */\n        function enterFunction(node) {\n\n            // `this` can be invalid only under strict mode.\n            stack.push({\n                init: !context.getScope().isStrict,\n                node,\n                valid: true\n            });\n        }\n\n        /**\n         * Pops the current checking context from the stack.\n         * @returns {void}\n         */\n        function exitFunction() {\n            stack.pop();\n        }\n\n        return {\n\n            /*\n             * `this` is invalid only under strict mode.\n             * Modules is always strict mode.\n             */\n            Program(node) {\n                const scope = context.getScope(),\n                    features = context.parserOptions.ecmaFeatures || {};\n\n                stack.push({\n                    init: true,\n                    node,\n                    valid: !(\n                        scope.isStrict ||\n                        node.sourceType === \"module\" ||\n                        (features.globalReturn && scope.childScopes[0].isStrict)\n                    )\n                });\n            },\n\n            \"Program:exit\"() {\n                stack.pop();\n            },\n\n            FunctionDeclaration: enterFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            FunctionExpression: enterFunction,\n            \"FunctionExpression:exit\": exitFunction,\n\n            // Reports if `this` of the current context is invalid.\n            ThisExpression(node) {\n                const current = stack.getCurrent();\n\n                if (current && !current.valid) {\n                    context.report({ node, message: \"Unexpected 'this'.\" });\n                }\n            }\n        };\n    }\n};\n","no-irregular-whitespace.js":"/**\n * @fileoverview Rule to disalow whitespace that is not a tab or space, whitespace inside strings and comments are allowed\n * @author Jonathan Kingston\n * @author Christophe Porteneuve\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst ALL_IRREGULARS = /[\\f\\v\\u0085\\ufeff\\u00a0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u202f\\u205f\\u3000\\u2028\\u2029]/;\nconst IRREGULAR_WHITESPACE = /[\\f\\v\\u0085\\ufeff\\u00a0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u202f\\u205f\\u3000]+/mg;\nconst IRREGULAR_LINE_TERMINATORS = /[\\u2028\\u2029]/mg;\nconst LINE_BREAK = astUtils.createGlobalLinebreakMatcher();\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow irregular whitespace outside of strings and comments\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    skipComments: {\n                        type: \"boolean\"\n                    },\n                    skipStrings: {\n                        type: \"boolean\"\n                    },\n                    skipTemplates: {\n                        type: \"boolean\"\n                    },\n                    skipRegExps: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        // Module store of errors that we have found\n        let errors = [];\n\n        // Lookup the `skipComments` option, which defaults to `false`.\n        const options = context.options[0] || {};\n        const skipComments = !!options.skipComments;\n        const skipStrings = options.skipStrings !== false;\n        const skipRegExps = !!options.skipRegExps;\n        const skipTemplates = !!options.skipTemplates;\n\n        const sourceCode = context.getSourceCode();\n        const commentNodes = sourceCode.getAllComments();\n\n        /**\n         * Removes errors that occur inside a string node\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeWhitespaceError(node) {\n            const locStart = node.loc.start;\n            const locEnd = node.loc.end;\n\n            errors = errors.filter(error => {\n                const errorLoc = error[1];\n\n                if (errorLoc.line >= locStart.line && errorLoc.line <= locEnd.line) {\n                    if (errorLoc.column >= locStart.column && (errorLoc.column <= locEnd.column || errorLoc.line < locEnd.line)) {\n                        return false;\n                    }\n                }\n                return true;\n            });\n        }\n\n        /**\n         * Checks identifier or literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeInvalidNodeErrorsInIdentifierOrLiteral(node) {\n            const shouldCheckStrings = skipStrings && (typeof node.value === \"string\");\n            const shouldCheckRegExps = skipRegExps && (node.value instanceof RegExp);\n\n            if (shouldCheckStrings || shouldCheckRegExps) {\n\n                // If we have irregular characters remove them from the errors list\n                if (ALL_IRREGULARS.test(node.raw)) {\n                    removeWhitespaceError(node);\n                }\n            }\n        }\n\n        /**\n         * Checks template string literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeInvalidNodeErrorsInTemplateLiteral(node) {\n            if (typeof node.value.raw === \"string\") {\n                if (ALL_IRREGULARS.test(node.value.raw)) {\n                    removeWhitespaceError(node);\n                }\n            }\n        }\n\n        /**\n         * Checks comment nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeInvalidNodeErrorsInComment(node) {\n            if (ALL_IRREGULARS.test(node.value)) {\n                removeWhitespaceError(node);\n            }\n        }\n\n        /**\n         * Checks the program source for irregular whitespace\n         * @param {ASTNode} node The program node\n         * @returns {void}\n         * @private\n         */\n        function checkForIrregularWhitespace(node) {\n            const sourceLines = sourceCode.lines;\n\n            sourceLines.forEach((sourceLine, lineIndex) => {\n                const lineNumber = lineIndex + 1;\n                let match;\n\n                while ((match = IRREGULAR_WHITESPACE.exec(sourceLine)) !== null) {\n                    const location = {\n                        line: lineNumber,\n                        column: match.index\n                    };\n\n                    errors.push([node, location, \"Irregular whitespace not allowed.\"]);\n                }\n            });\n        }\n\n        /**\n         * Checks the program source for irregular line terminators\n         * @param {ASTNode} node The program node\n         * @returns {void}\n         * @private\n         */\n        function checkForIrregularLineTerminators(node) {\n            const source = sourceCode.getText(),\n                sourceLines = sourceCode.lines,\n                linebreaks = source.match(LINE_BREAK);\n            let lastLineIndex = -1,\n                match;\n\n            while ((match = IRREGULAR_LINE_TERMINATORS.exec(source)) !== null) {\n                const lineIndex = linebreaks.indexOf(match[0], lastLineIndex + 1) || 0;\n                const location = {\n                    line: lineIndex + 1,\n                    column: sourceLines[lineIndex].length\n                };\n\n                errors.push([node, location, \"Irregular whitespace not allowed.\"]);\n                lastLineIndex = lineIndex;\n            }\n        }\n\n        /**\n         * A no-op function to act as placeholder for comment accumulation when the `skipComments` option is `false`.\n         * @returns {void}\n         * @private\n         */\n        function noop() {}\n\n        const nodes = {};\n\n        if (ALL_IRREGULARS.test(sourceCode.getText())) {\n            nodes.Program = function(node) {\n\n                /*\n                 * As we can easily fire warnings for all white space issues with\n                 * all the source its simpler to fire them here.\n                 * This means we can check all the application code without having\n                 * to worry about issues caused in the parser tokens.\n                 * When writing this code also evaluating per node was missing out\n                 * connecting tokens in some cases.\n                 * We can later filter the errors when they are found to be not an\n                 * issue in nodes we don't care about.\n                 */\n                checkForIrregularWhitespace(node);\n                checkForIrregularLineTerminators(node);\n            };\n\n            nodes.Identifier = removeInvalidNodeErrorsInIdentifierOrLiteral;\n            nodes.Literal = removeInvalidNodeErrorsInIdentifierOrLiteral;\n            nodes.TemplateElement = skipTemplates ? removeInvalidNodeErrorsInTemplateLiteral : noop;\n            nodes[\"Program:exit\"] = function() {\n                if (skipComments) {\n\n                    // First strip errors occurring in comment nodes.\n                    commentNodes.forEach(removeInvalidNodeErrorsInComment);\n                }\n\n                // If we have any errors remaining report on them\n                errors.forEach(error => {\n                    context.report.apply(context, error);\n                });\n            };\n        } else {\n            nodes.Program = noop;\n        }\n\n        return nodes;\n    }\n};\n","no-iterator.js":"/**\n * @fileoverview Rule to flag usage of __iterator__ property\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of the `__iterator__` property\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            MemberExpression(node) {\n\n                if (node.property &&\n                        (node.property.type === \"Identifier\" && node.property.name === \"__iterator__\" && !node.computed) ||\n                        (node.property.type === \"Literal\" && node.property.value === \"__iterator__\")) {\n                    context.report({ node, message: \"Reserved name '__iterator__'.\" });\n                }\n            }\n        };\n\n    }\n};\n","no-label-var.js":"/**\n * @fileoverview Rule to flag labels that are the same as an identifier\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow labels that share a name with a variable\",\n            category: \"Variables\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Check if the identifier is present inside current scope\n         * @param {Object} scope current scope\n         * @param {string} name To evaluate\n         * @returns {boolean} True if its present\n         * @private\n         */\n        function findIdentifier(scope, name) {\n            return astUtils.getVariableByName(scope, name) !== null;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n\n            LabeledStatement(node) {\n\n                // Fetch the innermost scope.\n                const scope = context.getScope();\n\n                // Recursively find the identifier walking up the scope, starting\n                // with the innermost scope.\n                if (findIdentifier(scope, node.label.name)) {\n                    context.report({ node, message: \"Found identifier with same name as label.\" });\n                }\n            }\n\n        };\n\n    }\n};\n","no-labels.js":"/**\n * @fileoverview Disallow Labeled Statements\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow labeled statements\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowLoop: {\n                        type: \"boolean\"\n                    },\n                    allowSwitch: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = context.options[0];\n        const allowLoop = Boolean(options && options.allowLoop);\n        const allowSwitch = Boolean(options && options.allowSwitch);\n        let scopeInfo = null;\n\n        /**\n         * Gets the kind of a given node.\n         *\n         * @param {ASTNode} node - A node to get.\n         * @returns {string} The kind of the node.\n         */\n        function getBodyKind(node) {\n            if (astUtils.isLoop(node)) {\n                return \"loop\";\n            }\n            if (node.type === \"SwitchStatement\") {\n                return \"switch\";\n            }\n            return \"other\";\n        }\n\n        /**\n         * Checks whether the label of a given kind is allowed or not.\n         *\n         * @param {string} kind - A kind to check.\n         * @returns {boolean} `true` if the kind is allowed.\n         */\n        function isAllowed(kind) {\n            switch (kind) {\n                case \"loop\": return allowLoop;\n                case \"switch\": return allowSwitch;\n                default: return false;\n            }\n        }\n\n        /**\n         * Checks whether a given name is a label of a loop or not.\n         *\n         * @param {string} label - A name of a label to check.\n         * @returns {boolean} `true` if the name is a label of a loop.\n         */\n        function getKind(label) {\n            let info = scopeInfo;\n\n            while (info) {\n                if (info.label === label) {\n                    return info.kind;\n                }\n                info = info.upper;\n            }\n\n            /* istanbul ignore next: syntax error */\n            return \"other\";\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            LabeledStatement(node) {\n                scopeInfo = {\n                    label: node.label.name,\n                    kind: getBodyKind(node.body),\n                    upper: scopeInfo\n                };\n            },\n\n            \"LabeledStatement:exit\"(node) {\n                if (!isAllowed(scopeInfo.kind)) {\n                    context.report({\n                        node,\n                        message: \"Unexpected labeled statement.\"\n                    });\n                }\n\n                scopeInfo = scopeInfo.upper;\n            },\n\n            BreakStatement(node) {\n                if (node.label && !isAllowed(getKind(node.label.name))) {\n                    context.report({\n                        node,\n                        message: \"Unexpected label in break statement.\"\n                    });\n                }\n            },\n\n            ContinueStatement(node) {\n                if (node.label && !isAllowed(getKind(node.label.name))) {\n                    context.report({\n                        node,\n                        message: \"Unexpected label in continue statement.\"\n                    });\n                }\n            }\n        };\n\n    }\n};\n","no-lone-blocks.js":"/**\n * @fileoverview Rule to flag blocks with no reason to exist\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary nested blocks\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        // A stack of lone blocks to be checked for block-level bindings\n        const loneBlocks = [];\n        let ruleDef;\n\n        /**\n         * Reports a node as invalid.\n         * @param {ASTNode} node - The node to be reported.\n         * @returns {void}\n        */\n        function report(node) {\n            const message = node.parent.type === \"BlockStatement\" ? \"Nested block is redundant.\" : \"Block is redundant.\";\n\n            context.report({ node, message });\n        }\n\n        /**\n         * Checks for any ocurrence of a BlockStatement in a place where lists of statements can appear\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} True if the node is a lone block.\n        */\n        function isLoneBlock(node) {\n            return node.parent.type === \"BlockStatement\" ||\n                node.parent.type === \"Program\" ||\n\n                // Don't report blocks in switch cases if the block is the only statement of the case.\n                node.parent.type === \"SwitchCase\" && !(node.parent.consequent[0] === node && node.parent.consequent.length === 1);\n        }\n\n        /**\n         * Checks the enclosing block of the current node for block-level bindings,\n         * and \"marks it\" as valid if any.\n         * @returns {void}\n        */\n        function markLoneBlock() {\n            if (loneBlocks.length === 0) {\n                return;\n            }\n\n            const block = context.getAncestors().pop();\n\n            if (loneBlocks[loneBlocks.length - 1] === block) {\n                loneBlocks.pop();\n            }\n        }\n\n        // Default rule definition: report all lone blocks\n        ruleDef = {\n            BlockStatement(node) {\n                if (isLoneBlock(node)) {\n                    report(node);\n                }\n            }\n        };\n\n        // ES6: report blocks without block-level bindings\n        if (context.parserOptions.ecmaVersion >= 6) {\n            ruleDef = {\n                BlockStatement(node) {\n                    if (isLoneBlock(node)) {\n                        loneBlocks.push(node);\n                    }\n                },\n                \"BlockStatement:exit\"(node) {\n                    if (loneBlocks.length > 0 && loneBlocks[loneBlocks.length - 1] === node) {\n                        loneBlocks.pop();\n                        report(node);\n                    }\n                }\n            };\n\n            ruleDef.VariableDeclaration = function(node) {\n                if (node.kind === \"let\" || node.kind === \"const\") {\n                    markLoneBlock();\n                }\n            };\n\n            ruleDef.FunctionDeclaration = function() {\n                if (context.getScope().isStrict) {\n                    markLoneBlock();\n                }\n            };\n\n            ruleDef.ClassDeclaration = markLoneBlock;\n        }\n\n        return ruleDef;\n    }\n};\n","no-lonely-if.js":"/**\n * @fileoverview Rule to disallow if as the only statmenet in an else block\n * @author Brandon Mills\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `if` statements as the only statement in `else` blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            IfStatement(node) {\n                const ancestors = context.getAncestors(),\n                    parent = ancestors.pop(),\n                    grandparent = ancestors.pop();\n\n                if (parent && parent.type === \"BlockStatement\" &&\n                        parent.body.length === 1 && grandparent &&\n                        grandparent.type === \"IfStatement\" &&\n                        parent === grandparent.alternate) {\n                    context.report({\n                        node,\n                        message: \"Unexpected if as the only statement in an else block.\",\n                        fix(fixer) {\n                            const openingElseCurly = sourceCode.getFirstToken(parent);\n                            const closingElseCurly = sourceCode.getLastToken(parent);\n                            const elseKeyword = sourceCode.getTokenBefore(openingElseCurly);\n                            const tokenAfterElseBlock = sourceCode.getTokenAfter(closingElseCurly);\n                            const lastIfToken = sourceCode.getLastToken(node.consequent);\n                            const sourceText = sourceCode.getText();\n\n                            if (sourceText.slice(openingElseCurly.range[1], node.range[0]).trim() || sourceText.slice(node.range[1], closingElseCurly.range[0]).trim()) {\n\n                                // Don't fix if there are any non-whitespace characters interfering (e.g. comments)\n                                return null;\n                            }\n\n                            if (\n                                node.consequent.type !== \"BlockStatement\" && lastIfToken.value !== \";\" && tokenAfterElseBlock &&\n                                (\n                                    node.consequent.loc.end.line === tokenAfterElseBlock.loc.start.line ||\n                                    /^[([/+`-]/.test(tokenAfterElseBlock.value) ||\n                                    lastIfToken.value === \"++\" ||\n                                    lastIfToken.value === \"--\"\n                                )\n                            ) {\n\n                                /*\n                                 * If the `if` statement has no block, and is not followed by a semicolon, make sure that fixing\n                                 * the issue would not change semantics due to ASI. If this would happen, don't do a fix.\n                                 */\n                                return null;\n                            }\n\n                            return fixer.replaceTextRange(\n                                [openingElseCurly.range[0], closingElseCurly.range[1]],\n                                (elseKeyword.range[1] === openingElseCurly.range[0] ? \" \" : \"\") + sourceCode.getText(node)\n                            );\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","no-loop-func.js":"/**\n * @fileoverview Rule to flag creation of function inside a loop\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets the containing loop node of a specified node.\n *\n * We don't need to check nested functions, so this ignores those.\n * `Scope.through` contains references of nested functions.\n *\n * @param {ASTNode} node - An AST node to get.\n * @returns {ASTNode|null} The containing loop node of the specified node, or\n *      `null`.\n */\nfunction getContainingLoopNode(node) {\n    let parent = node.parent;\n\n    while (parent) {\n        switch (parent.type) {\n            case \"WhileStatement\":\n            case \"DoWhileStatement\":\n                return parent;\n\n            case \"ForStatement\":\n\n                // `init` is outside of the loop.\n                if (parent.init !== node) {\n                    return parent;\n                }\n                break;\n\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n\n                // `right` is outside of the loop.\n                if (parent.right !== node) {\n                    return parent;\n                }\n                break;\n\n            case \"ArrowFunctionExpression\":\n            case \"FunctionExpression\":\n            case \"FunctionDeclaration\":\n\n                // We don't need to check nested functions.\n                return null;\n\n            default:\n                break;\n        }\n\n        node = parent;\n        parent = node.parent;\n    }\n\n    return null;\n}\n\n/**\n * Gets the containing loop node of a given node.\n * If the loop was nested, this returns the most outer loop.\n *\n * @param {ASTNode} node - A node to get. This is a loop node.\n * @param {ASTNode|null} excludedNode - A node that the result node should not\n *      include.\n * @returns {ASTNode} The most outer loop node.\n */\nfunction getTopLoopNode(node, excludedNode) {\n    let retv = node;\n    const border = excludedNode ? excludedNode.range[1] : 0;\n\n    while (node && node.range[0] >= border) {\n        retv = node;\n        node = getContainingLoopNode(node);\n    }\n\n    return retv;\n}\n\n/**\n * Checks whether a given reference which refers to an upper scope's variable is\n * safe or not.\n *\n * @param {ASTNode} loopNode - A containing loop node.\n * @param {eslint-scope.Reference} reference - A reference to check.\n * @returns {boolean} `true` if the reference is safe or not.\n */\nfunction isSafe(loopNode, reference) {\n    const variable = reference.resolved;\n    const definition = variable && variable.defs[0];\n    const declaration = definition && definition.parent;\n    const kind = (declaration && declaration.type === \"VariableDeclaration\")\n        ? declaration.kind\n        : \"\";\n\n    // Variables which are declared by `const` is safe.\n    if (kind === \"const\") {\n        return true;\n    }\n\n    // Variables which are declared by `let` in the loop is safe.\n    // It's a different instance from the next loop step's.\n    if (kind === \"let\" &&\n        declaration.range[0] > loopNode.range[0] &&\n        declaration.range[1] < loopNode.range[1]\n    ) {\n        return true;\n    }\n\n    // WriteReferences which exist after this border are unsafe because those\n    // can modify the variable.\n    const border = getTopLoopNode(\n        loopNode,\n        (kind === \"let\") ? declaration : null\n    ).range[0];\n\n    /**\n     * Checks whether a given reference is safe or not.\n     * The reference is every reference of the upper scope's variable we are\n     * looking now.\n     *\n     * It's safeafe if the reference matches one of the following condition.\n     * - is readonly.\n     * - doesn't exist inside a local function and after the border.\n     *\n     * @param {eslint-scope.Reference} upperRef - A reference to check.\n     * @returns {boolean} `true` if the reference is safe.\n     */\n    function isSafeReference(upperRef) {\n        const id = upperRef.identifier;\n\n        return (\n            !upperRef.isWrite() ||\n            variable.scope.variableScope === upperRef.from.variableScope &&\n            id.range[0] < border\n        );\n    }\n\n    return Boolean(variable) && variable.references.every(isSafeReference);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `function` declarations and expressions inside loop statements\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Reports functions which match the following condition:\n         *\n         * - has a loop node in ancestors.\n         * - has any references which refers to an unsafe variable.\n         *\n         * @param {ASTNode} node The AST node to check.\n         * @returns {boolean} Whether or not the node is within a loop.\n         */\n        function checkForLoops(node) {\n            const loopNode = getContainingLoopNode(node);\n\n            if (!loopNode) {\n                return;\n            }\n\n            const references = context.getScope().through;\n\n            if (references.length > 0 &&\n                !references.every(isSafe.bind(null, loopNode))\n            ) {\n                context.report({ node, message: \"Don't make functions within a loop.\" });\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: checkForLoops,\n            FunctionExpression: checkForLoops,\n            FunctionDeclaration: checkForLoops\n        };\n    }\n};\n","no-magic-numbers.js":"/**\n * @fileoverview Rule to flag statements that use magic numbers (adapted from https://github.com/danielstjules/buddy.js)\n * @author Vincent Lemeunier\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow magic numbers\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                detectObjects: {\n                    type: \"boolean\"\n                },\n                enforceConst: {\n                    type: \"boolean\"\n                },\n                ignore: {\n                    type: \"array\",\n                    items: {\n                        type: \"number\"\n                    },\n                    uniqueItems: true\n                },\n                ignoreArrayIndexes: {\n                    type: \"boolean\"\n                }\n            },\n            additionalProperties: false\n        }]\n    },\n\n    create(context) {\n        const config = context.options[0] || {},\n            detectObjects = !!config.detectObjects,\n            enforceConst = !!config.enforceConst,\n            ignore = config.ignore || [],\n            ignoreArrayIndexes = !!config.ignoreArrayIndexes;\n\n        /**\n         * Returns whether the node is number literal\n         * @param {Node} node - the node literal being evaluated\n         * @returns {boolean} true if the node is a number literal\n         */\n        function isNumber(node) {\n            return typeof node.value === \"number\";\n        }\n\n        /**\n         * Returns whether the number should be ignored\n         * @param {number} num - the number\n         * @returns {boolean} true if the number should be ignored\n         */\n        function shouldIgnoreNumber(num) {\n            return ignore.indexOf(num) !== -1;\n        }\n\n        /**\n         * Returns whether the number should be ignored when used as a radix within parseInt() or Number.parseInt()\n         * @param {ASTNode} parent - the non-\"UnaryExpression\" parent\n         * @param {ASTNode} node - the node literal being evaluated\n         * @returns {boolean} true if the number should be ignored\n         */\n        function shouldIgnoreParseInt(parent, node) {\n            return parent.type === \"CallExpression\" && node === parent.arguments[1] &&\n                (parent.callee.name === \"parseInt\" ||\n                parent.callee.type === \"MemberExpression\" &&\n                parent.callee.object.name === \"Number\" &&\n                parent.callee.property.name === \"parseInt\");\n        }\n\n        /**\n         * Returns whether the number should be ignored when used to define a JSX prop\n         * @param {ASTNode} parent - the non-\"UnaryExpression\" parent\n         * @returns {boolean} true if the number should be ignored\n         */\n        function shouldIgnoreJSXNumbers(parent) {\n            return parent.type.indexOf(\"JSX\") === 0;\n        }\n\n        /**\n         * Returns whether the number should be ignored when used as an array index with enabled 'ignoreArrayIndexes' option.\n         * @param {ASTNode} parent - the non-\"UnaryExpression\" parent.\n         * @returns {boolean} true if the number should be ignored\n         */\n        function shouldIgnoreArrayIndexes(parent) {\n            return parent.type === \"MemberExpression\" && ignoreArrayIndexes;\n        }\n\n        return {\n            Literal(node) {\n                let parent = node.parent,\n                    value = node.value,\n                    raw = node.raw;\n                const okTypes = detectObjects ? [] : [\"ObjectExpression\", \"Property\", \"AssignmentExpression\"];\n\n                if (!isNumber(node)) {\n                    return;\n                }\n\n                // For negative magic numbers: update the value and parent node\n                if (parent.type === \"UnaryExpression\" && parent.operator === \"-\") {\n                    node = parent;\n                    parent = node.parent;\n                    value = -value;\n                    raw = `-${raw}`;\n                }\n\n                if (shouldIgnoreNumber(value) ||\n                    shouldIgnoreParseInt(parent, node) ||\n                    shouldIgnoreArrayIndexes(parent) ||\n                    shouldIgnoreJSXNumbers(parent)) {\n                    return;\n                }\n\n                if (parent.type === \"VariableDeclarator\") {\n                    if (enforceConst && parent.parent.kind !== \"const\") {\n                        context.report({\n                            node,\n                            message: \"Number constants declarations must use 'const'.\"\n                        });\n                    }\n                } else if (\n                    okTypes.indexOf(parent.type) === -1 ||\n                    (parent.type === \"AssignmentExpression\" && parent.left.type === \"Identifier\")\n                ) {\n                    context.report({\n                        node,\n                        message: \"No magic number: {{raw}}.\",\n                        data: {\n                            raw\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","no-mixed-operators.js":"/**\n * @fileoverview Rule to disallow mixed binary operators.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils.js\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst ARITHMETIC_OPERATORS = [\"+\", \"-\", \"*\", \"/\", \"%\", \"**\"];\nconst BITWISE_OPERATORS = [\"&\", \"|\", \"^\", \"~\", \"<<\", \">>\", \">>>\"];\nconst COMPARISON_OPERATORS = [\"==\", \"!=\", \"===\", \"!==\", \">\", \">=\", \"<\", \"<=\"];\nconst LOGICAL_OPERATORS = [\"&&\", \"||\"];\nconst RELATIONAL_OPERATORS = [\"in\", \"instanceof\"];\nconst ALL_OPERATORS = [].concat(\n    ARITHMETIC_OPERATORS,\n    BITWISE_OPERATORS,\n    COMPARISON_OPERATORS,\n    LOGICAL_OPERATORS,\n    RELATIONAL_OPERATORS\n);\nconst DEFAULT_GROUPS = [\n    ARITHMETIC_OPERATORS,\n    BITWISE_OPERATORS,\n    COMPARISON_OPERATORS,\n    LOGICAL_OPERATORS,\n    RELATIONAL_OPERATORS\n];\nconst TARGET_NODE_TYPE = /^(?:Binary|Logical)Expression$/;\n\n/**\n * Normalizes options.\n *\n * @param {Object|undefined} options - A options object to normalize.\n * @returns {Object} Normalized option object.\n */\nfunction normalizeOptions(options) {\n    const hasGroups = (options && options.groups && options.groups.length > 0);\n    const groups = hasGroups ? options.groups : DEFAULT_GROUPS;\n    const allowSamePrecedence = (options && options.allowSamePrecedence) !== false;\n\n    return {\n        groups,\n        allowSamePrecedence\n    };\n}\n\n/**\n * Checks whether any group which includes both given operator exists or not.\n *\n * @param {Array.<string[]>} groups - A list of groups to check.\n * @param {string} left - An operator.\n * @param {string} right - Another operator.\n * @returns {boolean} `true` if such group existed.\n */\nfunction includesBothInAGroup(groups, left, right) {\n    return groups.some(group => group.indexOf(left) !== -1 && group.indexOf(right) !== -1);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow mixed binary operators\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    groups: {\n                        type: \"array\",\n                        items: {\n                            type: \"array\",\n                            items: { enum: ALL_OPERATORS },\n                            minItems: 2,\n                            uniqueItems: true\n                        },\n                        uniqueItems: true\n                    },\n                    allowSamePrecedence: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = normalizeOptions(context.options[0]);\n\n        /**\n         * Checks whether a given node should be ignored by options or not.\n         *\n         * @param {ASTNode} node - A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node. This parent node is one of\n         *      them, too.\n         * @returns {boolean} `true` if the node should be ignored.\n         */\n        function shouldIgnore(node) {\n            const a = node;\n            const b = node.parent;\n\n            return (\n                !includesBothInAGroup(options.groups, a.operator, b.operator) ||\n                (\n                    options.allowSamePrecedence &&\n                    astUtils.getPrecedence(a) === astUtils.getPrecedence(b)\n                )\n            );\n        }\n\n        /**\n         * Checks whether the operator of a given node is mixed with parent\n         * node's operator or not.\n         *\n         * @param {ASTNode} node - A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node. This parent node is one of\n         *      them, too.\n         * @returns {boolean} `true` if the node was mixed.\n         */\n        function isMixedWithParent(node) {\n            return (\n                node.operator !== node.parent.operator &&\n                !astUtils.isParenthesised(sourceCode, node)\n            );\n        }\n\n        /**\n         * Gets the operator token of a given node.\n         *\n         * @param {ASTNode} node - A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node.\n         * @returns {Token} The operator token of the node.\n         */\n        function getOperatorToken(node) {\n            return sourceCode.getTokenAfter(node.left, astUtils.isNotClosingParenToken);\n        }\n\n        /**\n         * Reports both the operator of a given node and the operator of the\n         * parent node.\n         *\n         * @param {ASTNode} node - A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node. This parent node is one of\n         *      them, too.\n         * @returns {void}\n         */\n        function reportBothOperators(node) {\n            const parent = node.parent;\n            const left = (parent.left === node) ? node : parent;\n            const right = (parent.left !== node) ? node : parent;\n            const message =\n                \"Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'.\";\n            const data = {\n                leftOperator: left.operator,\n                rightOperator: right.operator\n            };\n\n            context.report({\n                node: left,\n                loc: getOperatorToken(left).loc.start,\n                message,\n                data\n            });\n            context.report({\n                node: right,\n                loc: getOperatorToken(right).loc.start,\n                message,\n                data\n            });\n        }\n\n        /**\n         * Checks between the operator of this node and the operator of the\n         * parent node.\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            if (TARGET_NODE_TYPE.test(node.parent.type) &&\n                isMixedWithParent(node) &&\n                !shouldIgnore(node)\n            ) {\n                reportBothOperators(node);\n            }\n        }\n\n        return {\n            BinaryExpression: check,\n            LogicalExpression: check\n        };\n    }\n};\n","no-mixed-requires.js":"/**\n * @fileoverview Rule to enforce grouped require statements for Node.JS\n * @author Raphael Pigulla\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `require` calls to be mixed with regular variable declarations\",\n            category: \"Node.js and CommonJS\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"boolean\"\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            grouping: {\n                                type: \"boolean\"\n                            },\n                            allowCall: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n\n        const options = context.options[0];\n        let grouping = false,\n            allowCall = false;\n\n        if (typeof options === \"object\") {\n            grouping = options.grouping;\n            allowCall = options.allowCall;\n        } else {\n            grouping = !!options;\n        }\n\n        /**\n         * Returns the list of built-in modules.\n         *\n         * @returns {string[]} An array of built-in Node.js modules.\n         */\n        function getBuiltinModules() {\n\n            /*\n             * This list is generated using:\n             * `require(\"repl\")._builtinLibs.concat('repl').sort()`\n             * This particular list is as per nodejs v0.12.2 and iojs v0.7.1\n             */\n            return [\n                \"assert\", \"buffer\", \"child_process\", \"cluster\", \"crypto\",\n                \"dgram\", \"dns\", \"domain\", \"events\", \"fs\", \"http\", \"https\",\n                \"net\", \"os\", \"path\", \"punycode\", \"querystring\", \"readline\",\n                \"repl\", \"smalloc\", \"stream\", \"string_decoder\", \"tls\", \"tty\",\n                \"url\", \"util\", \"v8\", \"vm\", \"zlib\"\n            ];\n        }\n\n        const BUILTIN_MODULES = getBuiltinModules();\n\n        const DECL_REQUIRE = \"require\",\n            DECL_UNINITIALIZED = \"uninitialized\",\n            DECL_OTHER = \"other\";\n\n        const REQ_CORE = \"core\",\n            REQ_FILE = \"file\",\n            REQ_MODULE = \"module\",\n            REQ_COMPUTED = \"computed\";\n\n        /**\n         * Determines the type of a declaration statement.\n         * @param {ASTNode} initExpression The init node of the VariableDeclarator.\n         * @returns {string} The type of declaration represented by the expression.\n         */\n        function getDeclarationType(initExpression) {\n            if (!initExpression) {\n\n                // \"var x;\"\n                return DECL_UNINITIALIZED;\n            }\n\n            if (initExpression.type === \"CallExpression\" &&\n                initExpression.callee.type === \"Identifier\" &&\n                initExpression.callee.name === \"require\"\n            ) {\n\n                // \"var x = require('util');\"\n                return DECL_REQUIRE;\n            } else if (allowCall &&\n                initExpression.type === \"CallExpression\" &&\n                initExpression.callee.type === \"CallExpression\"\n            ) {\n\n                // \"var x = require('diagnose')('sub-module');\"\n                return getDeclarationType(initExpression.callee);\n            } else if (initExpression.type === \"MemberExpression\") {\n\n                // \"var x = require('glob').Glob;\"\n                return getDeclarationType(initExpression.object);\n            }\n\n            // \"var x = 42;\"\n            return DECL_OTHER;\n        }\n\n        /**\n         * Determines the type of module that is loaded via require.\n         * @param {ASTNode} initExpression The init node of the VariableDeclarator.\n         * @returns {string} The module type.\n         */\n        function inferModuleType(initExpression) {\n            if (initExpression.type === \"MemberExpression\") {\n\n                // \"var x = require('glob').Glob;\"\n                return inferModuleType(initExpression.object);\n            } else if (initExpression.arguments.length === 0) {\n\n                // \"var x = require();\"\n                return REQ_COMPUTED;\n            }\n\n            const arg = initExpression.arguments[0];\n\n            if (arg.type !== \"Literal\" || typeof arg.value !== \"string\") {\n\n                // \"var x = require(42);\"\n                return REQ_COMPUTED;\n            }\n\n            if (BUILTIN_MODULES.indexOf(arg.value) !== -1) {\n\n                // \"var fs = require('fs');\"\n                return REQ_CORE;\n            } else if (/^\\.{0,2}\\//.test(arg.value)) {\n\n                // \"var utils = require('./utils');\"\n                return REQ_FILE;\n            }\n\n            // \"var async = require('async');\"\n            return REQ_MODULE;\n\n        }\n\n        /**\n         * Check if the list of variable declarations is mixed, i.e. whether it\n         * contains both require and other declarations.\n         * @param {ASTNode} declarations The list of VariableDeclarators.\n         * @returns {boolean} True if the declarations are mixed, false if not.\n         */\n        function isMixed(declarations) {\n            const contains = {};\n\n            declarations.forEach(declaration => {\n                const type = getDeclarationType(declaration.init);\n\n                contains[type] = true;\n            });\n\n            return !!(\n                contains[DECL_REQUIRE] &&\n                (contains[DECL_UNINITIALIZED] || contains[DECL_OTHER])\n            );\n        }\n\n        /**\n         * Check if all require declarations in the given list are of the same\n         * type.\n         * @param {ASTNode} declarations The list of VariableDeclarators.\n         * @returns {boolean} True if the declarations are grouped, false if not.\n         */\n        function isGrouped(declarations) {\n            const found = {};\n\n            declarations.forEach(declaration => {\n                if (getDeclarationType(declaration.init) === DECL_REQUIRE) {\n                    found[inferModuleType(declaration.init)] = true;\n                }\n            });\n\n            return Object.keys(found).length <= 1;\n        }\n\n\n        return {\n\n            VariableDeclaration(node) {\n\n                if (isMixed(node.declarations)) {\n                    context.report({ node, message: \"Do not mix 'require' and other declarations.\" });\n                } else if (grouping && !isGrouped(node.declarations)) {\n                    context.report({ node, message: \"Do not mix core, module, file and computed requires.\" });\n                }\n            }\n        };\n\n    }\n};\n","no-mixed-spaces-and-tabs.js":"/**\n * @fileoverview Disallow mixed spaces and tabs for indentation\n * @author Jary Niebur\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow mixed spaces and tabs for indentation\",\n            category: \"Stylistic Issues\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                enum: [\"smart-tabs\", true, false]\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        let smartTabs;\n        const ignoredLocs = [];\n\n        switch (context.options[0]) {\n            case true: // Support old syntax, maybe add deprecation warning here\n            case \"smart-tabs\":\n                smartTabs = true;\n                break;\n            default:\n                smartTabs = false;\n        }\n\n        /**\n         * Determines if a given line and column are before a location.\n         * @param {Location} loc The location object from an AST node.\n         * @param {int} line The line to check.\n         * @param {int} column The column to check.\n         * @returns {boolean} True if the line and column are before the location, false if not.\n         * @private\n         */\n        function beforeLoc(loc, line, column) {\n            if (line < loc.start.line) {\n                return true;\n            }\n            return line === loc.start.line && column < loc.start.column;\n        }\n\n        /**\n         * Determines if a given line and column are after a location.\n         * @param {Location} loc The location object from an AST node.\n         * @param {int} line The line to check.\n         * @param {int} column The column to check.\n         * @returns {boolean} True if the line and column are after the location, false if not.\n         * @private\n         */\n        function afterLoc(loc, line, column) {\n            if (line > loc.end.line) {\n                return true;\n            }\n            return line === loc.end.line && column > loc.end.column;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            TemplateElement(node) {\n                ignoredLocs.push(node.loc);\n            },\n\n            \"Program:exit\"(node) {\n\n                /*\n                 * At least one space followed by a tab\n                 * or the reverse before non-tab/-space\n                 * characters begin.\n                 */\n                let regex = /^(?=[\\t ]*(\\t | \\t))/;\n                const lines = sourceCode.lines,\n                    comments = sourceCode.getAllComments();\n\n                comments.forEach(comment => {\n                    ignoredLocs.push(comment.loc);\n                });\n\n                ignoredLocs.sort((first, second) => {\n                    if (beforeLoc(first, second.start.line, second.start.column)) {\n                        return 1;\n                    }\n\n                    if (beforeLoc(second, first.start.line, second.start.column)) {\n                        return -1;\n                    }\n\n                    return 0;\n                });\n\n                if (smartTabs) {\n\n                    /*\n                     * At least one space followed by a tab\n                     * before non-tab/-space characters begin.\n                     */\n                    regex = /^(?=[\\t ]* \\t)/;\n                }\n\n                lines.forEach((line, i) => {\n                    const match = regex.exec(line);\n\n                    if (match) {\n                        const lineNumber = i + 1,\n                            column = match.index + 1;\n\n                        for (let j = 0; j < ignoredLocs.length; j++) {\n                            if (beforeLoc(ignoredLocs[j], lineNumber, column)) {\n                                continue;\n                            }\n                            if (afterLoc(ignoredLocs[j], lineNumber, column)) {\n                                continue;\n                            }\n\n                            return;\n                        }\n\n                        context.report({ node, loc: { line: lineNumber, column }, message: \"Mixed spaces and tabs.\" });\n                    }\n                });\n            }\n\n        };\n\n    }\n};\n","no-multi-assign.js":"/**\n * @fileoverview Rule to check use of chained assignment expressions\n * @author Stewart Rand\n */\n\n\"use strict\";\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow use of chained assignment expressions\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        schema: []\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            AssignmentExpression(node) {\n                if ([\"AssignmentExpression\", \"VariableDeclarator\"].indexOf(node.parent.type) !== -1) {\n                    context.report({\n                        node,\n                        message: \"Unexpected chained assignment.\"\n                    });\n                }\n            }\n        };\n\n    }\n};\n","no-multi-spaces.js":"/**\n * @fileoverview Disallow use of multiple spaces.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow multiple spaces\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"object\",\n                        patternProperties: {\n                            \"^([A-Z][a-z]*)+$\": {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    ignoreEOLComments: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = context.options[0] || {};\n        const ignoreEOLComments = options.ignoreEOLComments;\n        const exceptions = Object.assign({ Property: true }, options.exceptions);\n        const hasExceptions = Object.keys(exceptions).filter(key => exceptions[key]).length > 0;\n\n        /**\n         * Formats value of given comment token for error message by truncating its length.\n         * @param {Token} token comment token\n         * @returns {string} formatted value\n         * @private\n         */\n        function formatReportedCommentValue(token) {\n            const valueLines = token.value.split(\"\\n\");\n            const value = valueLines[0];\n            const formattedValue = `${value.slice(0, 12)}...`;\n\n            return valueLines.length === 1 && value.length <= 12 ? value : formattedValue;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program() {\n                sourceCode.tokensAndComments.forEach((leftToken, leftIndex, tokensAndComments) => {\n                    if (leftIndex === tokensAndComments.length - 1) {\n                        return;\n                    }\n                    const rightToken = tokensAndComments[leftIndex + 1];\n\n                    // Ignore tokens that don't have 2 spaces between them or are on different lines\n                    if (\n                        !sourceCode.text.slice(leftToken.range[1], rightToken.range[0]).includes(\"  \") ||\n                        leftToken.loc.end.line < rightToken.loc.start.line\n                    ) {\n                        return;\n                    }\n\n                    // Ignore comments that are the last token on their line if `ignoreEOLComments` is active.\n                    if (\n                        ignoreEOLComments &&\n                        astUtils.isCommentToken(rightToken) &&\n                        (\n                            leftIndex === tokensAndComments.length - 2 ||\n                            rightToken.loc.end.line < tokensAndComments[leftIndex + 2].loc.start.line\n                        )\n                    ) {\n                        return;\n                    }\n\n                    // Ignore tokens that are in a node in the \"exceptions\" object\n                    if (hasExceptions) {\n                        const parentNode = sourceCode.getNodeByRangeIndex(rightToken.range[0] - 1);\n\n                        if (parentNode && exceptions[parentNode.type]) {\n                            return;\n                        }\n                    }\n\n                    let displayValue;\n\n                    if (rightToken.type === \"Block\") {\n                        displayValue = `/*${formatReportedCommentValue(rightToken)}*/`;\n                    } else if (rightToken.type === \"Line\") {\n                        displayValue = `//${formatReportedCommentValue(rightToken)}`;\n                    } else {\n                        displayValue = rightToken.value;\n                    }\n\n                    context.report({\n                        node: rightToken,\n                        loc: rightToken.loc.start,\n                        message: \"Multiple spaces found before '{{displayValue}}'.\",\n                        data: { displayValue },\n                        fix: fixer => fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], \" \")\n                    });\n                });\n            }\n        };\n\n    }\n};\n","no-multi-str.js":"/**\n * @fileoverview Rule to flag when using multiline strings\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow multiline strings\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Determines if a given node is part of JSX syntax.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node is a JSX node, false if not.\n         * @private\n         */\n        function isJSXElement(node) {\n            return node.type.indexOf(\"JSX\") === 0;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n\n            Literal(node) {\n                if (astUtils.LINEBREAK_MATCHER.test(node.raw) && !isJSXElement(node.parent)) {\n                    context.report({ node, message: \"Multiline support is limited to browsers supporting ES5 only.\" });\n                }\n            }\n        };\n\n    }\n};\n","no-multiple-empty-lines.js":"/**\n * @fileoverview Disallows multiple blank lines.\n * implementation adapted from the no-trailing-spaces rule.\n * @author Greg Cochard\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow multiple empty lines\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    max: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    maxEOF: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    maxBOF: {\n                        type: \"integer\",\n                        minimum: 0\n                    }\n                },\n                required: [\"max\"],\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        // Use options.max or 2 as default\n        let max = 2,\n            maxEOF = max,\n            maxBOF = max;\n\n        if (context.options.length) {\n            max = context.options[0].max;\n            maxEOF = typeof context.options[0].maxEOF !== \"undefined\" ? context.options[0].maxEOF : max;\n            maxBOF = typeof context.options[0].maxBOF !== \"undefined\" ? context.options[0].maxBOF : max;\n        }\n\n        const sourceCode = context.getSourceCode();\n\n        // Swallow the final newline, as some editors add it automatically and we don't want it to cause an issue\n        const allLines = sourceCode.lines[sourceCode.lines.length - 1] === \"\" ? sourceCode.lines.slice(0, -1) : sourceCode.lines;\n        const templateLiteralLines = new Set();\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            TemplateLiteral(node) {\n                node.quasis.forEach(literalPart => {\n\n                    // Empty lines have a semantic meaning if they're inside template literals. Don't count these as empty lines.\n                    for (let ignoredLine = literalPart.loc.start.line; ignoredLine < literalPart.loc.end.line; ignoredLine++) {\n                        templateLiteralLines.add(ignoredLine);\n                    }\n                });\n            },\n            \"Program:exit\"(node) {\n                return allLines\n\n                    // Given a list of lines, first get a list of line numbers that are non-empty.\n                    .reduce((nonEmptyLineNumbers, line, index) => {\n                        if (line.trim() || templateLiteralLines.has(index + 1)) {\n                            nonEmptyLineNumbers.push(index + 1);\n                        }\n                        return nonEmptyLineNumbers;\n                    }, [])\n\n                    // Add a value at the end to allow trailing empty lines to be checked.\n                    .concat(allLines.length + 1)\n\n                    // Given two line numbers of non-empty lines, report the lines between if the difference is too large.\n                    .reduce((lastLineNumber, lineNumber) => {\n                        let message, maxAllowed;\n\n                        if (lastLineNumber === 0) {\n                            message = \"Too many blank lines at the beginning of file. Max of {{max}} allowed.\";\n                            maxAllowed = maxBOF;\n                        } else if (lineNumber === allLines.length + 1) {\n                            message = \"Too many blank lines at the end of file. Max of {{max}} allowed.\";\n                            maxAllowed = maxEOF;\n                        } else {\n                            message = \"More than {{max}} blank {{pluralizedLines}} not allowed.\";\n                            maxAllowed = max;\n                        }\n\n                        if (lineNumber - lastLineNumber - 1 > maxAllowed) {\n                            context.report({\n                                node,\n                                loc: { start: { line: lastLineNumber + 1, column: 0 }, end: { line: lineNumber, column: 0 } },\n                                message,\n                                data: { max: maxAllowed, pluralizedLines: maxAllowed === 1 ? \"line\" : \"lines\" },\n                                fix(fixer) {\n                                    const rangeStart = sourceCode.getIndexFromLoc({ line: lastLineNumber + 1, column: 0 });\n\n                                    /*\n                                     * The end of the removal range is usually the start index of the next line.\n                                     * However, at the end of the file there is no next line, so the end of the\n                                     * range is just the length of the text.\n                                     */\n                                    const lineNumberAfterRemovedLines = lineNumber - maxAllowed;\n                                    const rangeEnd = lineNumberAfterRemovedLines <= allLines.length\n                                        ? sourceCode.getIndexFromLoc({ line: lineNumberAfterRemovedLines, column: 0 })\n                                        : sourceCode.text.length;\n\n                                    return fixer.removeRange([rangeStart, rangeEnd]);\n                                }\n                            });\n                        }\n\n                        return lineNumber;\n                    }, 0);\n            }\n        };\n    }\n};\n","no-native-reassign.js":"/**\n * @fileoverview Rule to disallow assignments to native objects or read-only global variables\n * @author Ilya Volodin\n * @deprecated in ESLint v3.3.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow assignments to native objects or read-only global variables\",\n            category: \"Best Practices\",\n            recommended: false,\n            replacedBy: [\"no-global-assign\"]\n        },\n\n        deprecated: true,\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: { type: \"string\" },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const config = context.options[0];\n        const exceptions = (config && config.exceptions) || [];\n\n        /**\n         * Reports write references.\n         * @param {Reference} reference - A reference to check.\n         * @param {int} index - The index of the reference in the references.\n         * @param {Reference[]} references - The array that the reference belongs to.\n         * @returns {void}\n         */\n        function checkReference(reference, index, references) {\n            const identifier = reference.identifier;\n\n            if (reference.init === false &&\n                reference.isWrite() &&\n\n                // Destructuring assignments can have multiple default value,\n                // so possibly there are multiple writeable references for the same identifier.\n                (index === 0 || references[index - 1].identifier !== identifier)\n            ) {\n                context.report({\n                    node: identifier,\n                    message: \"Read-only global '{{name}}' should not be modified.\",\n                    data: identifier\n                });\n            }\n        }\n\n        /**\n         * Reports write references if a given variable is read-only builtin.\n         * @param {Variable} variable - A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            if (variable.writeable === false && exceptions.indexOf(variable.name) === -1) {\n                variable.references.forEach(checkReference);\n            }\n        }\n\n        return {\n            Program() {\n                const globalScope = context.getScope();\n\n                globalScope.variables.forEach(checkVariable);\n            }\n        };\n    }\n};\n","no-negated-condition.js":"/**\n * @fileoverview Rule to disallow a negated condition\n * @author Alberto RodrÃ­guez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow negated conditions\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Determines if a given node is an if-else without a condition on the else\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node has an else without an if.\n         * @private\n         */\n        function hasElseWithoutCondition(node) {\n            return node.alternate && node.alternate.type !== \"IfStatement\";\n        }\n\n        /**\n         * Determines if a given node is a negated unary expression\n         * @param {Object} test The test object to check.\n         * @returns {boolean} True if the node is a negated unary expression.\n         * @private\n         */\n        function isNegatedUnaryExpression(test) {\n            return test.type === \"UnaryExpression\" && test.operator === \"!\";\n        }\n\n        /**\n         * Determines if a given node is a negated binary expression\n         * @param {Test} test The test to check.\n         * @returns {boolean} True if the node is a negated binary expression.\n         * @private\n         */\n        function isNegatedBinaryExpression(test) {\n            return test.type === \"BinaryExpression\" &&\n                (test.operator === \"!=\" || test.operator === \"!==\");\n        }\n\n        /**\n         * Determines if a given node has a negated if expression\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node has a negated if expression.\n         * @private\n         */\n        function isNegatedIf(node) {\n            return isNegatedUnaryExpression(node.test) || isNegatedBinaryExpression(node.test);\n        }\n\n        return {\n            IfStatement(node) {\n                if (!hasElseWithoutCondition(node)) {\n                    return;\n                }\n\n                if (isNegatedIf(node)) {\n                    context.report({ node, message: \"Unexpected negated condition.\" });\n                }\n            },\n            ConditionalExpression(node) {\n                if (isNegatedIf(node)) {\n                    context.report({ node, message: \"Unexpected negated condition.\" });\n                }\n            }\n        };\n    }\n};\n","no-negated-in-lhs.js":"/**\n * @fileoverview A rule to disallow negated left operands of the `in` operator\n * @author Michael Ficarra\n * @deprecated in ESLint v3.3.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow negating the left operand in `in` expressions\",\n            category: \"Possible Errors\",\n            recommended: false,\n            replacedBy: [\"no-unsafe-negation\"]\n        },\n        deprecated: true,\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            BinaryExpression(node) {\n                if (node.operator === \"in\" && node.left.type === \"UnaryExpression\" && node.left.operator === \"!\") {\n                    context.report({ node, message: \"The 'in' expression's left operand is negated.\" });\n                }\n            }\n        };\n\n    }\n};\n","no-nested-ternary.js":"/**\n * @fileoverview Rule to flag nested ternary expressions\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow nested ternary expressions\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n            ConditionalExpression(node) {\n                if (node.alternate.type === \"ConditionalExpression\" ||\n                        node.consequent.type === \"ConditionalExpression\") {\n                    context.report({ node, message: \"Do not nest ternary expressions.\" });\n                }\n            }\n        };\n    }\n};\n","no-new-func.js":"/**\n * @fileoverview Rule to flag when using new Function\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `new` operators with the `Function` object\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Reports a node.\n         * @param {ASTNode} node The node to report\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            context.report({ node, message: \"The Function constructor is eval.\" });\n        }\n\n        return {\n            \"NewExpression[callee.name = 'Function']\": report,\n            \"CallExpression[callee.name = 'Function']\": report\n        };\n\n    }\n};\n","no-new-object.js":"/**\n * @fileoverview A rule to disallow calls to the Object constructor\n * @author Matt DuVall <http://www.mattduvall.com/>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `Object` constructors\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            NewExpression(node) {\n                if (node.callee.name === \"Object\") {\n                    context.report({ node, message: \"The object literal notation {} is preferrable.\" });\n                }\n            }\n        };\n\n    }\n};\n","no-new-require.js":"/**\n * @fileoverview Rule to disallow use of new operator with the `require` function\n * @author Wil Moore III\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `new` operators with calls to `require`\",\n            category: \"Node.js and CommonJS\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            NewExpression(node) {\n                if (node.callee.type === \"Identifier\" && node.callee.name === \"require\") {\n                    context.report({ node, message: \"Unexpected use of new with require.\" });\n                }\n            }\n        };\n\n    }\n};\n","no-new-symbol.js":"/**\n * @fileoverview Rule to disallow use of the new operator with the `Symbol` object\n * @author Alberto RodrÃ­guez\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `new` operators with the `Symbol` object\",\n            category: \"ECMAScript 6\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n                const variable = globalScope.set.get(\"Symbol\");\n\n                if (variable && variable.defs.length === 0) {\n                    variable.references.forEach(ref => {\n                        const node = ref.identifier;\n\n                        if (node.parent && node.parent.type === \"NewExpression\") {\n                            context.report({ node, message: \"`Symbol` cannot be called as a constructor.\" });\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","no-new-wrappers.js":"/**\n * @fileoverview Rule to flag when using constructor for wrapper objects\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `new` operators with the `String`, `Number`, and `Boolean` objects\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            NewExpression(node) {\n                const wrapperObjects = [\"String\", \"Number\", \"Boolean\", \"Math\", \"JSON\"];\n\n                if (wrapperObjects.indexOf(node.callee.name) > -1) {\n                    context.report({ node, message: \"Do not use {{fn}} as a constructor.\", data: { fn: node.callee.name } });\n                }\n            }\n        };\n\n    }\n};\n","no-new.js":"/**\n * @fileoverview Rule to flag statements with function invocation preceded by\n * \"new\" and not part of assignment\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `new` operators outside of assignments or comparisons\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n            \"ExpressionStatement > NewExpression\"(node) {\n                context.report({ node: node.parent, message: \"Do not use 'new' for side effects.\" });\n            }\n        };\n\n    }\n};\n","no-obj-calls.js":"/**\n * @fileoverview Rule to flag use of an object property of the global object (Math and JSON) as a function\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow calling global object properties as functions\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n            CallExpression(node) {\n\n                if (node.callee.type === \"Identifier\") {\n                    const name = node.callee.name;\n\n                    if (name === \"Math\" || name === \"JSON\" || name === \"Reflect\") {\n                        context.report({ node, message: \"'{{name}}' is not a function.\", data: { name } });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","no-octal-escape.js":"/**\n * @fileoverview Rule to flag octal escape sequences in string literals.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow octal escape sequences in string literals\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            Literal(node) {\n                if (typeof node.value !== \"string\") {\n                    return;\n                }\n\n                const match = node.raw.match(/^([^\\\\]|\\\\[^0-7])*\\\\([0-3][0-7]{1,2}|[4-7][0-7]|[0-7])/);\n\n                if (match) {\n                    const octalDigit = match[2];\n\n                    // \\0 is actually not considered an octal\n                    if (match[2] !== \"0\" || typeof match[3] !== \"undefined\") {\n                        context.report({ node, message: \"Don't use octal: '\\\\{{octalDigit}}'. Use '\\\\u....' instead.\", data: { octalDigit } });\n                    }\n                }\n            }\n\n        };\n\n    }\n};\n","no-octal.js":"/**\n * @fileoverview Rule to flag when initializing octal literal\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow octal literals\",\n            category: \"Best Practices\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            Literal(node) {\n                if (typeof node.value === \"number\" && /^0[0-7]/.test(node.raw)) {\n                    context.report({ node, message: \"Octal literals should not be used.\" });\n                }\n            }\n        };\n\n    }\n};\n","no-param-reassign.js":"/**\n * @fileoverview Disallow reassignment of function parameters.\n * @author Nat Burns\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst stopNodePattern = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/;\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow reassigning `function` parameters\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"object\",\n                        properties: {\n                            props: {\n                                enum: [false]\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            props: {\n                                enum: [true]\n                            },\n                            ignorePropertyModificationsFor: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                },\n                                uniqueItems: true\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const props = context.options[0] && Boolean(context.options[0].props);\n        const ignoredPropertyAssignmentsFor = context.options[0] && context.options[0].ignorePropertyModificationsFor || [];\n\n        /**\n         * Checks whether or not the reference modifies properties of its variable.\n         * @param {Reference} reference - A reference to check.\n         * @returns {boolean} Whether or not the reference modifies properties of its variable.\n         */\n        function isModifyingProp(reference) {\n            let node = reference.identifier;\n            let parent = node.parent;\n\n            while (parent && !stopNodePattern.test(parent.type)) {\n                switch (parent.type) {\n\n                    // e.g. foo.a = 0;\n                    case \"AssignmentExpression\":\n                        return parent.left === node;\n\n                    // e.g. ++foo.a;\n                    case \"UpdateExpression\":\n                        return true;\n\n                    // e.g. delete foo.a;\n                    case \"UnaryExpression\":\n                        if (parent.operator === \"delete\") {\n                            return true;\n                        }\n                        break;\n\n                    // EXCLUDES: e.g. cache.get(foo.a).b = 0;\n                    case \"CallExpression\":\n                        if (parent.callee !== node) {\n                            return false;\n                        }\n                        break;\n\n                    // EXCLUDES: e.g. cache[foo.a] = 0;\n                    case \"MemberExpression\":\n                        if (parent.property === node) {\n                            return false;\n                        }\n                        break;\n\n                    // EXCLUDES: e.g. ({ [foo]: a }) = bar;\n                    case \"Property\":\n                        if (parent.key === node) {\n                            return false;\n                        }\n\n                        break;\n\n                    // no default\n                }\n\n                node = parent;\n                parent = node.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Reports a reference if is non initializer and writable.\n         * @param {Reference} reference - A reference to check.\n         * @param {int} index - The index of the reference in the references.\n         * @param {Reference[]} references - The array that the reference belongs to.\n         * @returns {void}\n         */\n        function checkReference(reference, index, references) {\n            const identifier = reference.identifier;\n\n            if (identifier &&\n                !reference.init &&\n\n                // Destructuring assignments can have multiple default value,\n                // so possibly there are multiple writeable references for the same identifier.\n                (index === 0 || references[index - 1].identifier !== identifier)\n            ) {\n                if (reference.isWrite()) {\n                    context.report({ node: identifier, message: \"Assignment to function parameter '{{name}}'.\", data: { name: identifier.name } });\n                } else if (props && isModifyingProp(reference) && ignoredPropertyAssignmentsFor.indexOf(identifier.name) === -1) {\n                    context.report({ node: identifier, message: \"Assignment to property of function parameter '{{name}}'.\", data: { name: identifier.name } });\n                }\n            }\n        }\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {Variable} variable - A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            if (variable.defs[0].type === \"Parameter\") {\n                variable.references.forEach(checkReference);\n            }\n        }\n\n        /**\n         * Checks parameters of a given function node.\n         * @param {ASTNode} node - A function node to check.\n         * @returns {void}\n         */\n        function checkForFunction(node) {\n            context.getDeclaredVariables(node).forEach(checkVariable);\n        }\n\n        return {\n\n            // `:exit` is needed for the `node.parent` property of identifier nodes.\n            \"FunctionDeclaration:exit\": checkForFunction,\n            \"FunctionExpression:exit\": checkForFunction,\n            \"ArrowFunctionExpression:exit\": checkForFunction\n        };\n\n    }\n};\n","no-path-concat.js":"/**\n * @fileoverview Disallow string concatenation when using __dirname and __filename\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow string concatenation with `__dirname` and `__filename`\",\n            category: \"Node.js and CommonJS\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        const MATCHER = /^__(?:dir|file)name$/;\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            BinaryExpression(node) {\n\n                const left = node.left,\n                    right = node.right;\n\n                if (node.operator === \"+\" &&\n                        ((left.type === \"Identifier\" && MATCHER.test(left.name)) ||\n                        (right.type === \"Identifier\" && MATCHER.test(right.name)))\n                ) {\n\n                    context.report({ node, message: \"Use path.join() or path.resolve() instead of + to create paths.\" });\n                }\n            }\n\n        };\n\n    }\n};\n","no-plusplus.js":"/**\n * @fileoverview Rule to flag use of unary increment and decrement operators.\n * @author Ian Christian Myers\n * @author Brody McKee (github.com/mrmckeb)\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the unary operators `++` and `--`\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowForLoopAfterthoughts: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const config = context.options[0];\n        let allowInForAfterthought = false;\n\n        if (typeof config === \"object\") {\n            allowInForAfterthought = config.allowForLoopAfterthoughts === true;\n        }\n\n        return {\n\n            UpdateExpression(node) {\n                if (allowInForAfterthought && node.parent.type === \"ForStatement\") {\n                    return;\n                }\n                context.report({\n                    node,\n                    message: \"Unary operator '{{operator}}' used.\",\n                    data: {\n                        operator: node.operator\n                    }\n                });\n            }\n\n        };\n\n    }\n};\n","no-process-env.js":"/**\n * @fileoverview Disallow the use of process.env()\n * @author Vignesh Anand\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of `process.env`\",\n            category: \"Node.js and CommonJS\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            MemberExpression(node) {\n                const objectName = node.object.name,\n                    propertyName = node.property.name;\n\n                if (objectName === \"process\" && !node.computed && propertyName && propertyName === \"env\") {\n                    context.report({ node, message: \"Unexpected use of process.env.\" });\n                }\n\n            }\n\n        };\n\n    }\n};\n","no-process-exit.js":"/**\n * @fileoverview Disallow the use of process.exit()\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of `process.exit()`\",\n            category: \"Node.js and CommonJS\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            \"CallExpression > MemberExpression.callee[object.name = 'process'][property.name = 'exit']\"(node) {\n                context.report({ node: node.parent, message: \"Don't use process.exit(); throw an error instead.\" });\n            }\n        };\n\n    }\n};\n","no-proto.js":"/**\n * @fileoverview Rule to flag usage of __proto__ property\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of the `__proto__` property\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            MemberExpression(node) {\n\n                if (node.property &&\n                        (node.property.type === \"Identifier\" && node.property.name === \"__proto__\" && !node.computed) ||\n                        (node.property.type === \"Literal\" && node.property.value === \"__proto__\")) {\n                    context.report({ node, message: \"The '__proto__' property is deprecated.\" });\n                }\n            }\n        };\n\n    }\n};\n","no-prototype-builtins.js":"/**\n * @fileoverview Rule to disallow use of Object.prototype builtins on objects\n * @author Andrew Levine\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow calling some `Object.prototype` methods directly on objects\",\n            category: \"Possible Errors\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const DISALLOWED_PROPS = [\n            \"hasOwnProperty\",\n            \"isPrototypeOf\",\n            \"propertyIsEnumerable\"\n        ];\n\n        /**\n         * Reports if a disallowed property is used in a CallExpression\n         * @param {ASTNode} node The CallExpression node.\n         * @returns {void}\n         */\n        function disallowBuiltIns(node) {\n            if (node.callee.type !== \"MemberExpression\" || node.callee.computed) {\n                return;\n            }\n            const propName = node.callee.property.name;\n\n            if (DISALLOWED_PROPS.indexOf(propName) > -1) {\n                context.report({\n                    message: \"Do not access Object.prototype method '{{prop}}' from target object.\",\n                    loc: node.callee.property.loc.start,\n                    data: { prop: propName },\n                    node\n                });\n            }\n        }\n\n        return {\n            CallExpression: disallowBuiltIns\n        };\n    }\n};\n","no-redeclare.js":"/**\n * @fileoverview Rule to flag when the same variable is declared more then once.\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow variable redeclaration\",\n            category: \"Best Practices\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    builtinGlobals: { type: \"boolean\" }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = {\n            builtinGlobals: Boolean(context.options[0] && context.options[0].builtinGlobals)\n        };\n\n        /**\n         * Find variables in a given scope and flag redeclared ones.\n         * @param {Scope} scope - An eslint-scope scope object.\n         * @returns {void}\n         * @private\n         */\n        function findVariablesInScope(scope) {\n            scope.variables.forEach(variable => {\n                const hasBuiltin = options.builtinGlobals && \"writeable\" in variable;\n                const count = (hasBuiltin ? 1 : 0) + variable.identifiers.length;\n\n                if (count >= 2) {\n                    variable.identifiers.sort((a, b) => a.range[1] - b.range[1]);\n\n                    for (let i = (hasBuiltin ? 0 : 1), l = variable.identifiers.length; i < l; i++) {\n                        context.report({ node: variable.identifiers[i], message: \"'{{a}}' is already defined.\", data: { a: variable.name } });\n                    }\n                }\n            });\n\n        }\n\n        /**\n         * Find variables in the current scope.\n         * @param {ASTNode} node - The Program node.\n         * @returns {void}\n         * @private\n         */\n        function checkForGlobal(node) {\n            const scope = context.getScope(),\n                parserOptions = context.parserOptions,\n                ecmaFeatures = parserOptions.ecmaFeatures || {};\n\n            // Nodejs env or modules has a special scope.\n            if (ecmaFeatures.globalReturn || node.sourceType === \"module\") {\n                findVariablesInScope(scope.childScopes[0]);\n            } else {\n                findVariablesInScope(scope);\n            }\n        }\n\n        /**\n         * Find variables in the current scope.\n         * @returns {void}\n         * @private\n         */\n        function checkForBlock() {\n            findVariablesInScope(context.getScope());\n        }\n\n        if (context.parserOptions.ecmaVersion >= 6) {\n            return {\n                Program: checkForGlobal,\n                BlockStatement: checkForBlock,\n                SwitchStatement: checkForBlock\n            };\n        }\n        return {\n            Program: checkForGlobal,\n            FunctionDeclaration: checkForBlock,\n            FunctionExpression: checkForBlock,\n            ArrowFunctionExpression: checkForBlock\n        };\n\n    }\n};\n","no-regex-spaces.js":"/**\n * @fileoverview Rule to count multiple spaces in regular expressions\n * @author Matt DuVall <http://www.mattduvall.com/>\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow multiple spaces in regular expressions\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Validate regular expressions\n         * @param {ASTNode} node node to validate\n         * @param {string} value regular expression to validate\n         * @param {number} valueStart The start location of the regex/string literal. It will always be the case that\n         `sourceCode.getText().slice(valueStart, valueStart + value.length) === value`\n         * @returns {void}\n         * @private\n         */\n        function checkRegex(node, value, valueStart) {\n            const multipleSpacesRegex = /( {2,})( [+*{?]|[^+*{?]|$)/,\n                regexResults = multipleSpacesRegex.exec(value);\n\n            if (regexResults !== null) {\n                const count = regexResults[1].length;\n\n                context.report({\n                    node,\n                    message: \"Spaces are hard to count. Use {{{count}}}.\",\n                    data: { count },\n                    fix(fixer) {\n                        return fixer.replaceTextRange(\n                            [valueStart + regexResults.index, valueStart + regexResults.index + count],\n                            ` {${count}}`\n                        );\n                    }\n                });\n\n                /*\n                 * TODO: (platinumazure) Fix message to use rule message\n                 * substitution when api.report is fixed in lib/eslint.js.\n                 */\n            }\n        }\n\n        /**\n         * Validate regular expression literals\n         * @param {ASTNode} node node to validate\n         * @returns {void}\n         * @private\n         */\n        function checkLiteral(node) {\n            const token = sourceCode.getFirstToken(node),\n                nodeType = token.type,\n                nodeValue = token.value;\n\n            if (nodeType === \"RegularExpression\") {\n                checkRegex(node, nodeValue, token.range[0]);\n            }\n        }\n\n        /**\n         * Check if node is a string\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} True if its a string\n         * @private\n         */\n        function isString(node) {\n            return node && node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        /**\n         * Validate strings passed to the RegExp constructor\n         * @param {ASTNode} node node to validate\n         * @returns {void}\n         * @private\n         */\n        function checkFunction(node) {\n            const scope = context.getScope();\n            const regExpVar = astUtils.getVariableByName(scope, \"RegExp\");\n            const shadowed = regExpVar && regExpVar.defs.length > 0;\n\n            if (node.callee.type === \"Identifier\" && node.callee.name === \"RegExp\" && isString(node.arguments[0]) && !shadowed) {\n                checkRegex(node, node.arguments[0].value, node.arguments[0].range[0] + 1);\n            }\n        }\n\n        return {\n            Literal: checkLiteral,\n            CallExpression: checkFunction,\n            NewExpression: checkFunction\n        };\n\n    }\n};\n","no-restricted-globals.js":"/**\n * @fileoverview Restrict usage of specified globals.\n * @author BenoÃ®t Zugmeyer\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_MESSAGE_TEMPLATE = \"Unexpected use of '{{name}}'.\",\n    CUSTOM_MESSAGE_TEMPLATE = \"Unexpected use of '{{name}}'. {{customMessage}}\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow specified global variables\",\n            category: \"Variables\",\n            recommended: false\n        },\n\n        schema: {\n            type: \"array\",\n            items: {\n                oneOf: [\n                    {\n                        type: \"string\"\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            name: { type: \"string\" },\n                            message: { type: \"string\" }\n                        },\n                        required: [\"name\"],\n                        additionalProperties: false\n                    }\n                ]\n            },\n            uniqueItems: true,\n            minItems: 0\n        }\n    },\n\n    create(context) {\n\n        // If no globals are restricted, we don't need to do anything\n        if (context.options.length === 0) {\n            return {};\n        }\n\n        const restrictedGlobalMessages = context.options.reduce((memo, option) => {\n            if (typeof option === \"string\") {\n                memo[option] = null;\n            } else {\n                memo[option.name] = option.message;\n            }\n\n            return memo;\n        }, {});\n\n        /**\n         * Report a variable to be used as a restricted global.\n         * @param {Reference} reference the variable reference\n         * @returns {void}\n         * @private\n         */\n        function reportReference(reference) {\n            const name = reference.identifier.name,\n                customMessage = restrictedGlobalMessages[name],\n                message = customMessage\n                    ? CUSTOM_MESSAGE_TEMPLATE\n                    : DEFAULT_MESSAGE_TEMPLATE;\n\n            context.report({\n                node: reference.identifier,\n                message,\n                data: {\n                    name,\n                    customMessage\n                }\n            });\n        }\n\n        /**\n         * Check if the given name is a restricted global name.\n         * @param {string} name name of a variable\n         * @returns {boolean} whether the variable is a restricted global or not\n         * @private\n         */\n        function isRestricted(name) {\n            return restrictedGlobalMessages.hasOwnProperty(name);\n        }\n\n        return {\n            Program() {\n                const scope = context.getScope();\n\n                // Report variables declared elsewhere (ex: variables defined as \"global\" by eslint)\n                scope.variables.forEach(variable => {\n                    if (!variable.defs.length && isRestricted(variable.name)) {\n                        variable.references.forEach(reportReference);\n                    }\n                });\n\n                // Report variables not declared at all\n                scope.through.forEach(reference => {\n                    if (isRestricted(reference.identifier.name)) {\n                        reportReference(reference);\n                    }\n                });\n\n            }\n        };\n    }\n};\n","no-restricted-imports.js":"/**\n * @fileoverview Restrict usage of specified node imports.\n * @author Guy Ellis\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst ignore = require(\"ignore\");\n\nconst arrayOfStrings = {\n    type: \"array\",\n    items: {\n        type: \"string\"\n    },\n    uniqueItems: true\n};\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow specified modules when loaded by `import`\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: {\n            anyOf: [\n                arrayOfStrings,\n                {\n                    type: \"array\",\n                    items: [{\n                        type: \"object\",\n                        properties: {\n                            paths: arrayOfStrings,\n                            patterns: arrayOfStrings\n                        },\n                        additionalProperties: false\n                    }],\n                    additionalItems: false\n                }\n            ]\n        }\n    },\n\n    create(context) {\n        const options = Array.isArray(context.options) ? context.options : [];\n        const isStringArray = typeof options[0] !== \"object\";\n        const restrictedPaths = new Set(isStringArray ? context.options : options[0].paths || []);\n        const restrictedPatterns = isStringArray ? [] : options[0].patterns || [];\n\n        // if no imports are restricted we don\"t need to check\n        if (restrictedPaths.size === 0 && restrictedPatterns.length === 0) {\n            return {};\n        }\n\n        const ig = ignore().add(restrictedPatterns);\n\n        return {\n            ImportDeclaration(node) {\n                if (node && node.source && node.source.value) {\n\n                    const importName = node.source.value.trim();\n\n                    if (restrictedPaths.has(importName)) {\n                        context.report({\n                            node,\n                            message: \"'{{importName}}' import is restricted from being used.\",\n                            data: { importName }\n                        });\n                    }\n                    if (restrictedPatterns.length > 0 && ig.ignores(importName)) {\n                        context.report({\n                            node,\n                            message: \"'{{importName}}' import is restricted from being used by a pattern.\",\n                            data: { importName }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n","no-restricted-modules.js":"/**\n * @fileoverview Restrict usage of specified node modules.\n * @author Christian Schulz\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst ignore = require(\"ignore\");\n\nconst arrayOfStrings = {\n    type: \"array\",\n    items: {\n        type: \"string\"\n    },\n    uniqueItems: true\n};\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow specified modules when loaded by `require`\",\n            category: \"Node.js and CommonJS\",\n            recommended: false\n        },\n\n        schema: {\n            anyOf: [\n                arrayOfStrings,\n                {\n                    type: \"array\",\n                    items: [{\n                        type: \"object\",\n                        properties: {\n                            paths: arrayOfStrings,\n                            patterns: arrayOfStrings\n                        },\n                        additionalProperties: false\n                    }],\n                    additionalItems: false\n                }\n            ]\n        }\n    },\n\n    create(context) {\n        const options = Array.isArray(context.options) ? context.options : [];\n        const isStringArray = typeof options[0] !== \"object\";\n        const restrictedPaths = new Set(isStringArray ? context.options : options[0].paths || []);\n        const restrictedPatterns = isStringArray ? [] : options[0].patterns || [];\n\n        // if no imports are restricted we don\"t need to check\n        if (restrictedPaths.size === 0 && restrictedPatterns.length === 0) {\n            return {};\n        }\n\n        const ig = ignore().add(restrictedPatterns);\n\n        /**\n         * Function to check if a node is a string literal.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} If the node is a string literal.\n         */\n        function isString(node) {\n            return node && node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        /**\n         * Function to check if a node is a require call.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} If the node is a require call.\n         */\n        function isRequireCall(node) {\n            return node.callee.type === \"Identifier\" && node.callee.name === \"require\";\n        }\n\n        return {\n            CallExpression(node) {\n                if (isRequireCall(node)) {\n\n                    // node has arguments and first argument is string\n                    if (node.arguments.length && isString(node.arguments[0])) {\n                        const moduleName = node.arguments[0].value.trim();\n\n                        // check if argument value is in restricted modules array\n                        if (restrictedPaths.has(moduleName)) {\n                            context.report({\n                                node,\n                                message: \"'{{moduleName}}' module is restricted from being used.\",\n                                data: { moduleName }\n                            });\n                        }\n\n                        if (restrictedPatterns.length > 0 && ig.ignores(moduleName)) {\n                            context.report({\n                                node,\n                                message: \"'{{moduleName}}' module is restricted from being used by a pattern.\",\n                                data: { moduleName }\n                            });\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n","no-restricted-properties.js":"/**\n * @fileoverview Rule to disallow certain object properties\n * @author Will Klein & Eli White\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow certain properties on certain objects\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: {\n            type: \"array\",\n            items: {\n                anyOf: [ // `object` and `property` are both optional, but at least one of them must be provided.\n                    {\n                        type: \"object\",\n                        properties: {\n                            object: {\n                                type: \"string\"\n                            },\n                            property: {\n                                type: \"string\"\n                            },\n                            message: {\n                                type: \"string\"\n                            }\n                        },\n                        additionalProperties: false,\n                        required: [\"object\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            object: {\n                                type: \"string\"\n                            },\n                            property: {\n                                type: \"string\"\n                            },\n                            message: {\n                                type: \"string\"\n                            }\n                        },\n                        additionalProperties: false,\n                        required: [\"property\"]\n                    }\n                ]\n            },\n            uniqueItems: true\n        }\n    },\n\n    create(context) {\n        const restrictedCalls = context.options;\n\n        if (restrictedCalls.length === 0) {\n            return {};\n        }\n\n        const restrictedProperties = new Map();\n        const globallyRestrictedObjects = new Map();\n        const globallyRestrictedProperties = new Map();\n\n        restrictedCalls.forEach(option => {\n            const objectName = option.object;\n            const propertyName = option.property;\n\n            if (typeof objectName === \"undefined\") {\n                globallyRestrictedProperties.set(propertyName, { message: option.message });\n            } else if (typeof propertyName === \"undefined\") {\n                globallyRestrictedObjects.set(objectName, { message: option.message });\n            } else {\n                if (!restrictedProperties.has(objectName)) {\n                    restrictedProperties.set(objectName, new Map());\n                }\n\n                restrictedProperties.get(objectName).set(propertyName, {\n                    message: option.message\n                });\n            }\n        });\n\n        /**\n        * Checks to see whether a property access is restricted, and reports it if so.\n        * @param {ASTNode} node The node to report\n        * @param {string} objectName The name of the object\n        * @param {string} propertyName The name of the property\n        * @returns {undefined}\n        */\n        function checkPropertyAccess(node, objectName, propertyName) {\n            if (propertyName === null) {\n                return;\n            }\n            const matchedObject = restrictedProperties.get(objectName);\n            const matchedObjectProperty = matchedObject ? matchedObject.get(propertyName) : globallyRestrictedObjects.get(objectName);\n            const globalMatchedProperty = globallyRestrictedProperties.get(propertyName);\n\n            if (matchedObjectProperty) {\n                const message = matchedObjectProperty.message ? ` ${matchedObjectProperty.message}` : \"\";\n\n                context.report({\n                    node,\n                    // eslint-disable-next-line eslint-plugin/report-message-format\n                    message: \"'{{objectName}}.{{propertyName}}' is restricted from being used.{{message}}\",\n                    data: {\n                        objectName,\n                        propertyName,\n                        message\n                    }\n                });\n            } else if (globalMatchedProperty) {\n                const message = globalMatchedProperty.message ? ` ${globalMatchedProperty.message}` : \"\";\n\n                context.report({\n                    node,\n                    // eslint-disable-next-line eslint-plugin/report-message-format\n                    message: \"'{{propertyName}}' is restricted from being used.{{message}}\",\n                    data: {\n                        propertyName,\n                        message\n                    }\n                });\n            }\n        }\n\n        /**\n        * Checks property accesses in a destructuring assignment expression, e.g. `var foo; ({foo} = bar);`\n        * @param {ASTNode} node An AssignmentExpression or AssignmentPattern node\n        * @returns {undefined}\n        */\n        function checkDestructuringAssignment(node) {\n            if (node.right.type === \"Identifier\") {\n                const objectName = node.right.name;\n\n                if (node.left.type === \"ObjectPattern\") {\n                    node.left.properties.forEach(property => {\n                        checkPropertyAccess(node.left, objectName, astUtils.getStaticPropertyName(property));\n                    });\n                }\n            }\n        }\n\n        return {\n            MemberExpression(node) {\n                checkPropertyAccess(node, node.object && node.object.name, astUtils.getStaticPropertyName(node));\n            },\n            VariableDeclarator(node) {\n                if (node.init && node.init.type === \"Identifier\") {\n                    const objectName = node.init.name;\n\n                    if (node.id.type === \"ObjectPattern\") {\n                        node.id.properties.forEach(property => {\n                            checkPropertyAccess(node.id, objectName, astUtils.getStaticPropertyName(property));\n                        });\n                    }\n                }\n            },\n            AssignmentExpression: checkDestructuringAssignment,\n            AssignmentPattern: checkDestructuringAssignment\n        };\n    }\n};\n","no-restricted-syntax.js":"/**\n * @fileoverview Rule to flag use of certain node types\n * @author Burak Yigit Kaya\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow specified syntax\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: {\n            type: \"array\",\n            items: [{\n                oneOf: [\n                    {\n                        type: \"string\"\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            selector: { type: \"string\" },\n                            message: { type: \"string\" }\n                        },\n                        required: [\"selector\"],\n                        additionalProperties: false\n                    }\n                ]\n            }],\n            uniqueItems: true,\n            minItems: 0\n        }\n    },\n\n    create(context) {\n        return context.options.reduce((result, selectorOrObject) => {\n            const isStringFormat = (typeof selectorOrObject === \"string\");\n            const hasCustomMessage = !isStringFormat && Boolean(selectorOrObject.message);\n\n            const selector = isStringFormat ? selectorOrObject : selectorOrObject.selector;\n            const message = hasCustomMessage ? selectorOrObject.message : \"Using '{{selector}}' is not allowed.\";\n\n            return Object.assign(result, {\n                [selector](node) {\n                    context.report({\n                        node,\n                        message,\n                        data: hasCustomMessage ? {} : { selector }\n                    });\n                }\n            });\n        }, {});\n\n    }\n};\n","no-return-assign.js":"/**\n * @fileoverview Rule to flag when return statement contains assignment\n * @author Ilya Volodin\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SENTINEL_TYPE = /^(?:[a-zA-Z]+?Statement|ArrowFunctionExpression|FunctionExpression|ClassExpression)$/;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow assignment operators in `return` statements\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"except-parens\", \"always\"]\n            }\n        ]\n    },\n\n    create(context) {\n        const always = (context.options[0] || \"except-parens\") !== \"except-parens\";\n        const sourceCode = context.getSourceCode();\n\n        return {\n            AssignmentExpression(node) {\n                if (!always && astUtils.isParenthesised(sourceCode, node)) {\n                    return;\n                }\n\n                let parent = node.parent;\n\n                // Find ReturnStatement or ArrowFunctionExpression in ancestors.\n                while (parent && !SENTINEL_TYPE.test(parent.type)) {\n                    node = parent;\n                    parent = parent.parent;\n                }\n\n                // Reports.\n                if (parent && parent.type === \"ReturnStatement\") {\n                    context.report({\n                        node: parent,\n                        message: \"Return statement should not contain assignment.\"\n                    });\n                } else if (parent && parent.type === \"ArrowFunctionExpression\" && parent.body === node) {\n                    context.report({\n                        node: parent,\n                        message: \"Arrow function should not return assignment.\"\n                    });\n                }\n            }\n        };\n    }\n};\n","no-return-await.js":"/**\n * @fileoverview Disallows unnecessary `return await`\n * @author Jordan Harband\n */\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst message = \"Redundant use of `await` on a return value.\";\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary `return await`\",\n            category: \"Best Practices\",\n            recommended: false // TODO: set to true\n        },\n        fixable: null,\n        schema: [\n        ]\n    },\n\n    create(context) {\n\n        /**\n         * Reports a found unnecessary `await` expression.\n         * @param {ASTNode} node The node representing the `await` expression to report\n         * @returns {void}\n         */\n        function reportUnnecessaryAwait(node) {\n            context.report({\n                node: context.getSourceCode().getFirstToken(node),\n                loc: node.loc,\n                message\n            });\n        }\n\n        /**\n        * Determines whether a thrown error from this node will be caught/handled within this function rather than immediately halting\n        * this function. For example, a statement in a `try` block will always have an error handler. A statement in\n        * a `catch` block will only have an error handler if there is also a `finally` block.\n        * @param {ASTNode} node A node representing a location where an could be thrown\n        * @returns {boolean} `true` if a thrown error will be caught/handled in this function\n        */\n        function hasErrorHandler(node) {\n            let ancestor = node;\n\n            while (!astUtils.isFunction(ancestor) && ancestor.type !== \"Program\") {\n                if (ancestor.parent.type === \"TryStatement\" && (ancestor === ancestor.parent.block || ancestor === ancestor.parent.handler && ancestor.parent.finalizer)) {\n                    return true;\n                }\n                ancestor = ancestor.parent;\n            }\n            return false;\n        }\n\n        /**\n         * Checks if a node is placed in tail call position. Once `return` arguments (or arrow function expressions) can be a complex expression,\n         * an `await` expression could or could not be unnecessary by the definition of this rule. So we're looking for `await` expressions that are in tail position.\n         * @param {ASTNode} node A node representing the `await` expression to check\n         * @returns {boolean} The checking result\n         */\n        function isInTailCallPosition(node) {\n            if (node.parent.type === \"ArrowFunctionExpression\") {\n                return true;\n            }\n            if (node.parent.type === \"ReturnStatement\") {\n                return !hasErrorHandler(node.parent);\n            }\n            if (node.parent.type === \"ConditionalExpression\" && (node === node.parent.consequent || node === node.parent.alternate)) {\n                return isInTailCallPosition(node.parent);\n            }\n            if (node.parent.type === \"LogicalExpression\" && node === node.parent.right) {\n                return isInTailCallPosition(node.parent);\n            }\n            if (node.parent.type === \"SequenceExpression\" && node === node.parent.expressions[node.parent.expressions.length - 1]) {\n                return isInTailCallPosition(node.parent);\n            }\n            return false;\n        }\n\n        return {\n            AwaitExpression(node) {\n                if (isInTailCallPosition(node) && !hasErrorHandler(node)) {\n                    reportUnnecessaryAwait(node);\n                }\n            }\n        };\n    }\n};\n","no-script-url.js":"/**\n * @fileoverview Rule to flag when using javascript: urls\n * @author Ilya Volodin\n */\n/* jshint scripturl: true */\n/* eslint no-script-url: 0 */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `javascript:` urls\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            Literal(node) {\n                if (node.value && typeof node.value === \"string\") {\n                    const value = node.value.toLowerCase();\n\n                    if (value.indexOf(\"javascript:\") === 0) {\n                        context.report({ node, message: \"Script URL is a form of eval.\" });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","no-self-assign.js":"/**\n * @fileoverview Rule to disallow assignments where both sides are exactly the same\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SPACES = /\\s+/g;\n\n/**\n * Checks whether the property of 2 given member expression nodes are the same\n * property or not.\n *\n * @param {ASTNode} left - A member expression node to check.\n * @param {ASTNode} right - Another member expression node to check.\n * @returns {boolean} `true` if the member expressions have the same property.\n */\nfunction isSameProperty(left, right) {\n    if (left.property.type === \"Identifier\" &&\n        left.property.type === right.property.type &&\n        left.property.name === right.property.name &&\n        left.computed === right.computed\n    ) {\n        return true;\n    }\n\n    const lname = astUtils.getStaticPropertyName(left);\n    const rname = astUtils.getStaticPropertyName(right);\n\n    return lname !== null && lname === rname;\n}\n\n/**\n * Checks whether 2 given member expression nodes are the reference to the same\n * property or not.\n *\n * @param {ASTNode} left - A member expression node to check.\n * @param {ASTNode} right - Another member expression node to check.\n * @returns {boolean} `true` if the member expressions are the reference to the\n *  same property or not.\n */\nfunction isSameMember(left, right) {\n    if (!isSameProperty(left, right)) {\n        return false;\n    }\n\n    const lobj = left.object;\n    const robj = right.object;\n\n    if (lobj.type !== robj.type) {\n        return false;\n    }\n    if (lobj.type === \"MemberExpression\") {\n        return isSameMember(lobj, robj);\n    }\n    return lobj.type === \"Identifier\" && lobj.name === robj.name;\n}\n\n/**\n * Traverses 2 Pattern nodes in parallel, then reports self-assignments.\n *\n * @param {ASTNode|null} left - A left node to traverse. This is a Pattern or\n *      a Property.\n * @param {ASTNode|null} right - A right node to traverse. This is a Pattern or\n *      a Property.\n * @param {boolean} props - The flag to check member expressions as well.\n * @param {Function} report - A callback function to report.\n * @returns {void}\n */\nfunction eachSelfAssignment(left, right, props, report) {\n    if (!left || !right) {\n\n        // do nothing\n    } else if (\n        left.type === \"Identifier\" &&\n        right.type === \"Identifier\" &&\n        left.name === right.name\n    ) {\n        report(right);\n    } else if (\n        left.type === \"ArrayPattern\" &&\n        right.type === \"ArrayExpression\"\n    ) {\n        const end = Math.min(left.elements.length, right.elements.length);\n\n        for (let i = 0; i < end; ++i) {\n            const rightElement = right.elements[i];\n\n            eachSelfAssignment(left.elements[i], rightElement, props, report);\n\n            // After a spread element, those indices are unknown.\n            if (rightElement && rightElement.type === \"SpreadElement\") {\n                break;\n            }\n        }\n    } else if (\n        left.type === \"RestElement\" &&\n        right.type === \"SpreadElement\"\n    ) {\n        eachSelfAssignment(left.argument, right.argument, props, report);\n    } else if (\n        left.type === \"ObjectPattern\" &&\n        right.type === \"ObjectExpression\" &&\n        right.properties.length >= 1\n    ) {\n\n        // Gets the index of the last spread property.\n        // It's possible to overwrite properties followed by it.\n        let startJ = 0;\n\n        for (let i = right.properties.length - 1; i >= 0; --i) {\n            if (right.properties[i].type === \"ExperimentalSpreadProperty\") {\n                startJ = i + 1;\n                break;\n            }\n        }\n\n        for (let i = 0; i < left.properties.length; ++i) {\n            for (let j = startJ; j < right.properties.length; ++j) {\n                eachSelfAssignment(\n                    left.properties[i],\n                    right.properties[j],\n                    props,\n                    report\n                );\n            }\n        }\n    } else if (\n        left.type === \"Property\" &&\n        right.type === \"Property\" &&\n        !left.computed &&\n        !right.computed &&\n        right.kind === \"init\" &&\n        !right.method &&\n        left.key.name === right.key.name\n    ) {\n        eachSelfAssignment(left.value, right.value, props, report);\n    } else if (\n        props &&\n        left.type === \"MemberExpression\" &&\n        right.type === \"MemberExpression\" &&\n        isSameMember(left, right)\n    ) {\n        report(right);\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow assignments where both sides are exactly the same\",\n            category: \"Best Practices\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    props: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = context.options[0];\n        const props = Boolean(options && options.props);\n\n        /**\n         * Reports a given node as self assignments.\n         *\n         * @param {ASTNode} node - A node to report. This is an Identifier node.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node,\n                message: \"'{{name}}' is assigned to itself.\",\n                data: {\n                    name: sourceCode.getText(node).replace(SPACES, \"\")\n                }\n            });\n        }\n\n        return {\n            AssignmentExpression(node) {\n                if (node.operator === \"=\") {\n                    eachSelfAssignment(node.left, node.right, props, report);\n                }\n            }\n        };\n    }\n};\n","no-self-compare.js":"/**\n * @fileoverview Rule to flag comparison where left part is the same as the right\n * part.\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow comparisons where both sides are exactly the same\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether two nodes are composed of the same tokens.\n         * @param {ASTNode} nodeA The first node\n         * @param {ASTNode} nodeB The second node\n         * @returns {boolean} true if the nodes have identical token representations\n         */\n        function hasSameTokens(nodeA, nodeB) {\n            const tokensA = sourceCode.getTokens(nodeA);\n            const tokensB = sourceCode.getTokens(nodeB);\n\n            return tokensA.length === tokensB.length &&\n                tokensA.every((token, index) => token.type === tokensB[index].type && token.value === tokensB[index].value);\n        }\n\n        return {\n\n            BinaryExpression(node) {\n                const operators = new Set([\"===\", \"==\", \"!==\", \"!=\", \">\", \"<\", \">=\", \"<=\"]);\n\n                if (operators.has(node.operator) && hasSameTokens(node.left, node.right)) {\n                    context.report({ node, message: \"Comparing to itself is potentially pointless.\" });\n                }\n            }\n        };\n\n    }\n};\n","no-sequences.js":"/**\n * @fileoverview Rule to flag use of comma operator\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow comma operators\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Parts of the grammar that are required to have parens.\n         */\n        const parenthesized = {\n            DoWhileStatement: \"test\",\n            IfStatement: \"test\",\n            SwitchStatement: \"discriminant\",\n            WhileStatement: \"test\",\n            WithStatement: \"object\",\n            ArrowFunctionExpression: \"body\"\n\n            // Omitting CallExpression - commas are parsed as argument separators\n            // Omitting NewExpression - commas are parsed as argument separators\n            // Omitting ForInStatement - parts aren't individually parenthesised\n            // Omitting ForStatement - parts aren't individually parenthesised\n        };\n\n        /**\n         * Determines whether a node is required by the grammar to be wrapped in\n         * parens, e.g. the test of an if statement.\n         * @param {ASTNode} node - The AST node\n         * @returns {boolean} True if parens around node belong to parent node.\n         */\n        function requiresExtraParens(node) {\n            return node.parent && parenthesized[node.parent.type] &&\n                    node === node.parent[parenthesized[node.parent.type]];\n        }\n\n        /**\n         * Check if a node is wrapped in parens.\n         * @param {ASTNode} node - The AST node\n         * @returns {boolean} True if the node has a paren on each side.\n         */\n        function isParenthesised(node) {\n            return astUtils.isParenthesised(sourceCode, node);\n        }\n\n        /**\n         * Check if a node is wrapped in two levels of parens.\n         * @param {ASTNode} node - The AST node\n         * @returns {boolean} True if two parens surround the node on each side.\n         */\n        function isParenthesisedTwice(node) {\n            const previousToken = sourceCode.getTokenBefore(node, 1),\n                nextToken = sourceCode.getTokenAfter(node, 1);\n\n            return isParenthesised(node) && previousToken && nextToken &&\n                astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] &&\n                astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];\n        }\n\n        return {\n            SequenceExpression(node) {\n\n                // Always allow sequences in for statement update\n                if (node.parent.type === \"ForStatement\" &&\n                        (node === node.parent.init || node === node.parent.update)) {\n                    return;\n                }\n\n                // Wrapping a sequence in extra parens indicates intent\n                if (requiresExtraParens(node)) {\n                    if (isParenthesisedTwice(node)) {\n                        return;\n                    }\n                } else {\n                    if (isParenthesised(node)) {\n                        return;\n                    }\n                }\n\n                const child = sourceCode.getTokenAfter(node.expressions[0]);\n\n                context.report({ node, loc: child.loc.start, message: \"Unexpected use of comma operator.\" });\n            }\n        };\n\n    }\n};\n","no-shadow-restricted-names.js":"/**\n * @fileoverview Disallow shadowing of NaN, undefined, and Infinity (ES5 section 15.1.1)\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow identifiers from shadowing restricted names\",\n            category: \"Variables\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        const RESTRICTED = [\"undefined\", \"NaN\", \"Infinity\", \"arguments\", \"eval\"];\n\n        /**\n         * Check if the node name is present inside the restricted list\n         * @param {ASTNode} id id to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForViolation(id) {\n            if (RESTRICTED.indexOf(id.name) > -1) {\n                context.report({\n                    node: id,\n                    message: \"Shadowing of global property '{{idName}}'.\",\n                    data: {\n                        idName: id.name\n                    }\n                });\n            }\n        }\n\n        return {\n            VariableDeclarator(node) {\n                checkForViolation(node.id);\n            },\n            ArrowFunctionExpression(node) {\n                [].map.call(node.params, checkForViolation);\n            },\n            FunctionExpression(node) {\n                if (node.id) {\n                    checkForViolation(node.id);\n                }\n                [].map.call(node.params, checkForViolation);\n            },\n            FunctionDeclaration(node) {\n                if (node.id) {\n                    checkForViolation(node.id);\n                    [].map.call(node.params, checkForViolation);\n                }\n            },\n            CatchClause(node) {\n                checkForViolation(node.param);\n            }\n        };\n\n    }\n};\n","no-shadow.js":"/**\n * @fileoverview Rule to flag on declaring variables already declared in the outer scope\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow variable declarations from shadowing variables declared in the outer scope\",\n            category: \"Variables\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    builtinGlobals: { type: \"boolean\" },\n                    hoist: { enum: [\"all\", \"functions\", \"never\"] },\n                    allow: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const options = {\n            builtinGlobals: Boolean(context.options[0] && context.options[0].builtinGlobals),\n            hoist: (context.options[0] && context.options[0].hoist) || \"functions\",\n            allow: (context.options[0] && context.options[0].allow) || []\n        };\n\n        /**\n         * Check if variable name is allowed.\n         *\n         * @param  {ASTNode} variable The variable to check.\n         * @returns {boolean} Whether or not the variable name is allowed.\n         */\n        function isAllowed(variable) {\n            return options.allow.indexOf(variable.name) !== -1;\n        }\n\n        /**\n         * Checks if a variable of the class name in the class scope of ClassDeclaration.\n         *\n         * ClassDeclaration creates two variables of its name into its outer scope and its class scope.\n         * So we should ignore the variable in the class scope.\n         *\n         * @param {Object} variable The variable to check.\n         * @returns {boolean} Whether or not the variable of the class name in the class scope of ClassDeclaration.\n         */\n        function isDuplicatedClassNameVariable(variable) {\n            const block = variable.scope.block;\n\n            return block.type === \"ClassDeclaration\" && block.id === variable.identifiers[0];\n        }\n\n        /**\n         * Checks if a variable is inside the initializer of scopeVar.\n         *\n         * To avoid reporting at declarations such as `var a = function a() {};`.\n         * But it should report `var a = function(a) {};` or `var a = function() { function a() {} };`.\n         *\n         * @param {Object} variable The variable to check.\n         * @param {Object} scopeVar The scope variable to look for.\n         * @returns {boolean} Whether or not the variable is inside initializer of scopeVar.\n         */\n        function isOnInitializer(variable, scopeVar) {\n            const outerScope = scopeVar.scope;\n            const outerDef = scopeVar.defs[0];\n            const outer = outerDef && outerDef.parent && outerDef.parent.range;\n            const innerScope = variable.scope;\n            const innerDef = variable.defs[0];\n            const inner = innerDef && innerDef.name.range;\n\n            return (\n                outer &&\n                inner &&\n                outer[0] < inner[0] &&\n                inner[1] < outer[1] &&\n                ((innerDef.type === \"FunctionName\" && innerDef.node.type === \"FunctionExpression\") || innerDef.node.type === \"ClassExpression\") &&\n                outerScope === innerScope.upper\n            );\n        }\n\n        /**\n         * Get a range of a variable's identifier node.\n         * @param {Object} variable The variable to get.\n         * @returns {Array|undefined} The range of the variable's identifier node.\n         */\n        function getNameRange(variable) {\n            const def = variable.defs[0];\n\n            return def && def.name.range;\n        }\n\n        /**\n         * Checks if a variable is in TDZ of scopeVar.\n         * @param {Object} variable The variable to check.\n         * @param {Object} scopeVar The variable of TDZ.\n         * @returns {boolean} Whether or not the variable is in TDZ of scopeVar.\n         */\n        function isInTdz(variable, scopeVar) {\n            const outerDef = scopeVar.defs[0];\n            const inner = getNameRange(variable);\n            const outer = getNameRange(scopeVar);\n\n            return (\n                inner &&\n                outer &&\n                inner[1] < outer[0] &&\n\n                // Excepts FunctionDeclaration if is {\"hoist\":\"function\"}.\n                (options.hoist !== \"functions\" || !outerDef || outerDef.node.type !== \"FunctionDeclaration\")\n            );\n        }\n\n        /**\n         * Checks the current context for shadowed variables.\n         * @param {Scope} scope - Fixme\n         * @returns {void}\n         */\n        function checkForShadows(scope) {\n            const variables = scope.variables;\n\n            for (let i = 0; i < variables.length; ++i) {\n                const variable = variables[i];\n\n                // Skips \"arguments\" or variables of a class name in the class scope of ClassDeclaration.\n                if (variable.identifiers.length === 0 ||\n                    isDuplicatedClassNameVariable(variable) ||\n                    isAllowed(variable)\n                ) {\n                    continue;\n                }\n\n                // Gets shadowed variable.\n                const shadowed = astUtils.getVariableByName(scope.upper, variable.name);\n\n                if (shadowed &&\n                    (shadowed.identifiers.length > 0 || (options.builtinGlobals && \"writeable\" in shadowed)) &&\n                    !isOnInitializer(variable, shadowed) &&\n                    !(options.hoist !== \"all\" && isInTdz(variable, shadowed))\n                ) {\n                    context.report({\n                        node: variable.identifiers[0],\n                        message: \"'{{name}}' is already declared in the upper scope.\",\n                        data: variable\n                    });\n                }\n            }\n        }\n\n        return {\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n                const stack = globalScope.childScopes.slice();\n\n                while (stack.length) {\n                    const scope = stack.pop();\n\n                    stack.push.apply(stack, scope.childScopes);\n                    checkForShadows(scope);\n                }\n            }\n        };\n\n    }\n};\n","no-spaced-func.js":"/**\n * @fileoverview Rule to check that spaced function application\n * @author Matt DuVall <http://www.mattduvall.com>\n * @deprecated in ESLint v3.3.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow spacing between function identifiers and their applications (deprecated)\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            replacedBy: [\"func-call-spacing\"]\n        },\n\n        deprecated: true,\n\n        fixable: \"whitespace\",\n        schema: []\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Check if open space is present in a function name\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function detectOpenSpaces(node) {\n            const lastCalleeToken = sourceCode.getLastToken(node.callee);\n            let prevToken = lastCalleeToken,\n                parenToken = sourceCode.getTokenAfter(lastCalleeToken);\n\n            // advances to an open parenthesis.\n            while (\n                parenToken &&\n                parenToken.range[1] < node.range[1] &&\n                parenToken.value !== \"(\"\n            ) {\n                prevToken = parenToken;\n                parenToken = sourceCode.getTokenAfter(parenToken);\n            }\n\n            // look for a space between the callee and the open paren\n            if (parenToken &&\n                parenToken.range[1] < node.range[1] &&\n                sourceCode.isSpaceBetweenTokens(prevToken, parenToken)\n            ) {\n                context.report({\n                    node,\n                    loc: lastCalleeToken.loc.start,\n                    message: \"Unexpected space between function name and paren.\",\n                    fix(fixer) {\n                        return fixer.removeRange([prevToken.range[1], parenToken.range[0]]);\n                    }\n                });\n            }\n        }\n\n        return {\n            CallExpression: detectOpenSpaces,\n            NewExpression: detectOpenSpaces\n        };\n\n    }\n};\n","no-sparse-arrays.js":"/**\n * @fileoverview Disallow sparse arrays\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow sparse arrays\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            ArrayExpression(node) {\n\n                const emptySpot = node.elements.indexOf(null) > -1;\n\n                if (emptySpot) {\n                    context.report({ node, message: \"Unexpected comma in middle of array.\" });\n                }\n            }\n\n        };\n\n    }\n};\n","no-sync.js":"/**\n * @fileoverview Rule to check for properties whose identifier ends with the string Sync\n * @author Matt DuVall<http://mattduvall.com/>\n */\n\n/* jshint node:true */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow synchronous methods\",\n            category: \"Node.js and CommonJS\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowAtRootLevel: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const selector = context.options[0] && context.options[0].allowAtRootLevel\n            ? \":function MemberExpression[property.name=/.*Sync$/]\"\n            : \"MemberExpression[property.name=/.*Sync$/]\";\n\n        return {\n            [selector](node) {\n                context.report({\n                    node,\n                    message: \"Unexpected sync method: '{{propertyName}}'.\",\n                    data: {\n                        propertyName: node.property.name\n                    }\n                });\n            }\n        };\n\n    }\n};\n","no-tabs.js":"/**\n * @fileoverview Rule to check for tabs inside a file\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\nconst regex = /\\t/;\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow all tabs\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        schema: []\n    },\n\n    create(context) {\n        return {\n            Program(node) {\n                context.getSourceCode().getLines().forEach((line, index) => {\n                    const match = regex.exec(line);\n\n                    if (match) {\n                        context.report({\n                            node,\n                            loc: {\n                                line: index + 1,\n                                column: match.index + 1\n                            },\n                            message: \"Unexpected tab character.\"\n                        });\n                    }\n                });\n            }\n        };\n    }\n};\n","no-template-curly-in-string.js":"/**\n * @fileoverview Warn when using template string syntax in regular strings\n * @author Jeroen Engels\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow template literal placeholder syntax in regular strings\",\n            category: \"Possible Errors\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const regex = /\\$\\{[^}]+\\}/;\n\n        return {\n            Literal(node) {\n                if (typeof node.value === \"string\" && regex.test(node.value)) {\n                    context.report({\n                        node,\n                        message: \"Unexpected template string expression.\"\n                    });\n                }\n            }\n        };\n\n    }\n};\n","no-ternary.js":"/**\n * @fileoverview Rule to flag use of ternary operators.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow ternary operators\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            ConditionalExpression(node) {\n                context.report({ node, message: \"Ternary operator used.\" });\n            }\n\n        };\n\n    }\n};\n","no-this-before-super.js":"/**\n * @fileoverview A rule to disallow using `this`/`super` before `super()`.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a constructor.\n * @param {ASTNode} node - A node to check. This node type is one of\n *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and\n *   `ArrowFunctionExpression`.\n * @returns {boolean} `true` if the node is a constructor.\n */\nfunction isConstructorFunction(node) {\n    return (\n        node.type === \"FunctionExpression\" &&\n        node.parent.type === \"MethodDefinition\" &&\n        node.parent.kind === \"constructor\"\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `this`/`super` before calling `super()` in constructors\",\n            category: \"ECMAScript 6\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /*\n         * Information for each constructor.\n         * - upper:      Information of the upper constructor.\n         * - hasExtends: A flag which shows whether the owner class has a valid\n         *   `extends` part.\n         * - scope:      The scope of the owner class.\n         * - codePath:   The code path of this constructor.\n         */\n        let funcInfo = null;\n\n        /*\n         * Information for each code path segment.\n         * Each key is the id of a code path segment.\n         * Each value is an object:\n         * - superCalled:  The flag which shows `super()` called in all code paths.\n         * - invalidNodes: The array of invalid ThisExpression and Super nodes.\n         */\n        let segInfoMap = Object.create(null);\n\n        /**\n         * Gets whether or not `super()` is called in a given code path segment.\n         * @param {CodePathSegment} segment - A code path segment to get.\n         * @returns {boolean} `true` if `super()` is called.\n         */\n        function isCalled(segment) {\n            return !segment.reachable || segInfoMap[segment.id].superCalled;\n        }\n\n        /**\n         * Checks whether or not this is in a constructor.\n         * @returns {boolean} `true` if this is in a constructor.\n         */\n        function isInConstructorOfDerivedClass() {\n            return Boolean(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends);\n        }\n\n        /**\n         * Checks whether or not this is before `super()` is called.\n         * @returns {boolean} `true` if this is before `super()` is called.\n         */\n        function isBeforeCallOfSuper() {\n            return (\n                isInConstructorOfDerivedClass() &&\n                !funcInfo.codePath.currentSegments.every(isCalled)\n            );\n        }\n\n        /**\n         * Sets a given node as invalid.\n         * @param {ASTNode} node - A node to set as invalid. This is one of\n         *      a ThisExpression and a Super.\n         * @returns {void}\n         */\n        function setInvalid(node) {\n            const segments = funcInfo.codePath.currentSegments;\n\n            for (let i = 0; i < segments.length; ++i) {\n                const segment = segments[i];\n\n                if (segment.reachable) {\n                    segInfoMap[segment.id].invalidNodes.push(node);\n                }\n            }\n        }\n\n        /**\n         * Sets the current segment as `super` was called.\n         * @returns {void}\n         */\n        function setSuperCalled() {\n            const segments = funcInfo.codePath.currentSegments;\n\n            for (let i = 0; i < segments.length; ++i) {\n                const segment = segments[i];\n\n                if (segment.reachable) {\n                    segInfoMap[segment.id].superCalled = true;\n                }\n            }\n        }\n\n        return {\n\n            /**\n             * Adds information of a constructor into the stack.\n             * @param {CodePath} codePath - A code path which was started.\n             * @param {ASTNode} node - The current node.\n             * @returns {void}\n             */\n            onCodePathStart(codePath, node) {\n                if (isConstructorFunction(node)) {\n\n                    // Class > ClassBody > MethodDefinition > FunctionExpression\n                    const classNode = node.parent.parent.parent;\n\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: true,\n                        hasExtends: Boolean(\n                            classNode.superClass &&\n                            !astUtils.isNullOrUndefined(classNode.superClass)\n                        ),\n                        codePath\n                    };\n                } else {\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: false,\n                        hasExtends: false,\n                        codePath\n                    };\n                }\n            },\n\n            /**\n             * Removes the top of stack item.\n             *\n             * And this treverses all segments of this code path then reports every\n             * invalid node.\n             *\n             * @param {CodePath} codePath - A code path which was ended.\n             * @param {ASTNode} node - The current node.\n             * @returns {void}\n             */\n            onCodePathEnd(codePath) {\n                const isDerivedClass = funcInfo.hasExtends;\n\n                funcInfo = funcInfo.upper;\n                if (!isDerivedClass) {\n                    return;\n                }\n\n                codePath.traverseSegments((segment, controller) => {\n                    const info = segInfoMap[segment.id];\n\n                    for (let i = 0; i < info.invalidNodes.length; ++i) {\n                        const invalidNode = info.invalidNodes[i];\n\n                        context.report({\n                            message: \"'{{kind}}' is not allowed before 'super()'.\",\n                            node: invalidNode,\n                            data: {\n                                kind: invalidNode.type === \"Super\" ? \"super\" : \"this\"\n                            }\n                        });\n                    }\n\n                    if (info.superCalled) {\n                        controller.skip();\n                    }\n                });\n            },\n\n            /**\n             * Initialize information of a given code path segment.\n             * @param {CodePathSegment} segment - A code path segment to initialize.\n             * @returns {void}\n             */\n            onCodePathSegmentStart(segment) {\n                if (!isInConstructorOfDerivedClass()) {\n                    return;\n                }\n\n                // Initialize info.\n                segInfoMap[segment.id] = {\n                    superCalled: (\n                        segment.prevSegments.length > 0 &&\n                        segment.prevSegments.every(isCalled)\n                    ),\n                    invalidNodes: []\n                };\n            },\n\n            /**\n             * Update information of the code path segment when a code path was\n             * looped.\n             * @param {CodePathSegment} fromSegment - The code path segment of the\n             *      end of a loop.\n             * @param {CodePathSegment} toSegment - A code path segment of the head\n             *      of a loop.\n             * @returns {void}\n             */\n            onCodePathSegmentLoop(fromSegment, toSegment) {\n                if (!isInConstructorOfDerivedClass()) {\n                    return;\n                }\n\n                // Update information inside of the loop.\n                funcInfo.codePath.traverseSegments(\n                    { first: toSegment, last: fromSegment },\n                    (segment, controller) => {\n                        const info = segInfoMap[segment.id];\n\n                        if (info.superCalled) {\n                            info.invalidNodes = [];\n                            controller.skip();\n                        } else if (\n                            segment.prevSegments.length > 0 &&\n                            segment.prevSegments.every(isCalled)\n                        ) {\n                            info.superCalled = true;\n                            info.invalidNodes = [];\n                        }\n                    }\n                );\n            },\n\n            /**\n             * Reports if this is before `super()`.\n             * @param {ASTNode} node - A target node.\n             * @returns {void}\n             */\n            ThisExpression(node) {\n                if (isBeforeCallOfSuper()) {\n                    setInvalid(node);\n                }\n            },\n\n            /**\n             * Reports if this is before `super()`.\n             * @param {ASTNode} node - A target node.\n             * @returns {void}\n             */\n            Super(node) {\n                if (!astUtils.isCallee(node) && isBeforeCallOfSuper()) {\n                    setInvalid(node);\n                }\n            },\n\n            /**\n             * Marks `super()` called.\n             * @param {ASTNode} node - A target node.\n             * @returns {void}\n             */\n            \"CallExpression:exit\"(node) {\n                if (node.callee.type === \"Super\" && isBeforeCallOfSuper()) {\n                    setSuperCalled();\n                }\n            },\n\n            /**\n             * Resets state.\n             * @returns {void}\n             */\n            \"Program:exit\"() {\n                segInfoMap = Object.create(null);\n            }\n        };\n    }\n};\n","no-throw-literal.js":"/**\n * @fileoverview Rule to restrict what can be thrown as an exception.\n * @author Dieter Oberkofler\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow throwing literals as exceptions\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            ThrowStatement(node) {\n                if (!astUtils.couldBeError(node.argument)) {\n                    context.report({ node, message: \"Expected an object to be thrown.\" });\n                } else if (node.argument.type === \"Identifier\") {\n                    if (node.argument.name === \"undefined\") {\n                        context.report({ node, message: \"Do not throw undefined.\" });\n                    }\n                }\n\n            }\n\n        };\n\n    }\n};\n","no-trailing-spaces.js":"/**\n * @fileoverview Disallow trailing spaces at the end of lines.\n * @author Nodeca Team <https://github.com/nodeca>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow trailing whitespace at the end of lines\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    skipBlankLines: {\n                        type: \"boolean\"\n                    },\n                    ignoreComments: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const BLANK_CLASS = \"[ \\t\\u00a0\\u2000-\\u200b\\u3000]\",\n            SKIP_BLANK = `^${BLANK_CLASS}*$`,\n            NONBLANK = `${BLANK_CLASS}+$`;\n\n        const options = context.options[0] || {},\n            skipBlankLines = options.skipBlankLines || false,\n            ignoreComments = typeof options.ignoreComments === \"undefined\" || options.ignoreComments;\n\n        /**\n         * Report the error message\n         * @param {ASTNode} node node to report\n         * @param {int[]} location range information\n         * @param {int[]} fixRange Range based on the whole program\n         * @returns {void}\n         */\n        function report(node, location, fixRange) {\n\n            /*\n             * Passing node is a bit dirty, because message data will contain big\n             * text in `source`. But... who cares :) ?\n             * One more kludge will not make worse the bloody wizardry of this\n             * plugin.\n             */\n            context.report({\n                node,\n                loc: location,\n                message: \"Trailing spaces not allowed.\",\n                fix(fixer) {\n                    return fixer.removeRange(fixRange);\n                }\n            });\n        }\n\n        /**\n         * Given a list of comment nodes, return the line numbers for those comments.\n         * @param {Array} comments An array of comment nodes.\n         * @returns {number[]} An array of line numbers containing comments.\n         */\n        function getCommentLineNumbers(comments) {\n            const lines = new Set();\n\n            comments.forEach(comment => {\n                for (let i = comment.loc.start.line; i <= comment.loc.end.line; i++) {\n                    lines.add(i);\n                }\n            });\n\n            return lines;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            Program: function checkTrailingSpaces(node) {\n\n                // Let's hack. Since Espree does not return whitespace nodes,\n                // fetch the source code and do matching via regexps.\n\n                const re = new RegExp(NONBLANK),\n                    skipMatch = new RegExp(SKIP_BLANK),\n                    lines = sourceCode.lines,\n                    linebreaks = sourceCode.getText().match(astUtils.createGlobalLinebreakMatcher()),\n                    comments = sourceCode.getAllComments(),\n                    commentLineNumbers = getCommentLineNumbers(comments);\n\n                let totalLength = 0,\n                    fixRange = [];\n\n                for (let i = 0, ii = lines.length; i < ii; i++) {\n                    const matches = re.exec(lines[i]);\n\n                    // Always add linebreak length to line length to accommodate for line break (\\n or \\r\\n)\n                    // Because during the fix time they also reserve one spot in the array.\n                    // Usually linebreak length is 2 for \\r\\n (CRLF) and 1 for \\n (LF)\n                    const linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;\n                    const lineLength = lines[i].length + linebreakLength;\n\n                    if (matches) {\n                        const location = {\n                            line: i + 1,\n                            column: matches.index\n                        };\n\n                        const rangeStart = totalLength + location.column;\n                        const rangeEnd = totalLength + lineLength - linebreakLength;\n                        const containingNode = sourceCode.getNodeByRangeIndex(rangeStart);\n\n                        if (containingNode && containingNode.type === \"TemplateElement\" &&\n                          rangeStart > containingNode.parent.range[0] &&\n                          rangeEnd < containingNode.parent.range[1]) {\n                            totalLength += lineLength;\n                            continue;\n                        }\n\n                        // If the line has only whitespace, and skipBlankLines\n                        // is true, don't report it\n                        if (skipBlankLines && skipMatch.test(lines[i])) {\n                            totalLength += lineLength;\n                            continue;\n                        }\n\n                        fixRange = [rangeStart, rangeEnd];\n\n                        if (!ignoreComments || !commentLineNumbers.has(location.line)) {\n                            report(node, location, fixRange);\n                        }\n                    }\n\n                    totalLength += lineLength;\n                }\n            }\n\n        };\n    }\n};\n","no-undef-init.js":"/**\n * @fileoverview Rule to flag when initializing to undefined\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow initializing variables to `undefined`\",\n            category: \"Variables\",\n            recommended: false\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n\n        return {\n\n            VariableDeclarator(node) {\n                const name = sourceCode.getText(node.id),\n                    init = node.init && node.init.name,\n                    scope = context.getScope(),\n                    undefinedVar = astUtils.getVariableByName(scope, \"undefined\"),\n                    shadowed = undefinedVar && undefinedVar.defs.length > 0;\n\n                if (init === \"undefined\" && node.parent.kind !== \"const\" && !shadowed) {\n                    context.report({\n                        node,\n                        message: \"It's not necessary to initialize '{{name}}' to undefined.\",\n                        data: { name },\n                        fix(fixer) {\n                            if (node.parent.kind === \"var\") {\n                                return null;\n                            }\n\n                            if (node.id.type === \"ArrayPattern\" || node.id.type === \"ObjectPattern\") {\n\n                                // Don't fix destructuring assignment to `undefined`.\n                                return null;\n                            }\n                            return fixer.removeRange([node.id.range[1], node.range[1]]);\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","no-undef.js":"/**\n * @fileoverview Rule to flag references to undeclared variables.\n * @author Mark Macdonald\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks if the given node is the argument of a typeof operator.\n * @param {ASTNode} node The AST node being checked.\n * @returns {boolean} Whether or not the node is the argument of a typeof operator.\n */\nfunction hasTypeOfOperator(node) {\n    const parent = node.parent;\n\n    return parent.type === \"UnaryExpression\" && parent.operator === \"typeof\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of undeclared variables unless mentioned in `/*global */` comments\",\n            category: \"Variables\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    typeof: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = context.options[0];\n        const considerTypeOf = options && options.typeof === true || false;\n\n        return {\n            \"Program:exit\"(/* node */) {\n                const globalScope = context.getScope();\n\n                globalScope.through.forEach(ref => {\n                    const identifier = ref.identifier;\n\n                    if (!considerTypeOf && hasTypeOfOperator(identifier)) {\n                        return;\n                    }\n\n                    context.report({\n                        node: identifier,\n                        message: \"'{{name}}' is not defined.\",\n                        data: identifier\n                    });\n                });\n            }\n        };\n    }\n};\n","no-undefined.js":"/**\n * @fileoverview Rule to flag references to the undefined variable.\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of `undefined` as an identifier\",\n            category: \"Variables\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Report an invalid \"undefined\" identifier node.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node,\n                message: \"Unexpected use of undefined.\"\n            });\n        }\n\n        /**\n         * Checks the given scope for references to `undefined` and reports\n         * all references found.\n         * @param {eslint-scope.Scope} scope The scope to check.\n         * @returns {void}\n         */\n        function checkScope(scope) {\n            const undefinedVar = scope.set.get(\"undefined\");\n\n            if (!undefinedVar) {\n                return;\n            }\n\n            const references = undefinedVar.references;\n\n            const defs = undefinedVar.defs;\n\n            // Report non-initializing references (those are covered in defs below)\n            references\n                .filter(ref => !ref.init)\n                .forEach(ref => report(ref.identifier));\n\n            defs.forEach(def => report(def.name));\n        }\n\n        return {\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n\n                const stack = [globalScope];\n\n                while (stack.length) {\n                    const scope = stack.pop();\n\n                    stack.push.apply(stack, scope.childScopes);\n                    checkScope(scope);\n                }\n            }\n        };\n\n    }\n};\n","no-underscore-dangle.js":"/**\n * @fileoverview Rule to flag trailing underscores in variable declarations.\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow dangling underscores in identifiers\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allow: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    allowAfterThis: {\n                        type: \"boolean\"\n                    },\n                    allowAfterSuper: {\n                        type: \"boolean\"\n                    },\n                    enforceInMethodNames: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const options = context.options[0] || {};\n        const ALLOWED_VARIABLES = options.allow ? options.allow : [];\n        const allowAfterThis = typeof options.allowAfterThis !== \"undefined\" ? options.allowAfterThis : false;\n        const allowAfterSuper = typeof options.allowAfterSuper !== \"undefined\" ? options.allowAfterSuper : false;\n        const enforceInMethodNames = typeof options.enforceInMethodNames !== \"undefined\" ? options.enforceInMethodNames : false;\n\n        //-------------------------------------------------------------------------\n        // Helpers\n        //-------------------------------------------------------------------------\n\n        /**\n         * Check if identifier is present inside the allowed option\n         * @param {string} identifier name of the node\n         * @returns {boolean} true if its is present\n         * @private\n         */\n        function isAllowed(identifier) {\n            return ALLOWED_VARIABLES.some(ident => ident === identifier);\n        }\n\n        /**\n         * Check if identifier has a underscore at the end\n         * @param {ASTNode} identifier node to evaluate\n         * @returns {boolean} true if its is present\n         * @private\n         */\n        function hasTrailingUnderscore(identifier) {\n            const len = identifier.length;\n\n            return identifier !== \"_\" && (identifier[0] === \"_\" || identifier[len - 1] === \"_\");\n        }\n\n        /**\n         * Check if identifier is a special case member expression\n         * @param {ASTNode} identifier node to evaluate\n         * @returns {boolean} true if its is a special case\n         * @private\n         */\n        function isSpecialCaseIdentifierForMemberExpression(identifier) {\n            return identifier === \"__proto__\";\n        }\n\n        /**\n         * Check if identifier is a special case variable expression\n         * @param {ASTNode} identifier node to evaluate\n         * @returns {boolean} true if its is a special case\n         * @private\n         */\n        function isSpecialCaseIdentifierInVariableExpression(identifier) {\n\n            // Checks for the underscore library usage here\n            return identifier === \"_\";\n        }\n\n        /**\n         * Check if function has a underscore at the end\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForTrailingUnderscoreInFunctionDeclaration(node) {\n            if (node.id) {\n                const identifier = node.id.name;\n\n                if (typeof identifier !== \"undefined\" && hasTrailingUnderscore(identifier) && !isAllowed(identifier)) {\n                    context.report({\n                        node,\n                        message: \"Unexpected dangling '_' in '{{identifier}}'.\",\n                        data: {\n                            identifier\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Check if variable expression has a underscore at the end\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForTrailingUnderscoreInVariableExpression(node) {\n            const identifier = node.id.name;\n\n            if (typeof identifier !== \"undefined\" && hasTrailingUnderscore(identifier) &&\n                !isSpecialCaseIdentifierInVariableExpression(identifier) && !isAllowed(identifier)) {\n                context.report({\n                    node,\n                    message: \"Unexpected dangling '_' in '{{identifier}}'.\",\n                    data: {\n                        identifier\n                    }\n                });\n            }\n        }\n\n        /**\n         * Check if member expression has a underscore at the end\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForTrailingUnderscoreInMemberExpression(node) {\n            const identifier = node.property.name,\n                isMemberOfThis = node.object.type === \"ThisExpression\",\n                isMemberOfSuper = node.object.type === \"Super\";\n\n            if (typeof identifier !== \"undefined\" && hasTrailingUnderscore(identifier) &&\n                !(isMemberOfThis && allowAfterThis) &&\n                !(isMemberOfSuper && allowAfterSuper) &&\n                !isSpecialCaseIdentifierForMemberExpression(identifier) && !isAllowed(identifier)) {\n                context.report({\n                    node,\n                    message: \"Unexpected dangling '_' in '{{identifier}}'.\",\n                    data: {\n                        identifier\n                    }\n                });\n            }\n        }\n\n        /**\n         * Check if method declaration or method property has a underscore at the end\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForTrailingUnderscoreInMethod(node) {\n            const identifier = node.key.name;\n            const isMethod = node.type === \"MethodDefinition\" || node.type === \"Property\" && node.method;\n\n            if (typeof identifier !== \"undefined\" && enforceInMethodNames && isMethod && hasTrailingUnderscore(identifier)) {\n                context.report({\n                    node,\n                    message: \"Unexpected dangling '_' in '{{identifier}}'.\",\n                    data: {\n                        identifier\n                    }\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            FunctionDeclaration: checkForTrailingUnderscoreInFunctionDeclaration,\n            VariableDeclarator: checkForTrailingUnderscoreInVariableExpression,\n            MemberExpression: checkForTrailingUnderscoreInMemberExpression,\n            MethodDefinition: checkForTrailingUnderscoreInMethod,\n            Property: checkForTrailingUnderscoreInMethod\n        };\n\n    }\n};\n","no-unexpected-multiline.js":"/**\n * @fileoverview Rule to spot scenarios where a newline looks like it is ending a statement, but is not.\n * @author Glen Mailer\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow confusing multiline expressions\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        const FUNCTION_MESSAGE = \"Unexpected newline between function and ( of function call.\";\n        const PROPERTY_MESSAGE = \"Unexpected newline between object and [ of property access.\";\n        const TAGGED_TEMPLATE_MESSAGE = \"Unexpected newline between template tag and template literal.\";\n        const DIVISION_MESSAGE = \"Unexpected newline between numerator and division operator.\";\n\n        const REGEX_FLAG_MATCHER = /^[gimuy]+$/;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Check to see if there is a newline between the node and the following open bracket\n         * line's expression\n         * @param {ASTNode} node The node to check.\n         * @param {string} msg The error message to use.\n         * @returns {void}\n         * @private\n         */\n        function checkForBreakAfter(node, msg) {\n            const openParen = sourceCode.getTokenAfter(node, astUtils.isNotClosingParenToken);\n            const nodeExpressionEnd = sourceCode.getTokenBefore(openParen);\n\n            if (openParen.loc.start.line !== nodeExpressionEnd.loc.end.line) {\n                context.report({ node, loc: openParen.loc.start, message: msg, data: { char: openParen.value } });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n\n            MemberExpression(node) {\n                if (!node.computed) {\n                    return;\n                }\n                checkForBreakAfter(node.object, PROPERTY_MESSAGE);\n            },\n\n            TaggedTemplateExpression(node) {\n                if (node.tag.loc.end.line === node.quasi.loc.start.line) {\n                    return;\n                }\n                context.report({ node, loc: node.loc.start, message: TAGGED_TEMPLATE_MESSAGE });\n            },\n\n            CallExpression(node) {\n                if (node.arguments.length === 0) {\n                    return;\n                }\n                checkForBreakAfter(node.callee, FUNCTION_MESSAGE);\n            },\n\n            \"BinaryExpression[operator='/'] > BinaryExpression[operator='/'].left\"(node) {\n                const secondSlash = sourceCode.getTokenAfter(node, token => token.value === \"/\");\n                const tokenAfterOperator = sourceCode.getTokenAfter(secondSlash);\n\n                if (\n                    tokenAfterOperator.type === \"Identifier\" &&\n                    REGEX_FLAG_MATCHER.test(tokenAfterOperator.value) &&\n                    secondSlash.range[1] === tokenAfterOperator.range[0]\n                ) {\n                    checkForBreakAfter(node.left, DIVISION_MESSAGE);\n                }\n            }\n        };\n\n    }\n};\n","no-unmodified-loop-condition.js":"/**\n * @fileoverview Rule to disallow use of unmodified expressions in loop conditions\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Traverser = require(\"../util/traverser\"),\n    astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst pushAll = Function.apply.bind(Array.prototype.push);\nconst SENTINEL_PATTERN = /(?:(?:Call|Class|Function|Member|New|Yield)Expression|Statement|Declaration)$/;\nconst LOOP_PATTERN = /^(?:DoWhile|For|While)Statement$/; // for-in/of statements don't have `test` property.\nconst GROUP_PATTERN = /^(?:BinaryExpression|ConditionalExpression)$/;\nconst SKIP_PATTERN = /^(?:ArrowFunction|Class|Function)Expression$/;\nconst DYNAMIC_PATTERN = /^(?:Call|Member|New|TaggedTemplate|Yield)Expression$/;\n\n/**\n * @typedef {Object} LoopConditionInfo\n * @property {eslint-scope.Reference} reference - The reference.\n * @property {ASTNode} group - BinaryExpression or ConditionalExpression nodes\n *      that the reference is belonging to.\n * @property {Function} isInLoop - The predicate which checks a given reference\n *      is in this loop.\n * @property {boolean} modified - The flag that the reference is modified in\n *      this loop.\n */\n\n/**\n * Checks whether or not a given reference is a write reference.\n *\n * @param {eslint-scope.Reference} reference - A reference to check.\n * @returns {boolean} `true` if the reference is a write reference.\n */\nfunction isWriteReference(reference) {\n    if (reference.init) {\n        const def = reference.resolved && reference.resolved.defs[0];\n\n        if (!def || def.type !== \"Variable\" || def.parent.kind !== \"var\") {\n            return false;\n        }\n    }\n    return reference.isWrite();\n}\n\n/**\n * Checks whether or not a given loop condition info does not have the modified\n * flag.\n *\n * @param {LoopConditionInfo} condition - A loop condition info to check.\n * @returns {boolean} `true` if the loop condition info is \"unmodified\".\n */\nfunction isUnmodified(condition) {\n    return !condition.modified;\n}\n\n/**\n * Checks whether or not a given loop condition info does not have the modified\n * flag and does not have the group this condition belongs to.\n *\n * @param {LoopConditionInfo} condition - A loop condition info to check.\n * @returns {boolean} `true` if the loop condition info is \"unmodified\".\n */\nfunction isUnmodifiedAndNotBelongToGroup(condition) {\n    return !(condition.modified || condition.group);\n}\n\n/**\n * Checks whether or not a given reference is inside of a given node.\n *\n * @param {ASTNode} node - A node to check.\n * @param {eslint-scope.Reference} reference - A reference to check.\n * @returns {boolean} `true` if the reference is inside of the node.\n */\nfunction isInRange(node, reference) {\n    const or = node.range;\n    const ir = reference.identifier.range;\n\n    return or[0] <= ir[0] && ir[1] <= or[1];\n}\n\n/**\n * Checks whether or not a given reference is inside of a loop node's condition.\n *\n * @param {ASTNode} node - A node to check.\n * @param {eslint-scope.Reference} reference - A reference to check.\n * @returns {boolean} `true` if the reference is inside of the loop node's\n *      condition.\n */\nconst isInLoop = {\n    WhileStatement: isInRange,\n    DoWhileStatement: isInRange,\n    ForStatement(node, reference) {\n        return (\n            isInRange(node, reference) &&\n            !(node.init && isInRange(node.init, reference))\n        );\n    }\n};\n\n/**\n * Checks whether or not a given group node has any dynamic elements.\n *\n * @param {ASTNode} root - A node to check.\n *      This node is one of BinaryExpression or ConditionalExpression.\n * @returns {boolean} `true` if the node is dynamic.\n */\nfunction hasDynamicExpressions(root) {\n    let retv = false;\n    const traverser = new Traverser();\n\n    traverser.traverse(root, {\n        enter(node) {\n            if (DYNAMIC_PATTERN.test(node.type)) {\n                retv = true;\n                this.break();\n            } else if (SKIP_PATTERN.test(node.type)) {\n                this.skip();\n            }\n        }\n    });\n\n    return retv;\n}\n\n/**\n * Creates the loop condition information from a given reference.\n *\n * @param {eslint-scope.Reference} reference - A reference to create.\n * @returns {LoopConditionInfo|null} Created loop condition info, or null.\n */\nfunction toLoopCondition(reference) {\n    if (reference.init) {\n        return null;\n    }\n\n    let group = null;\n    let child = reference.identifier;\n    let node = child.parent;\n\n    while (node) {\n        if (SENTINEL_PATTERN.test(node.type)) {\n            if (LOOP_PATTERN.test(node.type) && node.test === child) {\n\n                // This reference is inside of a loop condition.\n                return {\n                    reference,\n                    group,\n                    isInLoop: isInLoop[node.type].bind(null, node),\n                    modified: false\n                };\n            }\n\n            // This reference is outside of a loop condition.\n            break;\n        }\n\n        /*\n         * If it's inside of a group, OK if either operand is modified.\n         * So stores the group this reference belongs to.\n         */\n        if (GROUP_PATTERN.test(node.type)) {\n\n            // If this expression is dynamic, no need to check.\n            if (hasDynamicExpressions(node)) {\n                break;\n            } else {\n                group = node;\n            }\n        }\n\n        child = node;\n        node = node.parent;\n    }\n\n    return null;\n}\n\n/**\n * Gets the function which encloses a given reference.\n * This supports only FunctionDeclaration.\n *\n * @param {eslint-scope.Reference} reference - A reference to get.\n * @returns {ASTNode|null} The function node or null.\n */\nfunction getEncloseFunctionDeclaration(reference) {\n    let node = reference.identifier;\n\n    while (node) {\n        if (node.type === \"FunctionDeclaration\") {\n            return node.id ? node : null;\n        }\n\n        node = node.parent;\n    }\n\n    return null;\n}\n\n/**\n * Updates the \"modified\" flags of given loop conditions with given modifiers.\n *\n * @param {LoopConditionInfo[]} conditions - The loop conditions to be updated.\n * @param {eslint-scope.Reference[]} modifiers - The references to update.\n * @returns {void}\n */\nfunction updateModifiedFlag(conditions, modifiers) {\n\n    for (let i = 0; i < conditions.length; ++i) {\n        const condition = conditions[i];\n\n        for (let j = 0; !condition.modified && j < modifiers.length; ++j) {\n            const modifier = modifiers[j];\n            let funcNode, funcVar;\n\n            /*\n             * Besides checking for the condition being in the loop, we want to\n             * check the function that this modifier is belonging to is called\n             * in the loop.\n             * FIXME: This should probably be extracted to a function.\n             */\n            const inLoop = condition.isInLoop(modifier) || Boolean(\n                (funcNode = getEncloseFunctionDeclaration(modifier)) &&\n                (funcVar = astUtils.getVariableByName(modifier.from.upper, funcNode.id.name)) &&\n                funcVar.references.some(condition.isInLoop)\n            );\n\n            condition.modified = inLoop;\n        }\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unmodified loop conditions\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        let groupMap = null;\n\n        /**\n         * Reports a given condition info.\n         *\n         * @param {LoopConditionInfo} condition - A loop condition info to report.\n         * @returns {void}\n         */\n        function report(condition) {\n            const node = condition.reference.identifier;\n\n            context.report({\n                node,\n                message: \"'{{name}}' is not modified in this loop.\",\n                data: node\n            });\n        }\n\n        /**\n         * Registers given conditions to the group the condition belongs to.\n         *\n         * @param {LoopConditionInfo[]} conditions - A loop condition info to\n         *      register.\n         * @returns {void}\n         */\n        function registerConditionsToGroup(conditions) {\n            for (let i = 0; i < conditions.length; ++i) {\n                const condition = conditions[i];\n\n                if (condition.group) {\n                    let group = groupMap.get(condition.group);\n\n                    if (!group) {\n                        group = [];\n                        groupMap.set(condition.group, group);\n                    }\n                    group.push(condition);\n                }\n            }\n        }\n\n        /**\n         * Reports references which are inside of unmodified groups.\n         *\n         * @param {LoopConditionInfo[]} conditions - A loop condition info to report.\n         * @returns {void}\n         */\n        function checkConditionsInGroup(conditions) {\n            if (conditions.every(isUnmodified)) {\n                conditions.forEach(report);\n            }\n        }\n\n        /**\n         * Finds unmodified references which are inside of a loop condition.\n         * Then reports the references which are outside of groups.\n         *\n         * @param {eslint-scope.Variable} variable - A variable to report.\n         * @returns {void}\n         */\n        function checkReferences(variable) {\n\n            // Gets references that exist in loop conditions.\n            const conditions = variable\n                .references\n                .map(toLoopCondition)\n                .filter(Boolean);\n\n            if (conditions.length === 0) {\n                return;\n            }\n\n            // Registers the conditions to belonging groups.\n            registerConditionsToGroup(conditions);\n\n            // Check the conditions are modified.\n            const modifiers = variable.references.filter(isWriteReference);\n\n            if (modifiers.length > 0) {\n                updateModifiedFlag(conditions, modifiers);\n            }\n\n            /*\n             * Reports the conditions which are not belonging to groups.\n             * Others will be reported after all variables are done.\n             */\n            conditions\n                .filter(isUnmodifiedAndNotBelongToGroup)\n                .forEach(report);\n        }\n\n        return {\n            \"Program:exit\"() {\n                const queue = [context.getScope()];\n\n                groupMap = new Map();\n\n                let scope;\n\n                while ((scope = queue.pop())) {\n                    pushAll(queue, scope.childScopes);\n                    scope.variables.forEach(checkReferences);\n                }\n\n                groupMap.forEach(checkConditionsInGroup);\n                groupMap = null;\n            }\n        };\n    }\n};\n","no-unneeded-ternary.js":"/**\n * @fileoverview Rule to flag no-unneeded-ternary\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n// Operators that always result in a boolean value\nconst BOOLEAN_OPERATORS = new Set([\"==\", \"===\", \"!=\", \"!==\", \">\", \">=\", \"<\", \"<=\", \"in\", \"instanceof\"]);\nconst OPERATOR_INVERSES = {\n    \"==\": \"!=\",\n    \"!=\": \"==\",\n    \"===\": \"!==\",\n    \"!==\": \"===\"\n\n    // Operators like < and >= are not true inverses, since both will return false with NaN.\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow ternary operators when simpler alternatives exist\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    defaultAssignment: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const defaultAssignment = options.defaultAssignment !== false;\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Test if the node is a boolean literal\n         * @param {ASTNode} node - The node to report.\n         * @returns {boolean} True if the its a boolean literal\n         * @private\n         */\n        function isBooleanLiteral(node) {\n            return node.type === \"Literal\" && typeof node.value === \"boolean\";\n        }\n\n        /**\n         * Creates an expression that represents the boolean inverse of the expression represented by the original node\n         * @param {ASTNode} node A node representing an expression\n         * @returns {string} A string representing an inverted expression\n         */\n        function invertExpression(node) {\n            if (node.type === \"BinaryExpression\" && Object.prototype.hasOwnProperty.call(OPERATOR_INVERSES, node.operator)) {\n                const operatorToken = sourceCode.getFirstTokenBetween(\n                    node.left,\n                    node.right,\n                    token => token.value === node.operator\n                );\n\n                return sourceCode.getText().slice(node.range[0], operatorToken.range[0]) + OPERATOR_INVERSES[node.operator] + sourceCode.getText().slice(operatorToken.range[1], node.range[1]);\n            }\n\n            if (astUtils.getPrecedence(node) < astUtils.getPrecedence({ type: \"UnaryExpression\" })) {\n                return `!(${astUtils.getParenthesisedText(sourceCode, node)})`;\n            }\n            return `!${astUtils.getParenthesisedText(sourceCode, node)}`;\n        }\n\n        /**\n         * Tests if a given node always evaluates to a boolean value\n         * @param {ASTNode} node - An expression node\n         * @returns {boolean} True if it is determined that the node will always evaluate to a boolean value\n         */\n        function isBooleanExpression(node) {\n            return node.type === \"BinaryExpression\" && BOOLEAN_OPERATORS.has(node.operator) ||\n                node.type === \"UnaryExpression\" && node.operator === \"!\";\n        }\n\n        /**\n         * Test if the node matches the pattern id ? id : expression\n         * @param {ASTNode} node - The ConditionalExpression to check.\n         * @returns {boolean} True if the pattern is matched, and false otherwise\n         * @private\n         */\n        function matchesDefaultAssignment(node) {\n            return node.test.type === \"Identifier\" &&\n                   node.consequent.type === \"Identifier\" &&\n                   node.test.name === node.consequent.name;\n        }\n\n        return {\n\n            ConditionalExpression(node) {\n                if (isBooleanLiteral(node.alternate) && isBooleanLiteral(node.consequent)) {\n                    context.report({\n                        node,\n                        loc: node.consequent.loc.start,\n                        message: \"Unnecessary use of boolean literals in conditional expression.\",\n                        fix(fixer) {\n                            if (node.consequent.value === node.alternate.value) {\n\n                                // Replace `foo ? true : true` with just `true`, but don't replace `foo() ? true : true`\n                                return node.test.type === \"Identifier\" ? fixer.replaceText(node, node.consequent.value.toString()) : null;\n                            }\n                            if (node.alternate.value) {\n\n                                // Replace `foo() ? false : true` with `!(foo())`\n                                return fixer.replaceText(node, invertExpression(node.test));\n                            }\n\n                            // Replace `foo ? true : false` with `foo` if `foo` is guaranteed to be a boolean, or `!!foo` otherwise.\n\n                            return fixer.replaceText(node, isBooleanExpression(node.test) ? astUtils.getParenthesisedText(sourceCode, node.test) : `!${invertExpression(node.test)}`);\n                        }\n                    });\n                } else if (!defaultAssignment && matchesDefaultAssignment(node)) {\n                    context.report({\n                        node,\n                        loc: node.consequent.loc.start,\n                        message: \"Unnecessary use of conditional expression for default assignment.\",\n                        fix: fixer => {\n                            let nodeAlternate = astUtils.getParenthesisedText(sourceCode, node.alternate);\n\n                            if (node.alternate.type === \"ConditionalExpression\") {\n                                const isAlternateParenthesised = astUtils.isParenthesised(sourceCode, node.alternate);\n\n                                nodeAlternate = isAlternateParenthesised ? nodeAlternate : `(${nodeAlternate})`;\n                            }\n\n                            return fixer.replaceText(node, `${astUtils.getParenthesisedText(sourceCode, node.test)} || ${nodeAlternate}`);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","no-unreachable.js":"/**\n * @fileoverview Checks for unreachable code due to return, throws, break, and continue.\n * @author Joel Feenstra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given variable declarator has the initializer.\n * @param {ASTNode} node - A VariableDeclarator node to check.\n * @returns {boolean} `true` if the node has the initializer.\n */\nfunction isInitialized(node) {\n    return Boolean(node.init);\n}\n\n/**\n * Checks whether or not a given code path segment is unreachable.\n * @param {CodePathSegment} segment - A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is unreachable.\n */\nfunction isUnreachable(segment) {\n    return !segment.reachable;\n}\n\n/**\n * The class to distinguish consecutive unreachable statements.\n */\nclass ConsecutiveRange {\n    constructor(sourceCode) {\n        this.sourceCode = sourceCode;\n        this.startNode = null;\n        this.endNode = null;\n    }\n\n    /**\n     * The location object of this range.\n     * @type {Object}\n     */\n    get location() {\n        return {\n            start: this.startNode.loc.start,\n            end: this.endNode.loc.end\n        };\n    }\n\n    /**\n     * `true` if this range is empty.\n     * @type {boolean}\n     */\n    get isEmpty() {\n        return !(this.startNode && this.endNode);\n    }\n\n    /**\n     * Checks whether the given node is inside of this range.\n     * @param {ASTNode|Token} node - The node to check.\n     * @returns {boolean} `true` if the node is inside of this range.\n     */\n    contains(node) {\n        return (\n            node.range[0] >= this.startNode.range[0] &&\n            node.range[1] <= this.endNode.range[1]\n        );\n    }\n\n    /**\n     * Checks whether the given node is consecutive to this range.\n     * @param {ASTNode} node - The node to check.\n     * @returns {boolean} `true` if the node is consecutive to this range.\n     */\n    isConsecutive(node) {\n        return this.contains(this.sourceCode.getTokenBefore(node));\n    }\n\n    /**\n     * Merges the given node to this range.\n     * @param {ASTNode} node - The node to merge.\n     * @returns {void}\n     */\n    merge(node) {\n        this.endNode = node;\n    }\n\n    /**\n     * Resets this range by the given node or null.\n     * @param {ASTNode|null} node - The node to reset, or null.\n     * @returns {void}\n     */\n    reset(node) {\n        this.startNode = this.endNode = node;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unreachable code after `return`, `throw`, `continue`, and `break` statements\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        let currentCodePath = null;\n\n        const range = new ConsecutiveRange(context.getSourceCode());\n\n        /**\n         * Reports a given node if it's unreachable.\n         * @param {ASTNode} node - A statement node to report.\n         * @returns {void}\n         */\n        function reportIfUnreachable(node) {\n            let nextNode = null;\n\n            if (node && currentCodePath.currentSegments.every(isUnreachable)) {\n\n                // Store this statement to distinguish consecutive statements.\n                if (range.isEmpty) {\n                    range.reset(node);\n                    return;\n                }\n\n                // Skip if this statement is inside of the current range.\n                if (range.contains(node)) {\n                    return;\n                }\n\n                // Merge if this statement is consecutive to the current range.\n                if (range.isConsecutive(node)) {\n                    range.merge(node);\n                    return;\n                }\n\n                nextNode = node;\n            }\n\n            // Report the current range since this statement is reachable or is\n            // not consecutive to the current range.\n            if (!range.isEmpty) {\n                context.report({\n                    message: \"Unreachable code.\",\n                    loc: range.location,\n                    node: range.startNode\n                });\n            }\n\n            // Update the current range.\n            range.reset(nextNode);\n        }\n\n        return {\n\n            // Manages the current code path.\n            onCodePathStart(codePath) {\n                currentCodePath = codePath;\n            },\n\n            onCodePathEnd() {\n                currentCodePath = currentCodePath.upper;\n            },\n\n            // Registers for all statement nodes (excludes FunctionDeclaration).\n            BlockStatement: reportIfUnreachable,\n            BreakStatement: reportIfUnreachable,\n            ClassDeclaration: reportIfUnreachable,\n            ContinueStatement: reportIfUnreachable,\n            DebuggerStatement: reportIfUnreachable,\n            DoWhileStatement: reportIfUnreachable,\n            EmptyStatement: reportIfUnreachable,\n            ExpressionStatement: reportIfUnreachable,\n            ForInStatement: reportIfUnreachable,\n            ForOfStatement: reportIfUnreachable,\n            ForStatement: reportIfUnreachable,\n            IfStatement: reportIfUnreachable,\n            ImportDeclaration: reportIfUnreachable,\n            LabeledStatement: reportIfUnreachable,\n            ReturnStatement: reportIfUnreachable,\n            SwitchStatement: reportIfUnreachable,\n            ThrowStatement: reportIfUnreachable,\n            TryStatement: reportIfUnreachable,\n\n            VariableDeclaration(node) {\n                if (node.kind !== \"var\" || node.declarations.some(isInitialized)) {\n                    reportIfUnreachable(node);\n                }\n            },\n\n            WhileStatement: reportIfUnreachable,\n            WithStatement: reportIfUnreachable,\n            ExportNamedDeclaration: reportIfUnreachable,\n            ExportDefaultDeclaration: reportIfUnreachable,\n            ExportAllDeclaration: reportIfUnreachable,\n\n            \"Program:exit\"() {\n                reportIfUnreachable();\n            }\n        };\n    }\n};\n","no-unsafe-finally.js":"/**\n * @fileoverview Rule to flag unsafe statements in finally block\n * @author Onur Temizkan\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SENTINEL_NODE_TYPE_RETURN_THROW = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression)$/;\nconst SENTINEL_NODE_TYPE_BREAK = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement|SwitchStatement)$/;\nconst SENTINEL_NODE_TYPE_CONTINUE = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement)$/;\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow control flow statements in `finally` blocks\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n    create(context) {\n\n        /**\n         * Checks if the node is the finalizer of a TryStatement\n         *\n         * @param {ASTNode} node - node to check.\n         * @returns {boolean} - true if the node is the finalizer of a TryStatement\n         */\n        function isFinallyBlock(node) {\n            return node.parent.type === \"TryStatement\" && node.parent.finalizer === node;\n        }\n\n        /**\n         * Climbs up the tree if the node is not a sentinel node\n         *\n         * @param {ASTNode} node - node to check.\n         * @param {string} label - label of the break or continue statement\n         * @returns {boolean} - return whether the node is a finally block or a sentinel node\n         */\n        function isInFinallyBlock(node, label) {\n            let labelInside = false;\n            let sentinelNodeType;\n\n            if (node.type === \"BreakStatement\" && !node.label) {\n                sentinelNodeType = SENTINEL_NODE_TYPE_BREAK;\n            } else if (node.type === \"ContinueStatement\") {\n                sentinelNodeType = SENTINEL_NODE_TYPE_CONTINUE;\n            } else {\n                sentinelNodeType = SENTINEL_NODE_TYPE_RETURN_THROW;\n            }\n\n            while (node && !sentinelNodeType.test(node.type)) {\n                if (node.parent.label && label && (node.parent.label.name === label.name)) {\n                    labelInside = true;\n                }\n                if (isFinallyBlock(node)) {\n                    if (label && labelInside) {\n                        return false;\n                    }\n                    return true;\n                }\n                node = node.parent;\n            }\n            return false;\n        }\n\n        /**\n         * Checks whether the possibly-unsafe statement is inside a finally block.\n         *\n         * @param {ASTNode} node - node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            if (isInFinallyBlock(node, node.label)) {\n                context.report({\n                    message: \"Unsafe usage of {{nodeType}}.\",\n                    data: {\n                        nodeType: node.type\n                    },\n                    node,\n                    line: node.loc.line,\n                    column: node.loc.column\n                });\n            }\n        }\n\n        return {\n            ReturnStatement: check,\n            ThrowStatement: check,\n            BreakStatement: check,\n            ContinueStatement: check\n        };\n    }\n};\n","no-unsafe-negation.js":"/**\n * @fileoverview Rule to disallow negating the left operand of relational operators\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether the given operator is a relational operator or not.\n *\n * @param {string} op - The operator type to check.\n * @returns {boolean} `true` if the operator is a relational operator.\n */\nfunction isRelationalOperator(op) {\n    return op === \"in\" || op === \"instanceof\";\n}\n\n/**\n * Checks whether the given node is a logical negation expression or not.\n *\n * @param {ASTNode} node - The node to check.\n * @returns {boolean} `true` if the node is a logical negation expression.\n */\nfunction isNegation(node) {\n    return node.type === \"UnaryExpression\" && node.operator === \"!\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow negating the left operand of relational operators\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n        schema: [],\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            BinaryExpression(node) {\n                if (isRelationalOperator(node.operator) &&\n                    isNegation(node.left) &&\n                    !astUtils.isParenthesised(sourceCode, node.left)\n                ) {\n                    context.report({\n                        node,\n                        loc: node.left.loc,\n                        message: \"Unexpected negating the left operand of '{{operator}}' operator.\",\n                        data: node,\n\n                        fix(fixer) {\n                            const negationToken = sourceCode.getFirstToken(node.left);\n                            const fixRange = [negationToken.range[1], node.range[1]];\n                            const text = sourceCode.text.slice(fixRange[0], fixRange[1]);\n\n                            return fixer.replaceTextRange(fixRange, `(${text})`);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","no-unused-expressions.js":"/**\n * @fileoverview Flag expressions in statement position that do not side effect\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unused expressions\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowShortCircuit: {\n                        type: \"boolean\"\n                    },\n                    allowTernary: {\n                        type: \"boolean\"\n                    },\n                    allowTaggedTemplates: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const config = context.options[0] || {},\n            allowShortCircuit = config.allowShortCircuit || false,\n            allowTernary = config.allowTernary || false,\n            allowTaggedTemplates = config.allowTaggedTemplates || false;\n\n        /**\n         * @param {ASTNode} node - any node\n         * @returns {boolean} whether the given node structurally represents a directive\n         */\n        function looksLikeDirective(node) {\n            return node.type === \"ExpressionStatement\" &&\n                node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n        }\n\n        /**\n         * @param {Function} predicate - ([a] -> Boolean) the function used to make the determination\n         * @param {a[]} list - the input list\n         * @returns {a[]} the leading sequence of members in the given list that pass the given predicate\n         */\n        function takeWhile(predicate, list) {\n            for (let i = 0; i < list.length; ++i) {\n                if (!predicate(list[i])) {\n                    return list.slice(0, i);\n                }\n            }\n            return list.slice();\n        }\n\n        /**\n         * @param {ASTNode} node - a Program or BlockStatement node\n         * @returns {ASTNode[]} the leading sequence of directive nodes in the given node's body\n         */\n        function directives(node) {\n            return takeWhile(looksLikeDirective, node.body);\n        }\n\n        /**\n         * @param {ASTNode} node - any node\n         * @param {ASTNode[]} ancestors - the given node's ancestors\n         * @returns {boolean} whether the given node is considered a directive in its current position\n         */\n        function isDirective(node, ancestors) {\n            const parent = ancestors[ancestors.length - 1],\n                grandparent = ancestors[ancestors.length - 2];\n\n            return (parent.type === \"Program\" || parent.type === \"BlockStatement\" &&\n                    (/Function/.test(grandparent.type))) &&\n                    directives(parent).indexOf(node) >= 0;\n        }\n\n        /**\n         * Determines whether or not a given node is a valid expression. Recurses on short circuit eval and ternary nodes if enabled by flags.\n         * @param {ASTNode} node - any node\n         * @returns {boolean} whether the given node is a valid expression\n         */\n        function isValidExpression(node) {\n            if (allowTernary) {\n\n                // Recursive check for ternary and logical expressions\n                if (node.type === \"ConditionalExpression\") {\n                    return isValidExpression(node.consequent) && isValidExpression(node.alternate);\n                }\n            }\n\n            if (allowShortCircuit) {\n                if (node.type === \"LogicalExpression\") {\n                    return isValidExpression(node.right);\n                }\n            }\n\n            if (allowTaggedTemplates && node.type === \"TaggedTemplateExpression\") {\n                return true;\n            }\n\n            return /^(?:Assignment|Call|New|Update|Yield|Await)Expression$/.test(node.type) ||\n                (node.type === \"UnaryExpression\" && [\"delete\", \"void\"].indexOf(node.operator) >= 0);\n        }\n\n        return {\n            ExpressionStatement(node) {\n                if (!isValidExpression(node.expression) && !isDirective(node, context.getAncestors())) {\n                    context.report({ node, message: \"Expected an assignment or function call and instead saw an expression.\" });\n                }\n            }\n        };\n\n    }\n};\n","no-unused-labels.js":"/**\n * @fileoverview Rule to disallow unused labels.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unused labels\",\n            category: \"Best Practices\",\n            recommended: true\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        let scopeInfo = null;\n\n        /**\n         * Adds a scope info to the stack.\n         *\n         * @param {ASTNode} node - A node to add. This is a LabeledStatement.\n         * @returns {void}\n         */\n        function enterLabeledScope(node) {\n            scopeInfo = {\n                label: node.label.name,\n                used: false,\n                upper: scopeInfo\n            };\n        }\n\n        /**\n         * Removes the top of the stack.\n         * At the same time, this reports the label if it's never used.\n         *\n         * @param {ASTNode} node - A node to report. This is a LabeledStatement.\n         * @returns {void}\n         */\n        function exitLabeledScope(node) {\n            if (!scopeInfo.used) {\n                context.report({\n                    node: node.label,\n                    message: \"'{{name}}:' is defined but never used.\",\n                    data: node.label,\n                    fix(fixer) {\n\n                        /*\n                         * Only perform a fix if there are no comments between the label and the body. This will be the case\n                         * when there is exactly one token/comment (the \":\") between the label and the body.\n                         */\n                        if (sourceCode.getTokenAfter(node.label, { includeComments: true }) === sourceCode.getTokenBefore(node.body, { includeComments: true })) {\n                            return fixer.removeRange([node.range[0], node.body.range[0]]);\n                        }\n\n                        return null;\n                    }\n                });\n            }\n\n            scopeInfo = scopeInfo.upper;\n        }\n\n        /**\n         * Marks the label of a given node as used.\n         *\n         * @param {ASTNode} node - A node to mark. This is a BreakStatement or\n         *      ContinueStatement.\n         * @returns {void}\n         */\n        function markAsUsed(node) {\n            if (!node.label) {\n                return;\n            }\n\n            const label = node.label.name;\n            let info = scopeInfo;\n\n            while (info) {\n                if (info.label === label) {\n                    info.used = true;\n                    break;\n                }\n                info = info.upper;\n            }\n        }\n\n        return {\n            LabeledStatement: enterLabeledScope,\n            \"LabeledStatement:exit\": exitLabeledScope,\n            BreakStatement: markAsUsed,\n            ContinueStatement: markAsUsed\n        };\n    }\n};\n","no-unused-vars.js":"/**\n * @fileoverview Rule to flag declared but unused variables\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unused variables\",\n            category: \"Variables\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"all\", \"local\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            vars: {\n                                enum: [\"all\", \"local\"]\n                            },\n                            varsIgnorePattern: {\n                                type: \"string\"\n                            },\n                            args: {\n                                enum: [\"all\", \"after-used\", \"none\"]\n                            },\n                            ignoreRestSiblings: {\n                                type: \"boolean\"\n                            },\n                            argsIgnorePattern: {\n                                type: \"string\"\n                            },\n                            caughtErrors: {\n                                enum: [\"all\", \"none\"]\n                            },\n                            caughtErrorsIgnorePattern: {\n                                type: \"string\"\n                            }\n                        }\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const REST_PROPERTY_TYPE = /^(?:Experimental)?RestProperty$/;\n\n        const config = {\n            vars: \"all\",\n            args: \"after-used\",\n            ignoreRestSiblings: false,\n            caughtErrors: \"none\"\n        };\n\n        const firstOption = context.options[0];\n\n        if (firstOption) {\n            if (typeof firstOption === \"string\") {\n                config.vars = firstOption;\n            } else {\n                config.vars = firstOption.vars || config.vars;\n                config.args = firstOption.args || config.args;\n                config.ignoreRestSiblings = firstOption.ignoreRestSiblings || config.ignoreRestSiblings;\n                config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;\n\n                if (firstOption.varsIgnorePattern) {\n                    config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern);\n                }\n\n                if (firstOption.argsIgnorePattern) {\n                    config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern);\n                }\n\n                if (firstOption.caughtErrorsIgnorePattern) {\n                    config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern);\n                }\n            }\n        }\n\n        /**\n         * Generate the warning message about the variable being\n         * defined and unused, including the ignore pattern if configured.\n         * @param {Variable} unusedVar - eslint-scope variable object.\n         * @returns {string} The warning message to be used with this unused variable.\n         */\n        function getDefinedMessage(unusedVar) {\n            let type;\n            let pattern;\n\n            if (config.varsIgnorePattern) {\n                type = \"vars\";\n                pattern = config.varsIgnorePattern.toString();\n            }\n\n            if (unusedVar.defs && unusedVar.defs[0] && unusedVar.defs[0].type) {\n                const defType = unusedVar.defs[0].type;\n\n                if (defType === \"CatchClause\" && config.caughtErrorsIgnorePattern) {\n                    type = \"args\";\n                    pattern = config.caughtErrorsIgnorePattern.toString();\n                } else if (defType === \"Parameter\" && config.argsIgnorePattern) {\n                    type = \"args\";\n                    pattern = config.argsIgnorePattern.toString();\n                }\n            }\n\n            const additional = type ? ` Allowed unused ${type} must match ${pattern}.` : \"\";\n\n            return `'{{name}}' is defined but never used.${additional}`;\n        }\n\n        /**\n         * Generate the warning message about the variable being\n         * assigned and unused, including the ignore pattern if configured.\n         * @returns {string} The warning message to be used with this unused variable.\n         */\n        function getAssignedMessage() {\n            const additional = config.varsIgnorePattern ? ` Allowed unused vars must match ${config.varsIgnorePattern.toString()}.` : \"\";\n\n            return `'{{name}}' is assigned a value but never used.${additional}`;\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const STATEMENT_TYPE = /(?:Statement|Declaration)$/;\n\n        /**\n         * Determines if a given variable is being exported from a module.\n         * @param {Variable} variable - eslint-scope variable object.\n         * @returns {boolean} True if the variable is exported, false if not.\n         * @private\n         */\n        function isExported(variable) {\n\n            const definition = variable.defs[0];\n\n            if (definition) {\n\n                let node = definition.node;\n\n                if (node.type === \"VariableDeclarator\") {\n                    node = node.parent;\n                } else if (definition.type === \"Parameter\") {\n                    return false;\n                }\n\n                return node.parent.type.indexOf(\"Export\") === 0;\n            }\n            return false;\n\n        }\n\n        /**\n         * Determines if a variable has a sibling rest property\n         * @param {Variable} variable - eslint-scope variable object.\n         * @returns {boolean} True if the variable is exported, false if not.\n         * @private\n         */\n        function hasRestSpreadSibling(variable) {\n            if (config.ignoreRestSiblings) {\n                return variable.defs.some(def => {\n                    const propertyNode = def.name.parent;\n                    const patternNode = propertyNode.parent;\n\n                    return (\n                        propertyNode.type === \"Property\" &&\n                        patternNode.type === \"ObjectPattern\" &&\n                        REST_PROPERTY_TYPE.test(patternNode.properties[patternNode.properties.length - 1].type)\n                    );\n                });\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a reference is a read operation.\n         * @param {Reference} ref - An eslint-scope Reference\n         * @returns {boolean} whether the given reference represents a read operation\n         * @private\n         */\n        function isReadRef(ref) {\n            return ref.isRead();\n        }\n\n        /**\n         * Determine if an identifier is referencing an enclosing function name.\n         * @param {Reference} ref - The reference to check.\n         * @param {ASTNode[]} nodes - The candidate function nodes.\n         * @returns {boolean} True if it's a self-reference, false if not.\n         * @private\n         */\n        function isSelfReference(ref, nodes) {\n            let scope = ref.from;\n\n            while (scope) {\n                if (nodes.indexOf(scope.block) >= 0) {\n                    return true;\n                }\n\n                scope = scope.upper;\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks the position of given nodes.\n         *\n         * @param {ASTNode} inner - A node which is expected as inside.\n         * @param {ASTNode} outer - A node which is expected as outside.\n         * @returns {boolean} `true` if the `inner` node exists in the `outer` node.\n         * @private\n         */\n        function isInside(inner, outer) {\n            return (\n                inner.range[0] >= outer.range[0] &&\n                inner.range[1] <= outer.range[1]\n            );\n        }\n\n        /**\n         * If a given reference is left-hand side of an assignment, this gets\n         * the right-hand side node of the assignment.\n         *\n         * In the following cases, this returns null.\n         *\n         * - The reference is not the LHS of an assignment expression.\n         * - The reference is inside of a loop.\n         * - The reference is inside of a function scope which is different from\n         *   the declaration.\n         *\n         * @param {eslint-scope.Reference} ref - A reference to check.\n         * @param {ASTNode} prevRhsNode - The previous RHS node.\n         * @returns {ASTNode|null} The RHS node or null.\n         * @private\n         */\n        function getRhsNode(ref, prevRhsNode) {\n            const id = ref.identifier;\n            const parent = id.parent;\n            const granpa = parent.parent;\n            const refScope = ref.from.variableScope;\n            const varScope = ref.resolved.scope.variableScope;\n            const canBeUsedLater = refScope !== varScope || astUtils.isInLoop(id);\n\n            /*\n             * Inherits the previous node if this reference is in the node.\n             * This is for `a = a + a`-like code.\n             */\n            if (prevRhsNode && isInside(id, prevRhsNode)) {\n                return prevRhsNode;\n            }\n\n            if (parent.type === \"AssignmentExpression\" &&\n                granpa.type === \"ExpressionStatement\" &&\n                id === parent.left &&\n                !canBeUsedLater\n            ) {\n                return parent.right;\n            }\n            return null;\n        }\n\n        /**\n         * Checks whether a given function node is stored to somewhere or not.\n         * If the function node is stored, the function can be used later.\n         *\n         * @param {ASTNode} funcNode - A function node to check.\n         * @param {ASTNode} rhsNode - The RHS node of the previous assignment.\n         * @returns {boolean} `true` if under the following conditions:\n         *      - the funcNode is assigned to a variable.\n         *      - the funcNode is bound as an argument of a function call.\n         *      - the function is bound to a property and the object satisfies above conditions.\n         * @private\n         */\n        function isStorableFunction(funcNode, rhsNode) {\n            let node = funcNode;\n            let parent = funcNode.parent;\n\n            while (parent && isInside(parent, rhsNode)) {\n                switch (parent.type) {\n                    case \"SequenceExpression\":\n                        if (parent.expressions[parent.expressions.length - 1] !== node) {\n                            return false;\n                        }\n                        break;\n\n                    case \"CallExpression\":\n                    case \"NewExpression\":\n                        return parent.callee !== node;\n\n                    case \"AssignmentExpression\":\n                    case \"TaggedTemplateExpression\":\n                    case \"YieldExpression\":\n                        return true;\n\n                    default:\n                        if (STATEMENT_TYPE.test(parent.type)) {\n\n                            /*\n                             * If it encountered statements, this is a complex pattern.\n                             * Since analyzeing complex patterns is hard, this returns `true` to avoid false positive.\n                             */\n                            return true;\n                        }\n                }\n\n                node = parent;\n                parent = parent.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks whether a given Identifier node exists inside of a function node which can be used later.\n         *\n         * \"can be used later\" means:\n         * - the function is assigned to a variable.\n         * - the function is bound to a property and the object can be used later.\n         * - the function is bound as an argument of a function call.\n         *\n         * If a reference exists in a function which can be used later, the reference is read when the function is called.\n         *\n         * @param {ASTNode} id - An Identifier node to check.\n         * @param {ASTNode} rhsNode - The RHS node of the previous assignment.\n         * @returns {boolean} `true` if the `id` node exists inside of a function node which can be used later.\n         * @private\n         */\n        function isInsideOfStorableFunction(id, rhsNode) {\n            const funcNode = astUtils.getUpperFunction(id);\n\n            return (\n                funcNode &&\n                isInside(funcNode, rhsNode) &&\n                isStorableFunction(funcNode, rhsNode)\n            );\n        }\n\n        /**\n         * Checks whether a given reference is a read to update itself or not.\n         *\n         * @param {eslint-scope.Reference} ref - A reference to check.\n         * @param {ASTNode} rhsNode - The RHS node of the previous assignment.\n         * @returns {boolean} The reference is a read to update itself.\n         * @private\n         */\n        function isReadForItself(ref, rhsNode) {\n            const id = ref.identifier;\n            const parent = id.parent;\n            const granpa = parent.parent;\n\n            return ref.isRead() && (\n\n                // self update. e.g. `a += 1`, `a++`\n                (\n                    parent.type === \"AssignmentExpression\" &&\n                    granpa.type === \"ExpressionStatement\" &&\n                    parent.left === id\n                ) ||\n                (\n                    parent.type === \"UpdateExpression\" &&\n                    granpa.type === \"ExpressionStatement\"\n                ) ||\n\n                // in RHS of an assignment for itself. e.g. `a = a + 1`\n                (\n                    rhsNode &&\n                    isInside(id, rhsNode) &&\n                    !isInsideOfStorableFunction(id, rhsNode)\n                )\n            );\n        }\n\n        /**\n         * Determine if an identifier is used either in for-in loops.\n         *\n         * @param {Reference} ref - The reference to check.\n         * @returns {boolean} whether reference is used in the for-in loops\n         * @private\n         */\n        function isForInRef(ref) {\n            let target = ref.identifier.parent;\n\n\n            // \"for (var ...) { return; }\"\n            if (target.type === \"VariableDeclarator\") {\n                target = target.parent.parent;\n            }\n\n            if (target.type !== \"ForInStatement\") {\n                return false;\n            }\n\n            // \"for (...) { return; }\"\n            if (target.body.type === \"BlockStatement\") {\n                target = target.body.body[0];\n\n            // \"for (...) return;\"\n            } else {\n                target = target.body;\n            }\n\n            // For empty loop body\n            if (!target) {\n                return false;\n            }\n\n            return target.type === \"ReturnStatement\";\n        }\n\n        /**\n         * Determines if the variable is used.\n         * @param {Variable} variable - The variable to check.\n         * @returns {boolean} True if the variable is used\n         * @private\n         */\n        function isUsedVariable(variable) {\n            const functionNodes = variable.defs.filter(def => def.type === \"FunctionName\").map(def => def.node),\n                isFunctionDefinition = functionNodes.length > 0;\n            let rhsNode = null;\n\n            return variable.references.some(ref => {\n                if (isForInRef(ref)) {\n                    return true;\n                }\n\n                const forItself = isReadForItself(ref, rhsNode);\n\n                rhsNode = getRhsNode(ref, rhsNode);\n\n                return (\n                    isReadRef(ref) &&\n                    !forItself &&\n                    !(isFunctionDefinition && isSelfReference(ref, functionNodes))\n                );\n            });\n        }\n\n        /**\n         * Checks whether the given variable is the last parameter in the non-ignored parameters.\n         *\n         * @param {eslint-scope.Variable} variable - The variable to check.\n         * @returns {boolean} `true` if the variable is the last.\n         */\n        function isLastInNonIgnoredParameters(variable) {\n            const def = variable.defs[0];\n\n            // This is the last.\n            if (def.index === def.node.params.length - 1) {\n                return true;\n            }\n\n            // if all parameters preceded by this variable are ignored and unused, this is the last.\n            if (config.argsIgnorePattern) {\n                const params = context.getDeclaredVariables(def.node);\n                const posteriorParams = params.slice(params.indexOf(variable) + 1);\n\n                if (posteriorParams.every(v => v.references.length === 0 && config.argsIgnorePattern.test(v.name))) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Gets an array of variables without read references.\n         * @param {Scope} scope - an eslint-scope Scope object.\n         * @param {Variable[]} unusedVars - an array that saving result.\n         * @returns {Variable[]} unused variables of the scope and descendant scopes.\n         * @private\n         */\n        function collectUnusedVariables(scope, unusedVars) {\n            const variables = scope.variables;\n            const childScopes = scope.childScopes;\n            let i, l;\n\n            if (scope.type !== \"TDZ\" && (scope.type !== \"global\" || config.vars === \"all\")) {\n                for (i = 0, l = variables.length; i < l; ++i) {\n                    const variable = variables[i];\n\n                    // skip a variable of class itself name in the class scope\n                    if (scope.type === \"class\" && scope.block.id === variable.identifiers[0]) {\n                        continue;\n                    }\n\n                    // skip function expression names and variables marked with markVariableAsUsed()\n                    if (scope.functionExpressionScope || variable.eslintUsed) {\n                        continue;\n                    }\n\n                    // skip implicit \"arguments\" variable\n                    if (scope.type === \"function\" && variable.name === \"arguments\" && variable.identifiers.length === 0) {\n                        continue;\n                    }\n\n                    // explicit global variables don't have definitions.\n                    const def = variable.defs[0];\n\n                    if (def) {\n                        const type = def.type;\n\n                        // skip catch variables\n                        if (type === \"CatchClause\") {\n                            if (config.caughtErrors === \"none\") {\n                                continue;\n                            }\n\n                            // skip ignored parameters\n                            if (config.caughtErrorsIgnorePattern && config.caughtErrorsIgnorePattern.test(def.name.name)) {\n                                continue;\n                            }\n                        }\n\n                        if (type === \"Parameter\") {\n\n                            // skip any setter argument\n                            if ((def.node.parent.type === \"Property\" || def.node.parent.type === \"MethodDefinition\") && def.node.parent.kind === \"set\") {\n                                continue;\n                            }\n\n                            // if \"args\" option is \"none\", skip any parameter\n                            if (config.args === \"none\") {\n                                continue;\n                            }\n\n                            // skip ignored parameters\n                            if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {\n                                continue;\n                            }\n\n                            // if \"args\" option is \"after-used\", skip all but the last parameter\n                            if (config.args === \"after-used\" && astUtils.isFunction(def.name.parent) && !isLastInNonIgnoredParameters(variable)) {\n                                continue;\n                            }\n                        } else {\n\n                            // skip ignored variables\n                            if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {\n                                continue;\n                            }\n                        }\n                    }\n\n                    if (!isUsedVariable(variable) && !isExported(variable) && !hasRestSpreadSibling(variable)) {\n                        unusedVars.push(variable);\n                    }\n                }\n            }\n\n            for (i = 0, l = childScopes.length; i < l; ++i) {\n                collectUnusedVariables(childScopes[i], unusedVars);\n            }\n\n            return unusedVars;\n        }\n\n        /**\n         * Gets the index of a given variable name in a given comment.\n         * @param {eslint-scope.Variable} variable - A variable to get.\n         * @param {ASTNode} comment - A comment node which includes the variable name.\n         * @returns {number} The index of the variable name's location.\n         * @private\n         */\n        function getColumnInComment(variable, comment) {\n            const namePattern = new RegExp(`[\\\\s,]${lodash.escapeRegExp(variable.name)}(?:$|[\\\\s,:])`, \"g\");\n\n            // To ignore the first text \"global\".\n            namePattern.lastIndex = comment.value.indexOf(\"global\") + 6;\n\n            // Search a given variable name.\n            const match = namePattern.exec(comment.value);\n\n            return match ? match.index + 1 : 0;\n        }\n\n        /**\n         * Creates the correct location of a given variables.\n         * The location is at its name string in a `/*global` comment.\n         *\n         * @param {eslint-scope.Variable} variable - A variable to get its location.\n         * @returns {{line: number, column: number}} The location object for the variable.\n         * @private\n         */\n        function getLocation(variable) {\n            const comment = variable.eslintExplicitGlobalComment;\n\n            return sourceCode.getLocFromIndex(comment.range[0] + 2 + getColumnInComment(variable, comment));\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            \"Program:exit\"(programNode) {\n                const unusedVars = collectUnusedVariables(context.getScope(), []);\n\n                for (let i = 0, l = unusedVars.length; i < l; ++i) {\n                    const unusedVar = unusedVars[i];\n\n                    if (unusedVar.eslintExplicitGlobal) {\n                        context.report({\n                            node: programNode,\n                            loc: getLocation(unusedVar),\n                            message: getDefinedMessage(unusedVar),\n                            data: unusedVar\n                        });\n                    } else if (unusedVar.defs.length > 0) {\n                        context.report({\n                            node: unusedVar.identifiers[0],\n                            message: unusedVar.references.some(ref => ref.isWrite())\n                                ? getAssignedMessage()\n                                : getDefinedMessage(unusedVar),\n                            data: unusedVar\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","no-use-before-define.js":"/**\n * @fileoverview Rule to flag use of variables before they are defined\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/;\nconst FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/;\n\n/**\n * Parses a given value as options.\n *\n * @param {any} options - A value to parse.\n * @returns {Object} The parsed options.\n */\nfunction parseOptions(options) {\n    let functions = true;\n    let classes = true;\n    let variables = true;\n\n    if (typeof options === \"string\") {\n        functions = (options !== \"nofunc\");\n    } else if (typeof options === \"object\" && options !== null) {\n        functions = options.functions !== false;\n        classes = options.classes !== false;\n        variables = options.variables !== false;\n    }\n\n    return { functions, classes, variables };\n}\n\n/**\n * Checks whether or not a given variable is a function declaration.\n *\n * @param {eslint-scope.Variable} variable - A variable to check.\n * @returns {boolean} `true` if the variable is a function declaration.\n */\nfunction isFunction(variable) {\n    return variable.defs[0].type === \"FunctionName\";\n}\n\n/**\n * Checks whether or not a given variable is a class declaration in an upper function scope.\n *\n * @param {eslint-scope.Variable} variable - A variable to check.\n * @param {eslint-scope.Reference} reference - A reference to check.\n * @returns {boolean} `true` if the variable is a class declaration.\n */\nfunction isOuterClass(variable, reference) {\n    return (\n        variable.defs[0].type === \"ClassName\" &&\n        variable.scope.variableScope !== reference.from.variableScope\n    );\n}\n\n/**\n* Checks whether or not a given variable is a variable declaration in an upper function scope.\n* @param {eslint-scope.Variable} variable - A variable to check.\n* @param {eslint-scope.Reference} reference - A reference to check.\n* @returns {boolean} `true` if the variable is a variable declaration.\n*/\nfunction isOuterVariable(variable, reference) {\n    return (\n        variable.defs[0].type === \"Variable\" &&\n        variable.scope.variableScope !== reference.from.variableScope\n    );\n}\n\n/**\n * Checks whether or not a given location is inside of the range of a given node.\n *\n * @param {ASTNode} node - An node to check.\n * @param {number} location - A location to check.\n * @returns {boolean} `true` if the location is inside of the range of the node.\n */\nfunction isInRange(node, location) {\n    return node && node.range[0] <= location && location <= node.range[1];\n}\n\n/**\n * Checks whether or not a given reference is inside of the initializers of a given variable.\n *\n * This returns `true` in the following cases:\n *\n *     var a = a\n *     var [a = a] = list\n *     var {a = a} = obj\n *     for (var a in a) {}\n *     for (var a of a) {}\n *\n * @param {Variable} variable - A variable to check.\n * @param {Reference} reference - A reference to check.\n * @returns {boolean} `true` if the reference is inside of the initializers.\n */\nfunction isInInitializer(variable, reference) {\n    if (variable.scope !== reference.from) {\n        return false;\n    }\n\n    let node = variable.identifiers[0].parent;\n    const location = reference.identifier.range[1];\n\n    while (node) {\n        if (node.type === \"VariableDeclarator\") {\n            if (isInRange(node.init, location)) {\n                return true;\n            }\n            if (FOR_IN_OF_TYPE.test(node.parent.parent.type) &&\n                isInRange(node.parent.parent.right, location)\n            ) {\n                return true;\n            }\n            break;\n        } else if (node.type === \"AssignmentPattern\") {\n            if (isInRange(node.right, location)) {\n                return true;\n            }\n        } else if (SENTINEL_TYPE.test(node.type)) {\n            break;\n        }\n\n        node = node.parent;\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of variables before they are defined\",\n            category: \"Variables\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"nofunc\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            functions: { type: \"boolean\" },\n                            classes: { type: \"boolean\" },\n                            variables: { type: \"boolean\" }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const options = parseOptions(context.options[0]);\n\n        /**\n         * Determines whether a given use-before-define case should be reported according to the options.\n         * @param {eslint-scope.Variable} variable The variable that gets used before being defined\n         * @param {eslint-scope.Reference} reference The reference to the variable\n         * @returns {boolean} `true` if the usage should be reported\n         */\n        function isForbidden(variable, reference) {\n            if (isFunction(variable)) {\n                return options.functions;\n            }\n            if (isOuterClass(variable, reference)) {\n                return options.classes;\n            }\n            if (isOuterVariable(variable, reference)) {\n                return options.variables;\n            }\n            return true;\n        }\n\n        /**\n         * Finds and validates all variables in a given scope.\n         * @param {Scope} scope The scope object.\n         * @returns {void}\n         * @private\n         */\n        function findVariablesInScope(scope) {\n            scope.references.forEach(reference => {\n                const variable = reference.resolved;\n\n                // Skips when the reference is:\n                // - initialization's.\n                // - referring to an undefined variable.\n                // - referring to a global environment variable (there're no identifiers).\n                // - located preceded by the variable (except in initializers).\n                // - allowed by options.\n                if (reference.init ||\n                    !variable ||\n                    variable.identifiers.length === 0 ||\n                    (variable.identifiers[0].range[1] < reference.identifier.range[1] && !isInInitializer(variable, reference)) ||\n                    !isForbidden(variable, reference)\n                ) {\n                    return;\n                }\n\n                // Reports.\n                context.report({\n                    node: reference.identifier,\n                    message: \"'{{name}}' was used before it was defined.\",\n                    data: reference.identifier\n                });\n            });\n        }\n\n        /**\n         * Validates variables inside of a node's scope.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         * @private\n         */\n        function findVariables() {\n            const scope = context.getScope();\n\n            findVariablesInScope(scope);\n        }\n\n        const ruleDefinition = {\n            \"Program:exit\"(node) {\n                const scope = context.getScope(),\n                    ecmaFeatures = context.parserOptions.ecmaFeatures || {};\n\n                findVariablesInScope(scope);\n\n                // both Node.js and Modules have an extra scope\n                if (ecmaFeatures.globalReturn || node.sourceType === \"module\") {\n                    findVariablesInScope(scope.childScopes[0]);\n                }\n            }\n        };\n\n        if (context.parserOptions.ecmaVersion >= 6) {\n            ruleDefinition[\"BlockStatement:exit\"] =\n                ruleDefinition[\"SwitchStatement:exit\"] = findVariables;\n\n            ruleDefinition[\"ArrowFunctionExpression:exit\"] = function(node) {\n                if (node.body.type !== \"BlockStatement\") {\n                    findVariables();\n                }\n            };\n        } else {\n            ruleDefinition[\"FunctionExpression:exit\"] =\n                ruleDefinition[\"FunctionDeclaration:exit\"] =\n                ruleDefinition[\"ArrowFunctionExpression:exit\"] = findVariables;\n        }\n\n        return ruleDefinition;\n    }\n};\n","no-useless-call.js":"/**\n * @fileoverview A rule to disallow unnecessary `.call()` and `.apply()`.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a node is a `.call()`/`.apply()`.\n * @param {ASTNode} node - A CallExpression node to check.\n * @returns {boolean} Whether or not the node is a `.call()`/`.apply()`.\n */\nfunction isCallOrNonVariadicApply(node) {\n    return (\n        node.callee.type === \"MemberExpression\" &&\n        node.callee.property.type === \"Identifier\" &&\n        node.callee.computed === false &&\n        (\n            (node.callee.property.name === \"call\" && node.arguments.length >= 1) ||\n            (node.callee.property.name === \"apply\" && node.arguments.length === 2 && node.arguments[1].type === \"ArrayExpression\")\n        )\n    );\n}\n\n/**\n * Checks whether or not the tokens of two given nodes are same.\n * @param {ASTNode} left - A node 1 to compare.\n * @param {ASTNode} right - A node 2 to compare.\n * @param {SourceCode} sourceCode - The ESLint source code object.\n * @returns {boolean} the source code for the given node.\n */\nfunction equalTokens(left, right, sourceCode) {\n    const tokensL = sourceCode.getTokens(left);\n    const tokensR = sourceCode.getTokens(right);\n\n    if (tokensL.length !== tokensR.length) {\n        return false;\n    }\n    for (let i = 0; i < tokensL.length; ++i) {\n        if (tokensL[i].type !== tokensR[i].type ||\n            tokensL[i].value !== tokensR[i].value\n        ) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Checks whether or not `thisArg` is not changed by `.call()`/`.apply()`.\n * @param {ASTNode|null} expectedThis - The node that is the owner of the applied function.\n * @param {ASTNode} thisArg - The node that is given to the first argument of the `.call()`/`.apply()`.\n * @param {SourceCode} sourceCode - The ESLint source code object.\n * @returns {boolean} Whether or not `thisArg` is not changed by `.call()`/`.apply()`.\n */\nfunction isValidThisArg(expectedThis, thisArg, sourceCode) {\n    if (!expectedThis) {\n        return astUtils.isNullOrUndefined(thisArg);\n    }\n    return equalTokens(expectedThis, thisArg, sourceCode);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary calls to `.call()` and `.apply()`\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            CallExpression(node) {\n                if (!isCallOrNonVariadicApply(node)) {\n                    return;\n                }\n\n                const applied = node.callee.object;\n                const expectedThis = (applied.type === \"MemberExpression\") ? applied.object : null;\n                const thisArg = node.arguments[0];\n\n                if (isValidThisArg(expectedThis, thisArg, sourceCode)) {\n                    context.report({ node, message: \"unnecessary '.{{name}}()'.\", data: { name: node.callee.property.name } });\n                }\n            }\n        };\n    }\n};\n","no-useless-computed-key.js":"/**\n * @fileoverview Rule to disallow unnecessary computed property keys in object literals\n * @author Burak Yigit Kaya\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst MESSAGE_UNNECESSARY_COMPUTED = \"Unnecessarily computed property [{{property}}] found.\";\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary computed property keys in object literals\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            Property(node) {\n                if (!node.computed) {\n                    return;\n                }\n\n                const key = node.key,\n                    nodeType = typeof key.value;\n\n                if (key.type === \"Literal\" && (nodeType === \"string\" || nodeType === \"number\") && key.value !== \"__proto__\") {\n                    context.report({\n                        node,\n                        message: MESSAGE_UNNECESSARY_COMPUTED,\n                        data: { property: sourceCode.getText(key) },\n                        fix(fixer) {\n                            const leftSquareBracket = sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken);\n                            const rightSquareBracket = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken);\n                            const tokensBetween = sourceCode.getTokensBetween(leftSquareBracket, rightSquareBracket, 1);\n\n                            if (tokensBetween.slice(0, -1).some((token, index) => sourceCode.getText().slice(token.range[1], tokensBetween[index + 1].range[0]).trim())) {\n\n                                // If there are comments between the brackets and the property name, don't do a fix.\n                                return null;\n                            }\n\n                            const tokenBeforeLeftBracket = sourceCode.getTokenBefore(leftSquareBracket);\n\n                            // Insert a space before the key to avoid changing identifiers, e.g. ({ get[2]() {} }) to ({ get2() {} })\n                            const needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] &&\n                                !astUtils.canTokensBeAdjacent(tokenBeforeLeftBracket, sourceCode.getFirstToken(key));\n\n                            const replacementKey = (needsSpaceBeforeKey ? \" \" : \"\") + key.raw;\n\n                            return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], replacementKey);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","no-useless-concat.js":"/**\n * @fileoverview disallow unncessary concatenation of template strings\n * @author Henry Zhu\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a concatenation.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is a concatenation.\n */\nfunction isConcatenation(node) {\n    return node.type === \"BinaryExpression\" && node.operator === \"+\";\n}\n\n/**\n * Checks if the given token is a `+` token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a `+` token.\n */\nfunction isConcatOperatorToken(token) {\n    return token.value === \"+\" && token.type === \"Punctuator\";\n}\n\n/**\n * Get's the right most node on the left side of a BinaryExpression with + operator.\n * @param {ASTNode} node - A BinaryExpression node to check.\n * @returns {ASTNode} node\n */\nfunction getLeft(node) {\n    let left = node.left;\n\n    while (isConcatenation(left)) {\n        left = left.right;\n    }\n    return left;\n}\n\n/**\n * Get's the left most node on the right side of a BinaryExpression with + operator.\n * @param {ASTNode} node - A BinaryExpression node to check.\n * @returns {ASTNode} node\n */\nfunction getRight(node) {\n    let right = node.right;\n\n    while (isConcatenation(right)) {\n        right = right.left;\n    }\n    return right;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary concatenation of literals or template literals\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            BinaryExpression(node) {\n\n                // check if not concatenation\n                if (node.operator !== \"+\") {\n                    return;\n                }\n\n                // account for the `foo + \"a\" + \"b\"` case\n                const left = getLeft(node);\n                const right = getRight(node);\n\n                if (astUtils.isStringLiteral(left) &&\n                    astUtils.isStringLiteral(right) &&\n                    astUtils.isTokenOnSameLine(left, right)\n                ) {\n                    const operatorToken = sourceCode.getFirstTokenBetween(left, right, isConcatOperatorToken);\n\n                    context.report({\n                        node,\n                        loc: operatorToken.loc.start,\n                        message: \"Unexpected string concatenation of literals.\"\n                    });\n                }\n            }\n        };\n    }\n};\n","no-useless-constructor.js":"/**\n * @fileoverview Rule to flag the use of redundant constructors in classes.\n * @author Alberto RodrÃ­guez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a given array of statements is a single call of `super`.\n *\n * @param {ASTNode[]} body - An array of statements to check.\n * @returns {boolean} `true` if the body is a single call of `super`.\n */\nfunction isSingleSuperCall(body) {\n    return (\n        body.length === 1 &&\n        body[0].type === \"ExpressionStatement\" &&\n        body[0].expression.type === \"CallExpression\" &&\n        body[0].expression.callee.type === \"Super\"\n    );\n}\n\n/**\n * Checks whether a given node is a pattern which doesn't have any side effects.\n * Default parameters and Destructuring parameters can have side effects.\n *\n * @param {ASTNode} node - A pattern node.\n * @returns {boolean} `true` if the node doesn't have any side effects.\n */\nfunction isSimple(node) {\n    return node.type === \"Identifier\" || node.type === \"RestElement\";\n}\n\n/**\n * Checks whether a given array of expressions is `...arguments` or not.\n * `super(...arguments)` passes all arguments through.\n *\n * @param {ASTNode[]} superArgs - An array of expressions to check.\n * @returns {boolean} `true` if the superArgs is `...arguments`.\n */\nfunction isSpreadArguments(superArgs) {\n    return (\n        superArgs.length === 1 &&\n        superArgs[0].type === \"SpreadElement\" &&\n        superArgs[0].argument.type === \"Identifier\" &&\n        superArgs[0].argument.name === \"arguments\"\n    );\n}\n\n/**\n * Checks whether given 2 nodes are identifiers which have the same name or not.\n *\n * @param {ASTNode} ctorParam - A node to check.\n * @param {ASTNode} superArg - A node to check.\n * @returns {boolean} `true` if the nodes are identifiers which have the same\n *      name.\n */\nfunction isValidIdentifierPair(ctorParam, superArg) {\n    return (\n        ctorParam.type === \"Identifier\" &&\n        superArg.type === \"Identifier\" &&\n        ctorParam.name === superArg.name\n    );\n}\n\n/**\n * Checks whether given 2 nodes are a rest/spread pair which has the same values.\n *\n * @param {ASTNode} ctorParam - A node to check.\n * @param {ASTNode} superArg - A node to check.\n * @returns {boolean} `true` if the nodes are a rest/spread pair which has the\n *      same values.\n */\nfunction isValidRestSpreadPair(ctorParam, superArg) {\n    return (\n        ctorParam.type === \"RestElement\" &&\n        superArg.type === \"SpreadElement\" &&\n        isValidIdentifierPair(ctorParam.argument, superArg.argument)\n    );\n}\n\n/**\n * Checks whether given 2 nodes have the same value or not.\n *\n * @param {ASTNode} ctorParam - A node to check.\n * @param {ASTNode} superArg - A node to check.\n * @returns {boolean} `true` if the nodes have the same value or not.\n */\nfunction isValidPair(ctorParam, superArg) {\n    return (\n        isValidIdentifierPair(ctorParam, superArg) ||\n        isValidRestSpreadPair(ctorParam, superArg)\n    );\n}\n\n/**\n * Checks whether the parameters of a constructor and the arguments of `super()`\n * have the same values or not.\n *\n * @param {ASTNode} ctorParams - The parameters of a constructor to check.\n * @param {ASTNode} superArgs - The arguments of `super()` to check.\n * @returns {boolean} `true` if those have the same values.\n */\nfunction isPassingThrough(ctorParams, superArgs) {\n    if (ctorParams.length !== superArgs.length) {\n        return false;\n    }\n\n    for (let i = 0; i < ctorParams.length; ++i) {\n        if (!isValidPair(ctorParams[i], superArgs[i])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Checks whether the constructor body is a redundant super call.\n *\n * @param {Array} body - constructor body content.\n * @param {Array} ctorParams - The params to check against super call.\n * @returns {boolean} true if the construtor body is redundant\n */\nfunction isRedundantSuperCall(body, ctorParams) {\n    return (\n        isSingleSuperCall(body) &&\n        ctorParams.every(isSimple) &&\n        (\n            isSpreadArguments(body[0].expression.arguments) ||\n            isPassingThrough(ctorParams, body[0].expression.arguments)\n        )\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary constructors\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Checks whether a node is a redundant constructor\n         * @param {ASTNode} node - node to check\n         * @returns {void}\n         */\n        function checkForConstructor(node) {\n            if (node.kind !== \"constructor\") {\n                return;\n            }\n\n            const body = node.value.body.body;\n            const ctorParams = node.value.params;\n            const superClass = node.parent.parent.superClass;\n\n            if (superClass ? isRedundantSuperCall(body, ctorParams) : (body.length === 0)) {\n                context.report({\n                    node,\n                    message: \"Useless constructor.\"\n                });\n            }\n        }\n\n        return {\n            MethodDefinition: checkForConstructor\n        };\n    }\n};\n","no-useless-escape.js":"/**\n * @fileoverview Look for useless escapes in strings and regexes\n * @author Onur Temizkan\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n* Returns the union of two sets.\n* @param {Set} setA The first set\n* @param {Set} setB The second set\n* @returns {Set} The union of the two sets\n*/\nfunction union(setA, setB) {\n    return new Set(function *() {\n        yield* setA;\n        yield* setB;\n    }());\n}\n\nconst VALID_STRING_ESCAPES = union(new Set(\"\\\\nrvtbfux\"), astUtils.LINEBREAKS);\nconst REGEX_GENERAL_ESCAPES = new Set(\"\\\\bcdDfnrsStvwWxu0123456789]\");\nconst REGEX_NON_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set(\"^/.$*+?[{}|()B\"));\n\n/**\n* Parses a regular expression into a list of characters with character class info.\n* @param {string} regExpText The raw text used to create the regular expression\n* @returns {Object[]} A list of characters, each with info on escaping and whether they're in a character class.\n* @example\n*\n* parseRegExp('a\\\\b[cd-]')\n*\n* returns:\n* [\n*   {text: 'a', index: 0, escaped: false, inCharClass: false, startsCharClass: false, endsCharClass: false},\n*   {text: 'b', index: 2, escaped: true, inCharClass: false, startsCharClass: false, endsCharClass: false},\n*   {text: 'c', index: 4, escaped: false, inCharClass: true, startsCharClass: true, endsCharClass: false},\n*   {text: 'd', index: 5, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false},\n*   {text: '-', index: 6, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false}\n* ]\n*/\nfunction parseRegExp(regExpText) {\n    const charList = [];\n\n    regExpText.split(\"\").reduce((state, char, index) => {\n        if (!state.escapeNextChar) {\n            if (char === \"\\\\\") {\n                return Object.assign(state, { escapeNextChar: true });\n            }\n            if (char === \"[\" && !state.inCharClass) {\n                return Object.assign(state, { inCharClass: true, startingCharClass: true });\n            }\n            if (char === \"]\" && state.inCharClass) {\n                if (charList.length && charList[charList.length - 1].inCharClass) {\n                    charList[charList.length - 1].endsCharClass = true;\n                }\n                return Object.assign(state, { inCharClass: false, startingCharClass: false });\n            }\n        }\n        charList.push({ text: char, index, escaped: state.escapeNextChar, inCharClass: state.inCharClass, startsCharClass: state.startingCharClass, endsCharClass: false });\n        return Object.assign(state, { escapeNextChar: false, startingCharClass: false });\n    }, { escapeNextChar: false, inCharClass: false, startingCharClass: false });\n\n    return charList;\n}\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary escape characters\",\n            category: \"Best Practices\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports a node\n         * @param {ASTNode} node The node to report\n         * @param {number} startOffset The backslash's offset from the start of the node\n         * @param {string} character The uselessly escaped character (not including the backslash)\n         * @returns {void}\n         */\n        function report(node, startOffset, character) {\n            context.report({\n                node,\n                loc: sourceCode.getLocFromIndex(sourceCode.getIndexFromLoc(node.loc.start) + startOffset),\n                message: \"Unnecessary escape character: \\\\{{character}}.\",\n                data: { character }\n            });\n        }\n\n        /**\n         * Checks if the escape character in given string slice is unnecessary.\n         *\n         * @private\n         * @param {ASTNode} node - node to validate.\n         * @param {string} match - string slice to validate.\n         * @returns {void}\n         */\n        function validateString(node, match) {\n            const isTemplateElement = node.type === \"TemplateElement\";\n            const escapedChar = match[0][1];\n            let isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);\n            let isQuoteEscape;\n\n            if (isTemplateElement) {\n                isQuoteEscape = escapedChar === \"`\";\n\n                if (escapedChar === \"$\") {\n\n                    // Warn if `\\$` is not followed by `{`\n                    isUnnecessaryEscape = match.input[match.index + 2] !== \"{\";\n                } else if (escapedChar === \"{\") {\n\n                    /* Warn if `\\{` is not preceded by `$`. If preceded by `$`, escaping\n                     * is necessary and the rule should not warn. If preceded by `/$`, the rule\n                     * will warn for the `/$` instead, as it is the first unnecessarily escaped character.\n                     */\n                    isUnnecessaryEscape = match.input[match.index - 1] !== \"$\";\n                }\n            } else {\n                isQuoteEscape = escapedChar === node.raw[0];\n            }\n\n            if (isUnnecessaryEscape && !isQuoteEscape) {\n                report(node, match.index + 1, match[0].slice(1));\n            }\n        }\n\n        /**\n         * Checks if a node has an escape.\n         *\n         * @param {ASTNode} node - node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            const isTemplateElement = node.type === \"TemplateElement\";\n\n            if (\n                isTemplateElement &&\n                node.parent &&\n                node.parent.parent &&\n                node.parent.parent.type === \"TaggedTemplateExpression\" &&\n                node.parent === node.parent.parent.quasi\n            ) {\n\n                // Don't report tagged template literals, because the backslash character is accessible to the tag function.\n                return;\n            }\n\n            if (typeof node.value === \"string\" || isTemplateElement) {\n\n                /*\n                 * JSXAttribute doesn't have any escape sequence: https://facebook.github.io/jsx/.\n                 * In addition, backticks are not supported by JSX yet: https://github.com/facebook/jsx/issues/25.\n                 */\n                if (node.parent.type === \"JSXAttribute\" || node.parent.type === \"JSXElement\") {\n                    return;\n                }\n\n                const value = isTemplateElement ? node.value.raw : node.raw.slice(1, -1);\n                const pattern = /\\\\[^\\d]/g;\n                let match;\n\n                while ((match = pattern.exec(value))) {\n                    validateString(node, match);\n                }\n            } else if (node.regex) {\n                parseRegExp(node.regex.pattern)\n\n                    /*\n                     * The '-' character is a special case, because it's only valid to escape it if it's in a character\n                     * class, and is not at either edge of the character class. To account for this, don't consider '-'\n                     * characters to be valid in general, and filter out '-' characters that appear in the middle of a\n                     * character class.\n                     */\n                    .filter(charInfo => !(charInfo.text === \"-\" && charInfo.inCharClass && !charInfo.startsCharClass && !charInfo.endsCharClass))\n\n                    /*\n                     * The '^' character is also a special case; it must always be escaped outside of character classes, but\n                     * it only needs to be escaped in character classes if it's at the beginning of the character class. To\n                     * account for this, consider it to be a valid escape character outside of character classes, and filter\n                     * out '^' characters that appear at the start of a character class.\n                     */\n                    .filter(charInfo => !(charInfo.text === \"^\" && charInfo.startsCharClass))\n\n                    // Filter out characters that aren't escaped.\n                    .filter(charInfo => charInfo.escaped)\n\n                    // Filter out characters that are valid to escape, based on their position in the regular expression.\n                    .filter(charInfo => !(charInfo.inCharClass ? REGEX_GENERAL_ESCAPES : REGEX_NON_CHARCLASS_ESCAPES).has(charInfo.text))\n\n                    // Report all the remaining characters.\n                    .forEach(charInfo => report(node, charInfo.index, charInfo.text));\n            }\n\n        }\n\n        return {\n            Literal: check,\n            TemplateElement: check\n        };\n    }\n};\n","no-useless-rename.js":"/**\n * @fileoverview Disallow renaming import, export, and destructured assignments to the same name.\n * @author Kai Cataldo\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow renaming import, export, and destructured assignments to the same name\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n        fixable: \"code\",\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreDestructuring: { type: \"boolean\" },\n                    ignoreImport: { type: \"boolean\" },\n                    ignoreExport: { type: \"boolean\" }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = context.options[0] || {},\n            ignoreDestructuring = options.ignoreDestructuring === true,\n            ignoreImport = options.ignoreImport === true,\n            ignoreExport = options.ignoreExport === true;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Reports error for unnecessarily renamed assignments\n         * @param {ASTNode} node - node to report\n         * @param {ASTNode} initial - node with initial name value\n         * @param {ASTNode} result - node with new name value\n         * @param {string} type - the type of the offending node\n         * @returns {void}\n         */\n        function reportError(node, initial, result, type) {\n            const name = initial.type === \"Identifier\" ? initial.name : initial.value;\n\n            return context.report({\n                node,\n                message: \"{{type}} {{name}} unnecessarily renamed.\",\n                data: {\n                    name,\n                    type\n                },\n                fix(fixer) {\n                    return fixer.replaceTextRange([\n                        initial.range[0],\n                        result.range[1]\n                    ], name);\n                }\n            });\n        }\n\n        /**\n         * Checks whether a destructured assignment is unnecessarily renamed\n         * @param {ASTNode} node - node to check\n         * @returns {void}\n         */\n        function checkDestructured(node) {\n            if (ignoreDestructuring) {\n                return;\n            }\n\n            const properties = node.properties;\n\n            for (let i = 0; i < properties.length; i++) {\n                if (properties[i].shorthand) {\n                    continue;\n                }\n\n                /**\n                 * If an ObjectPattern property is computed, we have no idea\n                 * if a rename is useless or not. If an ObjectPattern property\n                 * lacks a key, it is likely an ExperimentalRestProperty and\n                 * so there is no \"renaming\" occurring here.\n                 */\n                if (properties[i].computed || !properties[i].key) {\n                    continue;\n                }\n\n                if (properties[i].key.type === \"Identifier\" && properties[i].key.name === properties[i].value.name ||\n                        properties[i].key.type === \"Literal\" && properties[i].key.value === properties[i].value.name) {\n                    reportError(properties[i], properties[i].key, properties[i].value, \"Destructuring assignment\");\n                }\n            }\n        }\n\n        /**\n         * Checks whether an import is unnecessarily renamed\n         * @param {ASTNode} node - node to check\n         * @returns {void}\n         */\n        function checkImport(node) {\n            if (ignoreImport) {\n                return;\n            }\n\n            if (node.imported.name === node.local.name &&\n                    node.imported.range[0] !== node.local.range[0]) {\n                reportError(node, node.imported, node.local, \"Import\");\n            }\n        }\n\n        /**\n         * Checks whether an export is unnecessarily renamed\n         * @param {ASTNode} node - node to check\n         * @returns {void}\n         */\n        function checkExport(node) {\n            if (ignoreExport) {\n                return;\n            }\n\n            if (node.local.name === node.exported.name &&\n                    node.local.range[0] !== node.exported.range[0]) {\n                reportError(node, node.local, node.exported, \"Export\");\n            }\n\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ObjectPattern: checkDestructured,\n            ImportSpecifier: checkImport,\n            ExportSpecifier: checkExport\n        };\n    }\n};\n","no-useless-return.js":"/**\n * @fileoverview Disallow redundant return statements\n * @author Teddy Katz\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\"),\n    FixTracker = require(\"../util/fix-tracker\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Adds all elements of 2nd argument into 1st argument.\n *\n * @param {Array} array - The destination array to add.\n * @param {Array} elements - The source array to add.\n * @returns {void}\n */\nconst pushAll = Function.apply.bind(Array.prototype.push);\n\n/**\n * Removes the given element from the array.\n *\n * @param {Array} array - The source array to remove.\n * @param {any} element - The target item to remove.\n * @returns {void}\n */\nfunction remove(array, element) {\n    const index = array.indexOf(element);\n\n    if (index !== -1) {\n        array.splice(index, 1);\n    }\n}\n\n/**\n * Checks whether it can remove the given return statement or not.\n *\n * @param {ASTNode} node - The return statement node to check.\n * @returns {boolean} `true` if the node is removeable.\n */\nfunction isRemovable(node) {\n    return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);\n}\n\n/**\n * Checks whether the given return statement is in a `finally` block or not.\n *\n * @param {ASTNode} node - The return statement node to check.\n * @returns {boolean} `true` if the node is in a `finally` block.\n */\nfunction isInFinally(node) {\n    while (node && node.parent && !astUtils.isFunction(node)) {\n        if (node.parent.type === \"TryStatement\" && node.parent.finalizer === node) {\n            return true;\n        }\n\n        node = node.parent;\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow redundant return statements\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n        fixable: \"code\",\n        schema: []\n    },\n\n    create(context) {\n        const segmentInfoMap = new WeakMap();\n        const usedUnreachableSegments = new WeakSet();\n        let scopeInfo = null;\n\n        /**\n         * Checks whether the given segment is terminated by a return statement or not.\n         *\n         * @param {CodePathSegment} segment - The segment to check.\n         * @returns {boolean} `true` if the segment is terminated by a return statement, or if it's still a part of unreachable.\n         */\n        function isReturned(segment) {\n            const info = segmentInfoMap.get(segment);\n\n            return !info || info.returned;\n        }\n\n        /**\n         * Collects useless return statements from the given previous segments.\n         *\n         * A previous segment may be an unreachable segment.\n         * In that case, the information object of the unreachable segment is not\n         * initialized because `onCodePathSegmentStart` event is not notified for\n         * unreachable segments.\n         * This goes to the previous segments of the unreachable segment recursively\n         * if the unreachable segment was generated by a return statement. Otherwise,\n         * this ignores the unreachable segment.\n         *\n         * This behavior would simulate code paths for the case that the return\n         * statement does not exist.\n         *\n         * @param {ASTNode[]} uselessReturns - The collected return statements.\n         * @param {CodePathSegment[]} prevSegments - The previous segments to traverse.\n         * @param {WeakSet<CodePathSegment>} [traversedSegments] A set of segments that have already been traversed in this call\n         * @returns {ASTNode[]} `uselessReturns`.\n         */\n        function getUselessReturns(uselessReturns, prevSegments, traversedSegments) {\n            if (!traversedSegments) {\n                traversedSegments = new WeakSet();\n            }\n            for (const segment of prevSegments) {\n                if (!segment.reachable) {\n                    if (!traversedSegments.has(segment)) {\n                        traversedSegments.add(segment);\n                        getUselessReturns(\n                            uselessReturns,\n                            segment.allPrevSegments.filter(isReturned),\n                            traversedSegments\n                        );\n                    }\n                    continue;\n                }\n\n                pushAll(uselessReturns, segmentInfoMap.get(segment).uselessReturns);\n            }\n\n            return uselessReturns;\n        }\n\n        /**\n         * Removes the return statements on the given segment from the useless return\n         * statement list.\n         *\n         * This segment may be an unreachable segment.\n         * In that case, the information object of the unreachable segment is not\n         * initialized because `onCodePathSegmentStart` event is not notified for\n         * unreachable segments.\n         * This goes to the previous segments of the unreachable segment recursively\n         * if the unreachable segment was generated by a return statement. Otherwise,\n         * this ignores the unreachable segment.\n         *\n         * This behavior would simulate code paths for the case that the return\n         * statement does not exist.\n         *\n         * @param {CodePathSegment} segment - The segment to get return statements.\n         * @returns {void}\n         */\n        function markReturnStatementsOnSegmentAsUsed(segment) {\n            if (!segment.reachable) {\n                usedUnreachableSegments.add(segment);\n                segment.allPrevSegments\n                    .filter(isReturned)\n                    .filter(prevSegment => !usedUnreachableSegments.has(prevSegment))\n                    .forEach(markReturnStatementsOnSegmentAsUsed);\n                return;\n            }\n\n            const info = segmentInfoMap.get(segment);\n\n            for (const node of info.uselessReturns) {\n                remove(scopeInfo.uselessReturns, node);\n            }\n            info.uselessReturns = [];\n        }\n\n        /**\n         * Removes the return statements on the current segments from the useless\n         * return statement list.\n         *\n         * This function will be called at every statement except FunctionDeclaration,\n         * BlockStatement, and BreakStatement.\n         *\n         * - FunctionDeclarations are always executed whether it's returned or not.\n         * - BlockStatements do nothing.\n         * - BreakStatements go the next merely.\n         *\n         * @returns {void}\n         */\n        function markReturnStatementsOnCurrentSegmentsAsUsed() {\n            scopeInfo\n                .codePath\n                .currentSegments\n                .forEach(markReturnStatementsOnSegmentAsUsed);\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n\n            // Makes and pushs a new scope information.\n            onCodePathStart(codePath) {\n                scopeInfo = {\n                    upper: scopeInfo,\n                    uselessReturns: [],\n                    codePath\n                };\n            },\n\n            // Reports useless return statements if exist.\n            onCodePathEnd() {\n                for (const node of scopeInfo.uselessReturns) {\n                    context.report({\n                        node,\n                        loc: node.loc,\n                        message: \"Unnecessary return statement.\",\n                        fix(fixer) {\n                            if (isRemovable(node)) {\n\n                                // Extend the replacement range to include the\n                                // entire function to avoid conflicting with\n                                // no-else-return.\n                                // https://github.com/eslint/eslint/issues/8026\n                                return new FixTracker(fixer, context.getSourceCode())\n                                    .retainEnclosingFunction(node)\n                                    .remove(node);\n                            }\n                            return null;\n                        }\n                    });\n                }\n\n                scopeInfo = scopeInfo.upper;\n            },\n\n            // Initializes segments.\n            // NOTE: This event is notified for only reachable segments.\n            onCodePathSegmentStart(segment) {\n                const info = {\n                    uselessReturns: getUselessReturns([], segment.allPrevSegments),\n                    returned: false\n                };\n\n                // Stores the info.\n                segmentInfoMap.set(segment, info);\n            },\n\n            // Adds ReturnStatement node to check whether it's useless or not.\n            ReturnStatement(node) {\n                if (node.argument) {\n                    markReturnStatementsOnCurrentSegmentsAsUsed();\n                }\n                if (node.argument || astUtils.isInLoop(node) || isInFinally(node)) {\n                    return;\n                }\n\n                for (const segment of scopeInfo.codePath.currentSegments) {\n                    const info = segmentInfoMap.get(segment);\n\n                    if (info) {\n                        info.uselessReturns.push(node);\n                        info.returned = true;\n                    }\n                }\n                scopeInfo.uselessReturns.push(node);\n            },\n\n            // Registers for all statement nodes except FunctionDeclaration, BlockStatement, BreakStatement.\n            // Removes return statements of the current segments from the useless return statement list.\n            ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExportDefaultDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed\n        };\n    }\n};\n","no-var.js":"/**\n * @fileoverview Rule to check for the usage of var.\n * @author Jamund Ferguson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Finds the nearest function scope or global scope walking up the scope\n * hierarchy.\n *\n * @param {eslint-scope.Scope} scope - The scope to traverse.\n * @returns {eslint-scope.Scope} a function scope or global scope containing the given\n *      scope.\n */\nfunction getEnclosingFunctionScope(scope) {\n    while (scope.type !== \"function\" && scope.type !== \"global\") {\n        scope = scope.upper;\n    }\n    return scope;\n}\n\n/**\n * Checks whether the given variable has any references from a more specific\n * function expression (i.e. a closure).\n *\n * @param {eslint-scope.Variable} variable - A variable to check.\n * @returns {boolean} `true` if the variable is used from a closure.\n */\nfunction isReferencedInClosure(variable) {\n    const enclosingFunctionScope = getEnclosingFunctionScope(variable.scope);\n\n    return variable.references.some(reference =>\n        getEnclosingFunctionScope(reference.from) !== enclosingFunctionScope);\n}\n\n/**\n * Checks whether the given node is the assignee of a loop.\n *\n * @param {ASTNode} node - A VariableDeclaration node to check.\n * @returns {boolean} `true` if the declaration is assigned as part of loop\n *      iteration.\n */\nfunction isLoopAssignee(node) {\n    return (node.parent.type === \"ForOfStatement\" || node.parent.type === \"ForInStatement\") &&\n        node === node.parent.left;\n}\n\n/**\n * Checks whether the given variable declaration is immediately initialized.\n *\n * @param {ASTNode} node - A VariableDeclaration node to check.\n * @returns {boolean} `true` if the declaration has an initializer.\n */\nfunction isDeclarationInitialized(node) {\n    return node.declarations.every(declarator => declarator.init !== null);\n}\n\nconst SCOPE_NODE_TYPE = /^(?:Program|BlockStatement|SwitchStatement|ForStatement|ForInStatement|ForOfStatement)$/;\n\n/**\n * Gets the scope node which directly contains a given node.\n *\n * @param {ASTNode} node - A node to get. This is a `VariableDeclaration` or\n *      an `Identifier`.\n * @returns {ASTNode} A scope node. This is one of `Program`, `BlockStatement`,\n *      `SwitchStatement`, `ForStatement`, `ForInStatement`, and\n *      `ForOfStatement`.\n */\nfunction getScopeNode(node) {\n    while (node) {\n        if (SCOPE_NODE_TYPE.test(node.type)) {\n            return node;\n        }\n\n        node = node.parent;\n    }\n\n    /* istanbul ignore next : unreachable */\n    return null;\n}\n\n/**\n * Checks whether a given variable is redeclared or not.\n *\n * @param {eslint-scope.Variable} variable - A variable to check.\n * @returns {boolean} `true` if the variable is redeclared.\n */\nfunction isRedeclared(variable) {\n    return variable.defs.length >= 2;\n}\n\n/**\n * Checks whether a given variable is used from outside of the specified scope.\n *\n * @param {ASTNode} scopeNode - A scope node to check.\n * @returns {Function} The predicate function which checks whether a given\n *      variable is used from outside of the specified scope.\n */\nfunction isUsedFromOutsideOf(scopeNode) {\n\n    /**\n     * Checks whether a given reference is inside of the specified scope or not.\n     *\n     * @param {eslint-scope.Reference} reference - A reference to check.\n     * @returns {boolean} `true` if the reference is inside of the specified\n     *      scope.\n     */\n    function isOutsideOfScope(reference) {\n        const scope = scopeNode.range;\n        const id = reference.identifier.range;\n\n        return id[0] < scope[0] || id[1] > scope[1];\n    }\n\n    return function(variable) {\n        return variable.references.some(isOutsideOfScope);\n    };\n}\n\n/**\n * Creates the predicate function which checks whether a variable has their references in TDZ.\n *\n * The predicate function would return `true`:\n *\n * - if a reference is before the declarator. E.g. (var a = b, b = 1;)(var {a = b, b} = {};)\n * - if a reference is in the expression of their default value.  E.g. (var {a = a} = {};)\n * - if a reference is in the expression of their initializer.  E.g. (var a = a;)\n *\n * @param {ASTNode} node - The initializer node of VariableDeclarator.\n * @returns {Function} The predicate function.\n * @private\n */\nfunction hasReferenceInTDZ(node) {\n    const initStart = node.range[0];\n    const initEnd = node.range[1];\n\n    return variable => {\n        const id = variable.defs[0].name;\n        const idStart = id.range[0];\n        const defaultValue = (id.parent.type === \"AssignmentPattern\" ? id.parent.right : null);\n        const defaultStart = defaultValue && defaultValue.range[0];\n        const defaultEnd = defaultValue && defaultValue.range[1];\n\n        return variable.references.some(reference => {\n            const start = reference.identifier.range[0];\n            const end = reference.identifier.range[1];\n\n            return !reference.init && (\n                start < idStart ||\n                (defaultValue !== null && start >= defaultStart && end <= defaultEnd) ||\n                (start >= initStart && end <= initEnd)\n            );\n        });\n    };\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require `let` or `const` instead of `var`\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: [],\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Checks whether the variables which are defined by the given declarator node have their references in TDZ.\n         *\n         * @param {ASTNode} declarator - The VariableDeclarator node to check.\n         * @returns {boolean} `true` if one of the variables which are defined by the given declarator node have their references in TDZ.\n         */\n        function hasSelfReferenceInTDZ(declarator) {\n            if (!declarator.init) {\n                return false;\n            }\n            const variables = context.getDeclaredVariables(declarator);\n\n            return variables.some(hasReferenceInTDZ(declarator.init));\n        }\n\n        /**\n         * Checks whether it can fix a given variable declaration or not.\n         * It cannot fix if the following cases:\n         *\n         * - A variable is declared on a SwitchCase node.\n         * - A variable is redeclared.\n         * - A variable is used from outside the scope.\n         * - A variable is used from a closure within a loop.\n         * - A variable might be used before it is assigned within a loop.\n         * - A variable might be used in TDZ.\n         * - A variable is declared in statement position (e.g. a single-line `IfStatement`)\n         *\n         * ## A variable is declared on a SwitchCase node.\n         *\n         * If this rule modifies 'var' declarations on a SwitchCase node, it\n         * would generate the warnings of 'no-case-declarations' rule. And the\n         * 'eslint:recommended' preset includes 'no-case-declarations' rule, so\n         * this rule doesn't modify those declarations.\n         *\n         * ## A variable is redeclared.\n         *\n         * The language spec disallows redeclarations of `let` declarations.\n         * Those variables would cause syntax errors.\n         *\n         * ## A variable is used from outside the scope.\n         *\n         * The language spec disallows accesses from outside of the scope for\n         * `let` declarations. Those variables would cause reference errors.\n         *\n         * ## A variable is used from a closure within a loop.\n         *\n         * A `var` declaration within a loop shares the same variable instance\n         * across all loop iterations, while a `let` declaration creates a new\n         * instance for each iteration. This means if a variable in a loop is\n         * referenced by any closure, changing it from `var` to `let` would\n         * change the behavior in a way that is generally unsafe.\n         *\n         * ## A variable might be used before it is assigned within a loop.\n         *\n         * Within a loop, a `let` declaration without an initializer will be\n         * initialized to null, while a `var` declaration will retain its value\n         * from the previous iteration, so it is only safe to change `var` to\n         * `let` if we can statically determine that the variable is always\n         * assigned a value before its first access in the loop body. To keep\n         * the implementation simple, we only convert `var` to `let` within\n         * loops when the variable is a loop assignee or the declaration has an\n         * initializer.\n         *\n         * @param {ASTNode} node - A variable declaration node to check.\n         * @returns {boolean} `true` if it can fix the node.\n         */\n        function canFix(node) {\n            const variables = context.getDeclaredVariables(node);\n            const scopeNode = getScopeNode(node);\n\n            if (node.parent.type === \"SwitchCase\" ||\n                node.declarations.some(hasSelfReferenceInTDZ) ||\n                variables.some(isRedeclared) ||\n                variables.some(isUsedFromOutsideOf(scopeNode))\n            ) {\n                return false;\n            }\n\n            if (astUtils.isInLoop(node)) {\n                if (variables.some(isReferencedInClosure)) {\n                    return false;\n                }\n                if (!isLoopAssignee(node) && !isDeclarationInitialized(node)) {\n                    return false;\n                }\n            }\n\n            if (\n                !isLoopAssignee(node) &&\n                !(node.parent.type === \"ForStatement\" && node.parent.init === node) &&\n                !astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)\n            ) {\n\n                // If the declaration is not in a block, e.g. `if (foo) var bar = 1;`, then it can't be fixed.\n                return false;\n            }\n\n            return true;\n        }\n\n        /**\n         * Reports a given variable declaration node.\n         *\n         * @param {ASTNode} node - A variable declaration node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            const varToken = sourceCode.getFirstToken(node);\n\n            context.report({\n                node,\n                message: \"Unexpected var, use let or const instead.\",\n\n                fix(fixer) {\n                    if (canFix(node)) {\n                        return fixer.replaceText(varToken, \"let\");\n                    }\n                    return null;\n                }\n            });\n        }\n\n        return {\n            \"VariableDeclaration:exit\"(node) {\n                if (node.kind === \"var\") {\n                    report(node);\n                }\n            }\n        };\n    }\n};\n","no-void.js":"/**\n * @fileoverview Rule to disallow use of void operator.\n * @author Mike Sidorov\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `void` operators\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            UnaryExpression(node) {\n                if (node.operator === \"void\") {\n                    context.report({ node, message: \"Expected 'undefined' and instead saw 'void'.\" });\n                }\n            }\n        };\n\n    }\n};\n","no-warning-comments.js":"/**\n * @fileoverview Rule that warns about used warning comments\n * @author Alexander Schmidt <https://github.com/lxanders>\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow specified warning terms in comments\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    terms: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    location: {\n                        enum: [\"start\", \"anywhere\"]\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode(),\n            configuration = context.options[0] || {},\n            warningTerms = configuration.terms || [\"todo\", \"fixme\", \"xxx\"],\n            location = configuration.location || \"start\",\n            selfConfigRegEx = /\\bno-warning-comments\\b/;\n\n        /**\n         * Convert a warning term into a RegExp which will match a comment containing that whole word in the specified\n         * location (\"start\" or \"anywhere\"). If the term starts or ends with non word characters, then the match will not\n         * require word boundaries on that side.\n         *\n         * @param {string} term A term to convert to a RegExp\n         * @returns {RegExp} The term converted to a RegExp\n         */\n        function convertToRegExp(term) {\n            const escaped = term.replace(/[-/\\\\$^*+?.()|[\\]{}]/g, \"\\\\$&\");\n            let prefix;\n\n            /*\n             * If the term ends in a word character (a-z0-9_), ensure a word\n             * boundary at the end, so that substrings do not get falsely\n             * matched. eg \"todo\" in a string such as \"mastodon\".\n             * If the term ends in a non-word character, then \\b won't match on\n             * the boundary to the next non-word character, which would likely\n             * be a space. For example `/\\bFIX!\\b/.test('FIX! blah') === false`.\n             * In these cases, use no bounding match. Same applies for the\n             * prefix, handled below.\n             */\n            const suffix = /\\w$/.test(term) ? \"\\\\b\" : \"\";\n\n            if (location === \"start\") {\n\n                /*\n                 * When matching at the start, ignore leading whitespace, and\n                 * there's no need to worry about word boundaries.\n                 */\n                prefix = \"^\\\\s*\";\n            } else if (/^\\w/.test(term)) {\n                prefix = \"\\\\b\";\n            } else {\n                prefix = \"\";\n            }\n\n            return new RegExp(prefix + escaped + suffix, \"i\");\n        }\n\n        const warningRegExps = warningTerms.map(convertToRegExp);\n\n        /**\n         * Checks the specified comment for matches of the configured warning terms and returns the matches.\n         * @param {string} comment The comment which is checked.\n         * @returns {Array} All matched warning terms for this comment.\n         */\n        function commentContainsWarningTerm(comment) {\n            const matches = [];\n\n            warningRegExps.forEach((regex, index) => {\n                if (regex.test(comment)) {\n                    matches.push(warningTerms[index]);\n                }\n            });\n\n            return matches;\n        }\n\n        /**\n         * Checks the specified node for matching warning comments and reports them.\n         * @param {ASTNode} node The AST node being checked.\n         * @returns {void} undefined.\n         */\n        function checkComment(node) {\n            if (astUtils.isDirectiveComment(node) && selfConfigRegEx.test(node.value)) {\n                return;\n            }\n\n            const matches = commentContainsWarningTerm(node.value);\n\n            matches.forEach(matchedTerm => {\n                context.report({\n                    node,\n                    message: \"Unexpected '{{matchedTerm}}' comment.\",\n                    data: {\n                        matchedTerm\n                    }\n                });\n            });\n        }\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments.filter(token => token.type !== \"Shebang\").forEach(checkComment);\n            }\n        };\n    }\n};\n","no-whitespace-before-property.js":"/**\n * @fileoverview Rule to disallow whitespace before properties\n * @author Kai Cataldo\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow whitespace before properties\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Reports whitespace before property token\n         * @param {ASTNode} node - the node to report in the event of an error\n         * @param {Token} leftToken - the left token\n         * @param {Token} rightToken - the right token\n         * @returns {void}\n         * @private\n         */\n        function reportError(node, leftToken, rightToken) {\n            const replacementText = node.computed ? \"\" : \".\";\n\n            context.report({\n                node,\n                message: \"Unexpected whitespace before property {{propName}}.\",\n                data: {\n                    propName: sourceCode.getText(node.property)\n                },\n                fix(fixer) {\n                    if (!node.computed && astUtils.isDecimalInteger(node.object)) {\n\n                        // If the object is a number literal, fixing it to something like 5.toString() would cause a SyntaxError.\n                        // Don't fix this case.\n                        return null;\n                    }\n                    return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], replacementText);\n                }\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            MemberExpression(node) {\n                let rightToken;\n                let leftToken;\n\n                if (!astUtils.isTokenOnSameLine(node.object, node.property)) {\n                    return;\n                }\n\n                if (node.computed) {\n                    rightToken = sourceCode.getTokenBefore(node.property, astUtils.isOpeningBracketToken);\n                    leftToken = sourceCode.getTokenBefore(rightToken);\n                } else {\n                    rightToken = sourceCode.getFirstToken(node.property);\n                    leftToken = sourceCode.getTokenBefore(rightToken, 1);\n                }\n\n                if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken)) {\n                    reportError(node, leftToken, rightToken);\n                }\n            }\n        };\n    }\n};\n","no-with.js":"/**\n * @fileoverview Rule to flag use of with statement\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `with` statements\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n            WithStatement(node) {\n                context.report({ node, message: \"Unexpected use of 'with' statement.\" });\n            }\n        };\n\n    }\n};\n","nonblock-statement-body-position.js":"/**\n * @fileoverview enforce the location of single-line statements\n * @author Teddy Katz\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst POSITION_SCHEMA = { enum: [\"beside\", \"below\", \"any\"] };\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce the location of single-line statements\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        fixable: \"whitespace\",\n        schema: [\n            POSITION_SCHEMA,\n            {\n                properties: {\n                    overrides: {\n                        properties: {\n                            if: POSITION_SCHEMA,\n                            else: POSITION_SCHEMA,\n                            while: POSITION_SCHEMA,\n                            do: POSITION_SCHEMA,\n                            for: POSITION_SCHEMA\n                        },\n                        additionalProperties: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Gets the applicable preference for a particular keyword\n         * @param {string} keywordName The name of a keyword, e.g. 'if'\n         * @returns {string} The applicable option for the keyword, e.g. 'beside'\n         */\n        function getOption(keywordName) {\n            return context.options[1] && context.options[1].overrides && context.options[1].overrides[keywordName] ||\n                context.options[0] ||\n                \"beside\";\n        }\n\n        /**\n         * Validates the location of a single-line statement\n         * @param {ASTNode} node The single-line statement\n         * @param {string} keywordName The applicable keyword name for the single-line statement\n         * @returns {void}\n         */\n        function validateStatement(node, keywordName) {\n            const option = getOption(keywordName);\n\n            if (node.type === \"BlockStatement\" || option === \"any\") {\n                return;\n            }\n\n            const tokenBefore = sourceCode.getTokenBefore(node);\n\n            if (tokenBefore.loc.end.line === node.loc.start.line && option === \"below\") {\n                context.report({\n                    node,\n                    message: \"Expected a linebreak before this statement.\",\n                    fix: fixer => fixer.insertTextBefore(node, \"\\n\")\n                });\n            } else if (tokenBefore.loc.end.line !== node.loc.start.line && option === \"beside\") {\n                context.report({\n                    node,\n                    message: \"Expected no linebreak before this statement.\",\n                    fix(fixer) {\n                        if (sourceCode.getText().slice(tokenBefore.range[1], node.range[0]).trim()) {\n                            return null;\n                        }\n                        return fixer.replaceTextRange([tokenBefore.range[1], node.range[0]], \" \");\n                    }\n                });\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            IfStatement(node) {\n                validateStatement(node.consequent, \"if\");\n\n                // Check the `else` node, but don't check 'else if' statements.\n                if (node.alternate && node.alternate.type !== \"IfStatement\") {\n                    validateStatement(node.alternate, \"else\");\n                }\n            },\n            WhileStatement: node => validateStatement(node.body, \"while\"),\n            DoWhileStatement: node => validateStatement(node.body, \"do\"),\n            ForStatement: node => validateStatement(node.body, \"for\"),\n            ForInStatement: node => validateStatement(node.body, \"for\"),\n            ForOfStatement: node => validateStatement(node.body, \"for\")\n        };\n    }\n};\n","object-curly-newline.js":"/**\n * @fileoverview Rule to require or disallow line breaks inside braces.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n// Schema objects.\nconst OPTION_VALUE = {\n    oneOf: [\n        {\n            enum: [\"always\", \"never\"]\n        },\n        {\n            type: \"object\",\n            properties: {\n                multiline: {\n                    type: \"boolean\"\n                },\n                minProperties: {\n                    type: \"integer\",\n                    minimum: 0\n                },\n                consistent: {\n                    type: \"boolean\"\n                }\n            },\n            additionalProperties: false,\n            minProperties: 1\n        }\n    ]\n};\n\n/**\n * Normalizes a given option value.\n *\n * @param {string|Object|undefined} value - An option value to parse.\n * @returns {{multiline: boolean, minProperties: number, consistent: boolean}} Normalized option object.\n */\nfunction normalizeOptionValue(value) {\n    let multiline = false;\n    let minProperties = Number.POSITIVE_INFINITY;\n    let consistent = false;\n\n    if (value) {\n        if (value === \"always\") {\n            minProperties = 0;\n        } else if (value === \"never\") {\n            minProperties = Number.POSITIVE_INFINITY;\n        } else {\n            multiline = Boolean(value.multiline);\n            minProperties = value.minProperties || Number.POSITIVE_INFINITY;\n            consistent = Boolean(value.consistent);\n        }\n    } else {\n        multiline = true;\n    }\n\n    return { multiline, minProperties, consistent };\n}\n\n/**\n * Normalizes a given option value.\n *\n * @param {string|Object|undefined} options - An option value to parse.\n * @returns {{ObjectExpression: {multiline: boolean, minProperties: number}, ObjectPattern: {multiline: boolean, minProperties: number}}} Normalized option object.\n */\nfunction normalizeOptions(options) {\n    if (options && (options.ObjectExpression || options.ObjectPattern)) {\n        return {\n            ObjectExpression: normalizeOptionValue(options.ObjectExpression),\n            ObjectPattern: normalizeOptionValue(options.ObjectPattern)\n        };\n    }\n\n    const value = normalizeOptionValue(options);\n\n    return { ObjectExpression: value, ObjectPattern: value };\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent line breaks inside braces\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        fixable: \"whitespace\",\n        schema: [\n            {\n                oneOf: [\n                    OPTION_VALUE,\n                    {\n                        type: \"object\",\n                        properties: {\n                            ObjectExpression: OPTION_VALUE,\n                            ObjectPattern: OPTION_VALUE\n                        },\n                        additionalProperties: false,\n                        minProperties: 1\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const normalizedOptions = normalizeOptions(context.options[0]);\n\n        /**\n         * Reports a given node if it violated this rule.\n         *\n         * @param {ASTNode} node - A node to check. This is an ObjectExpression node or an ObjectPattern node.\n         * @param {{multiline: boolean, minProperties: number}} options - An option object.\n         * @returns {void}\n         */\n        function check(node) {\n            const options = normalizedOptions[node.type];\n            const openBrace = sourceCode.getFirstToken(node);\n            const closeBrace = sourceCode.getLastToken(node);\n            let first = sourceCode.getTokenAfter(openBrace, { includeComments: true });\n            let last = sourceCode.getTokenBefore(closeBrace, { includeComments: true });\n            const needsLinebreaks = (\n                node.properties.length >= options.minProperties ||\n                (\n                    options.multiline &&\n                    node.properties.length > 0 &&\n                    first.loc.start.line !== last.loc.end.line\n                )\n            );\n            const hasCommentsFirstToken = astUtils.isCommentToken(first);\n            const hasCommentsLastToken = astUtils.isCommentToken(last);\n\n            /*\n             * Use tokens or comments to check multiline or not.\n             * But use only tokens to check whether line breaks are needed.\n             * This allows:\n             *     var obj = { // eslint-disable-line foo\n             *         a: 1\n             *     }\n             */\n            first = sourceCode.getTokenAfter(openBrace);\n            last = sourceCode.getTokenBefore(closeBrace);\n\n            if (needsLinebreaks) {\n                if (astUtils.isTokenOnSameLine(openBrace, first)) {\n                    context.report({\n                        message: \"Expected a line break after this opening brace.\",\n                        node,\n                        loc: openBrace.loc.start,\n                        fix(fixer) {\n                            if (hasCommentsFirstToken) {\n                                return null;\n                            }\n\n                            return fixer.insertTextAfter(openBrace, \"\\n\");\n                        }\n                    });\n                }\n                if (astUtils.isTokenOnSameLine(last, closeBrace)) {\n                    context.report({\n                        message: \"Expected a line break before this closing brace.\",\n                        node,\n                        loc: closeBrace.loc.start,\n                        fix(fixer) {\n                            if (hasCommentsLastToken) {\n                                return null;\n                            }\n\n                            return fixer.insertTextBefore(closeBrace, \"\\n\");\n                        }\n                    });\n                }\n            } else {\n                const consistent = options.consistent;\n                const hasLineBreakBetweenOpenBraceAndFirst = !astUtils.isTokenOnSameLine(openBrace, first);\n                const hasLineBreakBetweenCloseBraceAndLast = !astUtils.isTokenOnSameLine(last, closeBrace);\n\n                if (\n                    (!consistent && hasLineBreakBetweenOpenBraceAndFirst) ||\n                    (consistent && hasLineBreakBetweenOpenBraceAndFirst && !hasLineBreakBetweenCloseBraceAndLast)\n                ) {\n                    context.report({\n                        message: \"Unexpected line break after this opening brace.\",\n                        node,\n                        loc: openBrace.loc.start,\n                        fix(fixer) {\n                            if (hasCommentsFirstToken) {\n                                return null;\n                            }\n\n                            return fixer.removeRange([\n                                openBrace.range[1],\n                                first.range[0]\n                            ]);\n                        }\n                    });\n                }\n                if (\n                    (!consistent && hasLineBreakBetweenCloseBraceAndLast) ||\n                    (consistent && !hasLineBreakBetweenOpenBraceAndFirst && hasLineBreakBetweenCloseBraceAndLast)\n                ) {\n                    context.report({\n                        message: \"Unexpected line break before this closing brace.\",\n                        node,\n                        loc: closeBrace.loc.start,\n                        fix(fixer) {\n                            if (hasCommentsLastToken) {\n                                return null;\n                            }\n\n                            return fixer.removeRange([\n                                last.range[1],\n                                closeBrace.range[0]\n                            ]);\n                        }\n                    });\n                }\n            }\n        }\n\n        return {\n            ObjectExpression: check,\n            ObjectPattern: check\n        };\n    }\n};\n","object-curly-spacing.js":"/**\n * @fileoverview Disallows or enforces spaces inside of object literals.\n * @author Jamund Ferguson\n */\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing inside braces\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    arraysInObjects: {\n                        type: \"boolean\"\n                    },\n                    objectsInObjects: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const spaced = context.options[0] === \"always\",\n            sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether an option is set, relative to the spacing option.\n         * If spaced is \"always\", then check whether option is set to false.\n         * If spaced is \"never\", then check whether option is set to true.\n         * @param {Object} option - The option to exclude.\n         * @returns {boolean} Whether or not the property is excluded.\n         */\n        function isOptionSet(option) {\n            return context.options[1] ? context.options[1][option] === !spaced : false;\n        }\n\n        const options = {\n            spaced,\n            arraysInObjectsException: isOptionSet(\"arraysInObjects\"),\n            objectsInObjectsException: isOptionSet(\"objectsInObjects\")\n        };\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n        * Reports that there shouldn't be a space after the first token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @returns {void}\n        */\n        function reportNoBeginningSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"There should be no space after '{{token}}'.\",\n                data: {\n                    token: token.value\n                },\n                fix(fixer) {\n                    const nextToken = context.getSourceCode().getTokenAfter(token);\n\n                    return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                }\n            });\n        }\n\n        /**\n        * Reports that there shouldn't be a space before the last token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @returns {void}\n        */\n        function reportNoEndingSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"There should be no space before '{{token}}'.\",\n                data: {\n                    token: token.value\n                },\n                fix(fixer) {\n                    const previousToken = context.getSourceCode().getTokenBefore(token);\n\n                    return fixer.removeRange([previousToken.range[1], token.range[0]]);\n                }\n            });\n        }\n\n        /**\n        * Reports that there should be a space after the first token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @returns {void}\n        */\n        function reportRequiredBeginningSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"A space is required after '{{token}}'.\",\n                data: {\n                    token: token.value\n                },\n                fix(fixer) {\n                    return fixer.insertTextAfter(token, \" \");\n                }\n            });\n        }\n\n        /**\n        * Reports that there should be a space before the last token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @returns {void}\n        */\n        function reportRequiredEndingSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"A space is required before '{{token}}'.\",\n                data: {\n                    token: token.value\n                },\n                fix(fixer) {\n                    return fixer.insertTextBefore(token, \" \");\n                }\n            });\n        }\n\n        /**\n         * Determines if spacing in curly braces is valid.\n         * @param {ASTNode} node The AST node to check.\n         * @param {Token} first The first token to check (should be the opening brace)\n         * @param {Token} second The second token to check (should be first after the opening brace)\n         * @param {Token} penultimate The penultimate token to check (should be last before closing brace)\n         * @param {Token} last The last token to check (should be closing brace)\n         * @returns {void}\n         */\n        function validateBraceSpacing(node, first, second, penultimate, last) {\n            if (astUtils.isTokenOnSameLine(first, second)) {\n                const firstSpaced = sourceCode.isSpaceBetweenTokens(first, second);\n\n                if (options.spaced && !firstSpaced) {\n                    reportRequiredBeginningSpace(node, first);\n                }\n                if (!options.spaced && firstSpaced) {\n                    reportNoBeginningSpace(node, first);\n                }\n            }\n\n            if (astUtils.isTokenOnSameLine(penultimate, last)) {\n                const shouldCheckPenultimate = (\n                    options.arraysInObjectsException && astUtils.isClosingBracketToken(penultimate) ||\n                    options.objectsInObjectsException && astUtils.isClosingBraceToken(penultimate)\n                );\n                const penultimateType = shouldCheckPenultimate && sourceCode.getNodeByRangeIndex(penultimate.range[0]).type;\n\n                const closingCurlyBraceMustBeSpaced = (\n                    options.arraysInObjectsException && penultimateType === \"ArrayExpression\" ||\n                    options.objectsInObjectsException && (penultimateType === \"ObjectExpression\" || penultimateType === \"ObjectPattern\")\n                ) ? !options.spaced : options.spaced;\n\n                const lastSpaced = sourceCode.isSpaceBetweenTokens(penultimate, last);\n\n                if (closingCurlyBraceMustBeSpaced && !lastSpaced) {\n                    reportRequiredEndingSpace(node, last);\n                }\n                if (!closingCurlyBraceMustBeSpaced && lastSpaced) {\n                    reportNoEndingSpace(node, last);\n                }\n            }\n        }\n\n        /**\n         * Gets '}' token of an object node.\n         *\n         * Because the last token of object patterns might be a type annotation,\n         * this traverses tokens preceded by the last property, then returns the\n         * first '}' token.\n         *\n         * @param {ASTNode} node - The node to get. This node is an\n         *      ObjectExpression or an ObjectPattern. And this node has one or\n         *      more properties.\n         * @returns {Token} '}' token.\n         */\n        function getClosingBraceOfObject(node) {\n            const lastProperty = node.properties[node.properties.length - 1];\n\n            return sourceCode.getTokenAfter(lastProperty, astUtils.isClosingBraceToken);\n        }\n\n        /**\n         * Reports a given object node if spacing in curly braces is invalid.\n         * @param {ASTNode} node - An ObjectExpression or ObjectPattern node to check.\n         * @returns {void}\n         */\n        function checkForObject(node) {\n            if (node.properties.length === 0) {\n                return;\n            }\n\n            const first = sourceCode.getFirstToken(node),\n                last = getClosingBraceOfObject(node),\n                second = sourceCode.getTokenAfter(first),\n                penultimate = sourceCode.getTokenBefore(last);\n\n            validateBraceSpacing(node, first, second, penultimate, last);\n        }\n\n        /**\n         * Reports a given import node if spacing in curly braces is invalid.\n         * @param {ASTNode} node - An ImportDeclaration node to check.\n         * @returns {void}\n         */\n        function checkForImport(node) {\n            if (node.specifiers.length === 0) {\n                return;\n            }\n\n            let firstSpecifier = node.specifiers[0];\n            const lastSpecifier = node.specifiers[node.specifiers.length - 1];\n\n            if (lastSpecifier.type !== \"ImportSpecifier\") {\n                return;\n            }\n            if (firstSpecifier.type !== \"ImportSpecifier\") {\n                firstSpecifier = node.specifiers[1];\n            }\n\n            const first = sourceCode.getTokenBefore(firstSpecifier),\n                last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken),\n                second = sourceCode.getTokenAfter(first),\n                penultimate = sourceCode.getTokenBefore(last);\n\n            validateBraceSpacing(node, first, second, penultimate, last);\n        }\n\n        /**\n         * Reports a given export node if spacing in curly braces is invalid.\n         * @param {ASTNode} node - An ExportNamedDeclaration node to check.\n         * @returns {void}\n         */\n        function checkForExport(node) {\n            if (node.specifiers.length === 0) {\n                return;\n            }\n\n            const firstSpecifier = node.specifiers[0],\n                lastSpecifier = node.specifiers[node.specifiers.length - 1],\n                first = sourceCode.getTokenBefore(firstSpecifier),\n                last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken),\n                second = sourceCode.getTokenAfter(first),\n                penultimate = sourceCode.getTokenBefore(last);\n\n            validateBraceSpacing(node, first, second, penultimate, last);\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            // var {x} = y;\n            ObjectPattern: checkForObject,\n\n            // var y = {x: 'y'}\n            ObjectExpression: checkForObject,\n\n            // import {y} from 'x';\n            ImportDeclaration: checkForImport,\n\n            // export {name} from 'yo';\n            ExportNamedDeclaration: checkForExport\n        };\n\n    }\n};\n","object-property-newline.js":"/**\n * @fileoverview Rule to enforce placing object properties on separate lines.\n * @author Vitor Balocco\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce placing object properties on separate lines\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowMultiplePropertiesPerLine: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"whitespace\"\n    },\n\n    create(context) {\n        const allowSameLine = context.options[0] && Boolean(context.options[0].allowMultiplePropertiesPerLine);\n        const errorMessage = allowSameLine\n            ? \"Object properties must go on a new line if they aren't all on the same line.\"\n            : \"Object properties must go on a new line.\";\n\n        const sourceCode = context.getSourceCode();\n\n        return {\n            ObjectExpression(node) {\n                if (allowSameLine) {\n                    if (node.properties.length > 1) {\n                        const firstTokenOfFirstProperty = sourceCode.getFirstToken(node.properties[0]);\n                        const lastTokenOfLastProperty = sourceCode.getLastToken(node.properties[node.properties.length - 1]);\n\n                        if (firstTokenOfFirstProperty.loc.end.line === lastTokenOfLastProperty.loc.start.line) {\n\n                            // All keys and values are on the same line\n                            return;\n                        }\n                    }\n                }\n\n                for (let i = 1; i < node.properties.length; i++) {\n                    const lastTokenOfPreviousProperty = sourceCode.getLastToken(node.properties[i - 1]);\n                    const firstTokenOfCurrentProperty = sourceCode.getFirstToken(node.properties[i]);\n\n                    if (lastTokenOfPreviousProperty.loc.end.line === firstTokenOfCurrentProperty.loc.start.line) {\n                        context.report({\n                            node,\n                            loc: firstTokenOfCurrentProperty.loc.start,\n                            message: errorMessage,\n                            fix(fixer) {\n                                const comma = sourceCode.getTokenBefore(firstTokenOfCurrentProperty);\n                                const rangeAfterComma = [comma.range[1], firstTokenOfCurrentProperty.range[0]];\n\n                                // Don't perform a fix if there are any comments between the comma and the next property.\n                                if (sourceCode.text.slice(rangeAfterComma[0], rangeAfterComma[1]).trim()) {\n                                    return null;\n                                }\n\n                                return fixer.replaceTextRange(rangeAfterComma, \"\\n\");\n                            }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n","object-shorthand.js":"/**\n * @fileoverview Rule to enforce concise object methods and properties.\n * @author Jamund Ferguson\n */\n\n\"use strict\";\n\nconst OPTIONS = {\n    always: \"always\",\n    never: \"never\",\n    methods: \"methods\",\n    properties: \"properties\",\n    consistent: \"consistent\",\n    consistentAsNeeded: \"consistent-as-needed\"\n};\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow method and property shorthand syntax for object literals\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        fixable: \"code\",\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"methods\", \"properties\", \"never\", \"consistent\", \"consistent-as-needed\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"methods\", \"properties\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                avoidQuotes: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"methods\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                ignoreConstructors: {\n                                    type: \"boolean\"\n                                },\n                                avoidQuotes: {\n                                    type: \"boolean\"\n                                },\n                                avoidExplicitReturnArrows: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        }\n    },\n\n    create(context) {\n        const APPLY = context.options[0] || OPTIONS.always;\n        const APPLY_TO_METHODS = APPLY === OPTIONS.methods || APPLY === OPTIONS.always;\n        const APPLY_TO_PROPS = APPLY === OPTIONS.properties || APPLY === OPTIONS.always;\n        const APPLY_NEVER = APPLY === OPTIONS.never;\n        const APPLY_CONSISTENT = APPLY === OPTIONS.consistent;\n        const APPLY_CONSISTENT_AS_NEEDED = APPLY === OPTIONS.consistentAsNeeded;\n\n        const PARAMS = context.options[1] || {};\n        const IGNORE_CONSTRUCTORS = PARAMS.ignoreConstructors;\n        const AVOID_QUOTES = PARAMS.avoidQuotes;\n        const AVOID_EXPLICIT_RETURN_ARROWS = !!PARAMS.avoidExplicitReturnArrows;\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Determines if the first character of the name is a capital letter.\n         * @param {string} name The name of the node to evaluate.\n         * @returns {boolean} True if the first character of the property name is a capital letter, false if not.\n         * @private\n         */\n        function isConstructor(name) {\n            const firstChar = name.charAt(0);\n\n            return firstChar === firstChar.toUpperCase();\n        }\n\n        /**\n         * Determines if the property can have a shorthand form.\n         * @param {ASTNode} property Property AST node\n         * @returns {boolean} True if the property can have a shorthand form\n         * @private\n         **/\n        function canHaveShorthand(property) {\n            return (property.kind !== \"set\" && property.kind !== \"get\" && property.type !== \"SpreadProperty\" && property.type !== \"ExperimentalSpreadProperty\");\n        }\n\n        /**\n          * Checks whether a node is a string literal.\n          * @param   {ASTNode} node - Any AST node.\n          * @returns {boolean} `true` if it is a string literal.\n          */\n        function isStringLiteral(node) {\n            return node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        /**\n         * Determines if the property is a shorthand or not.\n         * @param {ASTNode} property Property AST node\n         * @returns {boolean} True if the property is considered shorthand, false if not.\n         * @private\n         **/\n        function isShorthand(property) {\n\n            // property.method is true when `{a(){}}`.\n            return (property.shorthand || property.method);\n        }\n\n        /**\n         * Determines if the property's key and method or value are named equally.\n         * @param {ASTNode} property Property AST node\n         * @returns {boolean} True if the key and value are named equally, false if not.\n         * @private\n         **/\n        function isRedundant(property) {\n            const value = property.value;\n\n            if (value.type === \"FunctionExpression\") {\n                return !value.id; // Only anonymous should be shorthand method.\n            }\n            if (value.type === \"Identifier\") {\n                return astUtils.getStaticPropertyName(property) === value.name;\n            }\n\n            return false;\n        }\n\n        /**\n         * Ensures that an object's properties are consistently shorthand, or not shorthand at all.\n         * @param   {ASTNode} node Property AST node\n         * @param   {boolean} checkRedundancy Whether to check longform redundancy\n         * @returns {void}\n         **/\n        function checkConsistency(node, checkRedundancy) {\n\n            // We are excluding getters/setters and spread properties as they are considered neither longform nor shorthand.\n            const properties = node.properties.filter(canHaveShorthand);\n\n            // Do we still have properties left after filtering the getters and setters?\n            if (properties.length > 0) {\n                const shorthandProperties = properties.filter(isShorthand);\n\n                // If we do not have an equal number of longform properties as\n                // shorthand properties, we are using the annotations inconsistently\n                if (shorthandProperties.length !== properties.length) {\n\n                    // We have at least 1 shorthand property\n                    if (shorthandProperties.length > 0) {\n                        context.report({ node, message: \"Unexpected mix of shorthand and non-shorthand properties.\" });\n                    } else if (checkRedundancy) {\n\n                        // If all properties of the object contain a method or value with a name matching it's key,\n                        // all the keys are redundant.\n                        const canAlwaysUseShorthand = properties.every(isRedundant);\n\n                        if (canAlwaysUseShorthand) {\n                            context.report({ node, message: \"Expected shorthand for all properties.\" });\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n        * Fixes a FunctionExpression node by making it into a shorthand property.\n        * @param {SourceCodeFixer} fixer The fixer object\n        * @param {ASTNode} node A `Property` node that has a `FunctionExpression` or `ArrowFunctionExpression` as its value\n        * @returns {Object} A fix for this node\n        */\n        function makeFunctionShorthand(fixer, node) {\n            const firstKeyToken = node.computed ? sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken) : sourceCode.getFirstToken(node.key);\n            const lastKeyToken = node.computed ? sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken) : sourceCode.getLastToken(node.key);\n            const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);\n            let keyPrefix = \"\";\n\n            if (node.value.generator) {\n                keyPrefix = \"*\";\n            } else if (node.value.async) {\n                keyPrefix = \"async \";\n            }\n\n            if (node.value.type === \"FunctionExpression\") {\n                const functionToken = sourceCode.getTokens(node.value).find(token => token.type === \"Keyword\" && token.value === \"function\");\n                const tokenBeforeParams = node.value.generator ? sourceCode.getTokenAfter(functionToken) : functionToken;\n\n                return fixer.replaceTextRange(\n                    [firstKeyToken.range[0], node.range[1]],\n                    keyPrefix + keyText + sourceCode.text.slice(tokenBeforeParams.range[1], node.value.range[1])\n                );\n            }\n            const arrowToken = sourceCode.getTokens(node.value).find(token => token.value === \"=>\");\n            const tokenBeforeArrow = sourceCode.getTokenBefore(arrowToken);\n            const hasParensAroundParameters = tokenBeforeArrow.type === \"Punctuator\" && tokenBeforeArrow.value === \")\";\n            const oldParamText = sourceCode.text.slice(sourceCode.getFirstToken(node.value, node.value.async ? 1 : 0).range[0], tokenBeforeArrow.range[1]);\n            const newParamText = hasParensAroundParameters ? oldParamText : `(${oldParamText})`;\n\n            return fixer.replaceTextRange(\n                [firstKeyToken.range[0], node.range[1]],\n                keyPrefix + keyText + newParamText + sourceCode.text.slice(arrowToken.range[1], node.value.range[1])\n            );\n\n        }\n\n        /**\n        * Fixes a FunctionExpression node by making it into a longform property.\n        * @param {SourceCodeFixer} fixer The fixer object\n        * @param {ASTNode} node A `Property` node that has a `FunctionExpression` as its value\n        * @returns {Object} A fix for this node\n        */\n        function makeFunctionLongform(fixer, node) {\n            const firstKeyToken = node.computed ? sourceCode.getTokens(node).find(token => token.value === \"[\") : sourceCode.getFirstToken(node.key);\n            const lastKeyToken = node.computed ? sourceCode.getTokensBetween(node.key, node.value).find(token => token.value === \"]\") : sourceCode.getLastToken(node.key);\n            const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);\n            let functionHeader = \"function\";\n\n            if (node.value.generator) {\n                functionHeader = \"function*\";\n            } else if (node.value.async) {\n                functionHeader = \"async function\";\n            }\n\n            return fixer.replaceTextRange([node.range[0], lastKeyToken.range[1]], `${keyText}: ${functionHeader}`);\n        }\n\n        /*\n         * To determine whether a given arrow function has a lexical identifier (`this`, `arguments`, `super`, or `new.target`),\n         * create a stack of functions that define these identifiers (i.e. all functions except arrow functions) as the AST is\n         * traversed. Whenever a new function is encountered, create a new entry on the stack (corresponding to a different lexical\n         * scope of `this`), and whenever a function is exited, pop that entry off the stack. When an arrow function is entered,\n         * keep a reference to it on the current stack entry, and remove that reference when the arrow function is exited.\n         * When a lexical identifier is encountered, mark all the arrow functions on the current stack entry by adding them\n         * to an `arrowsWithLexicalIdentifiers` set. Any arrow function in that set will not be reported by this rule,\n         * because converting it into a method would change the value of one of the lexical identifiers.\n         */\n        const lexicalScopeStack = [];\n        const arrowsWithLexicalIdentifiers = new WeakSet();\n        const argumentsIdentifiers = new WeakSet();\n\n        /**\n        * Enters a function. This creates a new lexical identifier scope, so a new Set of arrow functions is pushed onto the stack.\n        * Also, this marks all `arguments` identifiers so that they can be detected later.\n        * @returns {void}\n        */\n        function enterFunction() {\n            lexicalScopeStack.unshift(new Set());\n            context.getScope().variables.filter(variable => variable.name === \"arguments\").forEach(variable => {\n                variable.references.map(ref => ref.identifier).forEach(identifier => argumentsIdentifiers.add(identifier));\n            });\n        }\n\n        /**\n        * Exits a function. This pops the current set of arrow functions off the lexical scope stack.\n        * @returns {void}\n        */\n        function exitFunction() {\n            lexicalScopeStack.shift();\n        }\n\n        /**\n        * Marks the current function as having a lexical keyword. This implies that all arrow functions\n        * in the current lexical scope contain a reference to this lexical keyword.\n        * @returns {void}\n        */\n        function reportLexicalIdentifier() {\n            lexicalScopeStack[0].forEach(arrowFunction => arrowsWithLexicalIdentifiers.add(arrowFunction));\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: enterFunction,\n            FunctionDeclaration: enterFunction,\n            FunctionExpression: enterFunction,\n            \"Program:exit\": exitFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            \"FunctionExpression:exit\": exitFunction,\n\n            ArrowFunctionExpression(node) {\n                lexicalScopeStack[0].add(node);\n            },\n            \"ArrowFunctionExpression:exit\"(node) {\n                lexicalScopeStack[0].delete(node);\n            },\n\n            ThisExpression: reportLexicalIdentifier,\n            Super: reportLexicalIdentifier,\n            MetaProperty(node) {\n                if (node.meta.name === \"new\" && node.property.name === \"target\") {\n                    reportLexicalIdentifier();\n                }\n            },\n            Identifier(node) {\n                if (argumentsIdentifiers.has(node)) {\n                    reportLexicalIdentifier();\n                }\n            },\n\n            ObjectExpression(node) {\n                if (APPLY_CONSISTENT) {\n                    checkConsistency(node, false);\n                } else if (APPLY_CONSISTENT_AS_NEEDED) {\n                    checkConsistency(node, true);\n                }\n            },\n\n            \"Property:exit\"(node) {\n                const isConciseProperty = node.method || node.shorthand;\n\n                // Ignore destructuring assignment\n                if (node.parent.type === \"ObjectPattern\") {\n                    return;\n                }\n\n                // getters and setters are ignored\n                if (node.kind === \"get\" || node.kind === \"set\") {\n                    return;\n                }\n\n                // only computed methods can fail the following checks\n                if (node.computed && node.value.type !== \"FunctionExpression\" && node.value.type !== \"ArrowFunctionExpression\") {\n                    return;\n                }\n\n                //--------------------------------------------------------------\n                // Checks for property/method shorthand.\n                if (isConciseProperty) {\n                    if (node.method && (APPLY_NEVER || AVOID_QUOTES && isStringLiteral(node.key))) {\n                        const message = APPLY_NEVER ? \"Expected longform method syntax.\" : \"Expected longform method syntax for string literal keys.\";\n\n                        // { x() {} } should be written as { x: function() {} }\n                        context.report({\n                            node,\n                            message,\n                            fix: fixer => makeFunctionLongform(fixer, node)\n                        });\n                    } else if (APPLY_NEVER) {\n\n                        // { x } should be written as { x: x }\n                        context.report({\n                            node,\n                            message: \"Expected longform property syntax.\",\n                            fix: fixer => fixer.insertTextAfter(node.key, `: ${node.key.name}`)\n                        });\n                    }\n                } else if (APPLY_TO_METHODS && !node.value.id && (node.value.type === \"FunctionExpression\" || node.value.type === \"ArrowFunctionExpression\")) {\n                    if (IGNORE_CONSTRUCTORS && node.key.type === \"Identifier\" && isConstructor(node.key.name)) {\n                        return;\n                    }\n                    if (AVOID_QUOTES && isStringLiteral(node.key)) {\n                        return;\n                    }\n\n                    // {[x]: function(){}} should be written as {[x]() {}}\n                    if (node.value.type === \"FunctionExpression\" ||\n                        node.value.type === \"ArrowFunctionExpression\" &&\n                        node.value.body.type === \"BlockStatement\" &&\n                        AVOID_EXPLICIT_RETURN_ARROWS &&\n                        !arrowsWithLexicalIdentifiers.has(node.value)\n                    ) {\n                        context.report({\n                            node,\n                            message: \"Expected method shorthand.\",\n                            fix: fixer => makeFunctionShorthand(fixer, node)\n                        });\n                    }\n                } else if (node.value.type === \"Identifier\" && node.key.name === node.value.name && APPLY_TO_PROPS) {\n\n                    // {x: x} should be written as {x}\n                    context.report({\n                        node,\n                        message: \"Expected property shorthand.\",\n                        fix(fixer) {\n                            return fixer.replaceText(node, node.value.name);\n                        }\n                    });\n                } else if (node.value.type === \"Identifier\" && node.key.type === \"Literal\" && node.key.value === node.value.name && APPLY_TO_PROPS) {\n                    if (AVOID_QUOTES) {\n                        return;\n                    }\n\n                    // {\"x\": x} should be written as {x}\n                    context.report({\n                        node,\n                        message: \"Expected property shorthand.\",\n                        fix(fixer) {\n                            return fixer.replaceText(node, node.value.name);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","one-var-declaration-per-line.js":"/**\n * @fileoverview Rule to check multiple var declarations per line\n * @author Alberto RodrÃ­guez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow newlines around variable declarations\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"initializations\"]\n            }\n        ],\n\n        fixable: \"whitespace\"\n    },\n\n    create(context) {\n\n        const ERROR_MESSAGE = \"Expected variable declaration to be on a new line.\";\n        const always = context.options[0] === \"always\";\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n\n        /**\n         * Determine if provided keyword is a variant of for specifiers\n         * @private\n         * @param {string} keyword - keyword to test\n         * @returns {boolean} True if `keyword` is a variant of for specifier\n         */\n        function isForTypeSpecifier(keyword) {\n            return keyword === \"ForStatement\" || keyword === \"ForInStatement\" || keyword === \"ForOfStatement\";\n        }\n\n        /**\n         * Checks newlines around variable declarations.\n         * @private\n         * @param {ASTNode} node - `VariableDeclaration` node to test\n         * @returns {void}\n         */\n        function checkForNewLine(node) {\n            if (isForTypeSpecifier(node.parent.type)) {\n                return;\n            }\n\n            const declarations = node.declarations;\n            let prev;\n\n            declarations.forEach(current => {\n                if (prev && prev.loc.end.line === current.loc.start.line) {\n                    if (always || prev.init || current.init) {\n                        context.report({\n                            node,\n                            message: ERROR_MESSAGE,\n                            loc: current.loc.start,\n                            fix: fixer => fixer.insertTextBefore(current, \"\\n\")\n                        });\n                    }\n                }\n                prev = current;\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclaration: checkForNewLine\n        };\n\n    }\n};\n","one-var.js":"/**\n * @fileoverview A rule to control the use of single variable declarations.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce variables to be declared either together or separately in functions\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            var: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            let: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            const: {\n                                enum: [\"always\", \"never\"]\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            initialized: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            uninitialized: {\n                                enum: [\"always\", \"never\"]\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n\n        const MODE_ALWAYS = \"always\",\n            MODE_NEVER = \"never\";\n\n        const mode = context.options[0] || MODE_ALWAYS;\n\n        const options = {\n        };\n\n        if (typeof mode === \"string\") { // simple options configuration with just a string\n            options.var = { uninitialized: mode, initialized: mode };\n            options.let = { uninitialized: mode, initialized: mode };\n            options.const = { uninitialized: mode, initialized: mode };\n        } else if (typeof mode === \"object\") { // options configuration is an object\n            if (mode.hasOwnProperty(\"var\") && typeof mode.var === \"string\") {\n                options.var = { uninitialized: mode.var, initialized: mode.var };\n            }\n            if (mode.hasOwnProperty(\"let\") && typeof mode.let === \"string\") {\n                options.let = { uninitialized: mode.let, initialized: mode.let };\n            }\n            if (mode.hasOwnProperty(\"const\") && typeof mode.const === \"string\") {\n                options.const = { uninitialized: mode.const, initialized: mode.const };\n            }\n            if (mode.hasOwnProperty(\"uninitialized\")) {\n                if (!options.var) {\n                    options.var = {};\n                }\n                if (!options.let) {\n                    options.let = {};\n                }\n                if (!options.const) {\n                    options.const = {};\n                }\n                options.var.uninitialized = mode.uninitialized;\n                options.let.uninitialized = mode.uninitialized;\n                options.const.uninitialized = mode.uninitialized;\n            }\n            if (mode.hasOwnProperty(\"initialized\")) {\n                if (!options.var) {\n                    options.var = {};\n                }\n                if (!options.let) {\n                    options.let = {};\n                }\n                if (!options.const) {\n                    options.const = {};\n                }\n                options.var.initialized = mode.initialized;\n                options.let.initialized = mode.initialized;\n                options.const.initialized = mode.initialized;\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const functionStack = [];\n        const blockStack = [];\n\n        /**\n         * Increments the blockStack counter.\n         * @returns {void}\n         * @private\n         */\n        function startBlock() {\n            blockStack.push({\n                let: { initialized: false, uninitialized: false },\n                const: { initialized: false, uninitialized: false }\n            });\n        }\n\n        /**\n         * Increments the functionStack counter.\n         * @returns {void}\n         * @private\n         */\n        function startFunction() {\n            functionStack.push({ initialized: false, uninitialized: false });\n            startBlock();\n        }\n\n        /**\n         * Decrements the blockStack counter.\n         * @returns {void}\n         * @private\n         */\n        function endBlock() {\n            blockStack.pop();\n        }\n\n        /**\n         * Decrements the functionStack counter.\n         * @returns {void}\n         * @private\n         */\n        function endFunction() {\n            functionStack.pop();\n            endBlock();\n        }\n\n        /**\n         * Records whether initialized or uninitialized variables are defined in current scope.\n         * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n         * @param {ASTNode[]} declarations List of declarations\n         * @param {Object} currentScope The scope being investigated\n         * @returns {void}\n         * @private\n         */\n        function recordTypes(statementType, declarations, currentScope) {\n            for (let i = 0; i < declarations.length; i++) {\n                if (declarations[i].init === null) {\n                    if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) {\n                        currentScope.uninitialized = true;\n                    }\n                } else {\n                    if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) {\n                        currentScope.initialized = true;\n                    }\n                }\n            }\n        }\n\n        /**\n         * Determines the current scope (function or block)\n         * @param  {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n         * @returns {Object} The scope associated with statementType\n         */\n        function getCurrentScope(statementType) {\n            let currentScope;\n\n            if (statementType === \"var\") {\n                currentScope = functionStack[functionStack.length - 1];\n            } else if (statementType === \"let\") {\n                currentScope = blockStack[blockStack.length - 1].let;\n            } else if (statementType === \"const\") {\n                currentScope = blockStack[blockStack.length - 1].const;\n            }\n            return currentScope;\n        }\n\n        /**\n         * Counts the number of initialized and uninitialized declarations in a list of declarations\n         * @param {ASTNode[]} declarations List of declarations\n         * @returns {Object} Counts of 'uninitialized' and 'initialized' declarations\n         * @private\n         */\n        function countDeclarations(declarations) {\n            const counts = { uninitialized: 0, initialized: 0 };\n\n            for (let i = 0; i < declarations.length; i++) {\n                if (declarations[i].init === null) {\n                    counts.uninitialized++;\n                } else {\n                    counts.initialized++;\n                }\n            }\n            return counts;\n        }\n\n        /**\n         * Determines if there is more than one var statement in the current scope.\n         * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n         * @param {ASTNode[]} declarations List of declarations\n         * @returns {boolean} Returns true if it is the first var declaration, false if not.\n         * @private\n         */\n        function hasOnlyOneStatement(statementType, declarations) {\n\n            const declarationCounts = countDeclarations(declarations);\n            const currentOptions = options[statementType] || {};\n            const currentScope = getCurrentScope(statementType);\n\n            if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) {\n                if (currentScope.uninitialized || currentScope.initialized) {\n                    return false;\n                }\n            }\n\n            if (declarationCounts.uninitialized > 0) {\n                if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) {\n                    return false;\n                }\n            }\n            if (declarationCounts.initialized > 0) {\n                if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) {\n                    return false;\n                }\n            }\n            recordTypes(statementType, declarations, currentScope);\n            return true;\n        }\n\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: startFunction,\n            FunctionDeclaration: startFunction,\n            FunctionExpression: startFunction,\n            ArrowFunctionExpression: startFunction,\n            BlockStatement: startBlock,\n            ForStatement: startBlock,\n            ForInStatement: startBlock,\n            ForOfStatement: startBlock,\n            SwitchStatement: startBlock,\n\n            VariableDeclaration(node) {\n                const parent = node.parent;\n                const type = node.kind;\n\n                if (!options[type]) {\n                    return;\n                }\n\n                const declarations = node.declarations;\n                const declarationCounts = countDeclarations(declarations);\n\n                // always\n                if (!hasOnlyOneStatement(type, declarations)) {\n                    if (options[type].initialized === MODE_ALWAYS && options[type].uninitialized === MODE_ALWAYS) {\n                        context.report({\n                            node,\n                            message: \"Combine this with the previous '{{type}}' statement.\",\n                            data: {\n                                type\n                            }\n                        });\n                    } else {\n                        if (options[type].initialized === MODE_ALWAYS) {\n                            context.report({\n                                node,\n                                message: \"Combine this with the previous '{{type}}' statement with initialized variables.\",\n                                data: {\n                                    type\n                                }\n                            });\n                        }\n                        if (options[type].uninitialized === MODE_ALWAYS) {\n                            if (node.parent.left === node && (node.parent.type === \"ForInStatement\" || node.parent.type === \"ForOfStatement\")) {\n                                return;\n                            }\n                            context.report({\n                                node,\n                                message: \"Combine this with the previous '{{type}}' statement with uninitialized variables.\",\n                                data: {\n                                    type\n                                }\n                            });\n                        }\n                    }\n                }\n\n                // never\n                if (parent.type !== \"ForStatement\" || parent.init !== node) {\n                    const totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;\n\n                    if (totalDeclarations > 1) {\n\n                        if (options[type].initialized === MODE_NEVER && options[type].uninitialized === MODE_NEVER) {\n\n                            // both initialized and uninitialized\n                            context.report({\n                                node,\n                                message: \"Split '{{type}}' declarations into multiple statements.\",\n                                data: {\n                                    type\n                                }\n                            });\n                        } else if (options[type].initialized === MODE_NEVER && declarationCounts.initialized > 0) {\n\n                            // initialized\n                            context.report({\n                                node,\n                                message: \"Split initialized '{{type}}' declarations into multiple statements.\",\n                                data: {\n                                    type\n                                }\n                            });\n                        } else if (options[type].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) {\n\n                            // uninitialized\n                            context.report({\n                                node,\n                                message: \"Split uninitialized '{{type}}' declarations into multiple statements.\",\n                                data: {\n                                    type\n                                }\n                            });\n                        }\n                    }\n                }\n            },\n\n            \"ForStatement:exit\": endBlock,\n            \"ForOfStatement:exit\": endBlock,\n            \"ForInStatement:exit\": endBlock,\n            \"SwitchStatement:exit\": endBlock,\n            \"BlockStatement:exit\": endBlock,\n            \"Program:exit\": endFunction,\n            \"FunctionDeclaration:exit\": endFunction,\n            \"FunctionExpression:exit\": endFunction,\n            \"ArrowFunctionExpression:exit\": endFunction\n        };\n\n    }\n};\n","operator-assignment.js":"/**\n * @fileoverview Rule to replace assignment expressions with operator assignment\n * @author Brandon Mills\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether an operator is commutative and has an operator assignment\n * shorthand form.\n * @param   {string}  operator Operator to check.\n * @returns {boolean}          True if the operator is commutative and has a\n *     shorthand form.\n */\nfunction isCommutativeOperatorWithShorthand(operator) {\n    return [\"*\", \"&\", \"^\", \"|\"].indexOf(operator) >= 0;\n}\n\n/**\n * Checks whether an operator is not commuatative and has an operator assignment\n * shorthand form.\n * @param   {string}  operator Operator to check.\n * @returns {boolean}          True if the operator is not commuatative and has\n *     a shorthand form.\n */\nfunction isNonCommutativeOperatorWithShorthand(operator) {\n    return [\"+\", \"-\", \"/\", \"%\", \"<<\", \">>\", \">>>\", \"**\"].indexOf(operator) >= 0;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether two expressions reference the same value. For example:\n *     a = a\n *     a.b = a.b\n *     a[0] = a[0]\n *     a['b'] = a['b']\n * @param   {ASTNode} a Left side of the comparison.\n * @param   {ASTNode} b Right side of the comparison.\n * @returns {boolean}   True if both sides match and reference the same value.\n */\nfunction same(a, b) {\n    if (a.type !== b.type) {\n        return false;\n    }\n\n    switch (a.type) {\n        case \"Identifier\":\n            return a.name === b.name;\n\n        case \"Literal\":\n            return a.value === b.value;\n\n        case \"MemberExpression\":\n\n            /*\n             * x[0] = x[0]\n             * x[y] = x[y]\n             * x.y = x.y\n             */\n            return same(a.object, b.object) && same(a.property, b.property);\n\n        default:\n            return false;\n    }\n}\n\n/**\n* Determines if the left side of a node can be safely fixed (i.e. if it activates the same getters/setters and)\n* toString calls regardless of whether assignment shorthand is used)\n* @param {ASTNode} node The node on the left side of the expression\n* @returns {boolean} `true` if the node can be fixed\n*/\nfunction canBeFixed(node) {\n    return node.type === \"Identifier\" ||\n        node.type === \"MemberExpression\" && node.object.type === \"Identifier\" && (!node.computed || node.property.type === \"Literal\");\n}\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow assignment operator shorthand where possible\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n        * Returns the operator token of an AssignmentExpression or BinaryExpression\n        * @param {ASTNode} node An AssignmentExpression or BinaryExpression node\n        * @returns {Token} The operator token in the node\n        */\n        function getOperatorToken(node) {\n            return sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n        }\n\n        /**\n         * Ensures that an assignment uses the shorthand form where possible.\n         * @param   {ASTNode} node An AssignmentExpression node.\n         * @returns {void}\n         */\n        function verify(node) {\n            if (node.operator !== \"=\" || node.right.type !== \"BinaryExpression\") {\n                return;\n            }\n\n            const left = node.left;\n            const expr = node.right;\n            const operator = expr.operator;\n\n            if (isCommutativeOperatorWithShorthand(operator) || isNonCommutativeOperatorWithShorthand(operator)) {\n                if (same(left, expr.left)) {\n                    context.report({\n                        node,\n                        message: \"Assignment can be replaced with operator assignment.\",\n                        fix(fixer) {\n                            if (canBeFixed(left)) {\n                                const equalsToken = getOperatorToken(node);\n                                const operatorToken = getOperatorToken(expr);\n                                const leftText = sourceCode.getText().slice(node.range[0], equalsToken.range[0]);\n                                const rightText = sourceCode.getText().slice(operatorToken.range[1], node.right.range[1]);\n\n                                return fixer.replaceText(node, `${leftText}${expr.operator}=${rightText}`);\n                            }\n                            return null;\n                        }\n                    });\n                } else if (same(left, expr.right) && isCommutativeOperatorWithShorthand(operator)) {\n\n                    /*\n                     * This case can't be fixed safely.\n                     * If `a` and `b` both have custom valueOf() behavior, then fixing `a = b * a` to `a *= b` would\n                     * change the execution order of the valueOf() functions.\n                     */\n                    context.report({\n                        node,\n                        message: \"Assignment can be replaced with operator assignment.\"\n                    });\n                }\n            }\n        }\n\n        /**\n         * Warns if an assignment expression uses operator assignment shorthand.\n         * @param   {ASTNode} node An AssignmentExpression node.\n         * @returns {void}\n         */\n        function prohibit(node) {\n            if (node.operator !== \"=\") {\n                context.report({\n                    node,\n                    message: \"Unexpected operator assignment shorthand.\",\n                    fix(fixer) {\n                        if (canBeFixed(node.left)) {\n                            const operatorToken = getOperatorToken(node);\n                            const leftText = sourceCode.getText().slice(node.range[0], operatorToken.range[0]);\n                            const newOperator = node.operator.slice(0, -1);\n                            let rightText;\n\n                            // If this change would modify precedence (e.g. `foo *= bar + 1` => `foo = foo * (bar + 1)`), parenthesize the right side.\n                            if (\n                                astUtils.getPrecedence(node.right) <= astUtils.getPrecedence({ type: \"BinaryExpression\", operator: newOperator }) &&\n                                !astUtils.isParenthesised(sourceCode, node.right)\n                            ) {\n                                rightText = `${sourceCode.text.slice(operatorToken.range[1], node.right.range[0])}(${sourceCode.getText(node.right)})`;\n                            } else {\n                                rightText = sourceCode.text.slice(operatorToken.range[1], node.range[1]);\n                            }\n\n                            return fixer.replaceText(node, `${leftText}= ${leftText}${newOperator}${rightText}`);\n                        }\n                        return null;\n                    }\n                });\n            }\n        }\n\n        return {\n            AssignmentExpression: context.options[0] !== \"never\" ? verify : prohibit\n        };\n\n    }\n};\n","operator-linebreak.js":"/**\n * @fileoverview Operator linebreak - enforces operator linebreak style of two types: after and before\n * @author BenoÃ®t Zugmeyer\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent linebreak style for operators\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"after\", \"before\", \"none\", null]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    overrides: {\n                        type: \"object\",\n                        properties: {\n                            anyOf: {\n                                type: \"string\",\n                                enum: [\"after\", \"before\", \"none\", \"ignore\"]\n                            }\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        const usedDefaultGlobal = !context.options[0];\n        const globalStyle = context.options[0] || \"after\";\n        const options = context.options[1] || {};\n        const styleOverrides = options.overrides ? Object.assign({}, options.overrides) : {};\n\n        if (usedDefaultGlobal && !styleOverrides[\"?\"]) {\n            styleOverrides[\"?\"] = \"before\";\n        }\n\n        if (usedDefaultGlobal && !styleOverrides[\":\"]) {\n            styleOverrides[\":\"] = \"before\";\n        }\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n        * Gets a fixer function to fix rule issues\n        * @param {Token} operatorToken The operator token of an expression\n        * @param {string} desiredStyle The style for the rule. One of 'before', 'after', 'none'\n        * @returns {Function} A fixer function\n        */\n        function getFixer(operatorToken, desiredStyle) {\n            return fixer => {\n                const tokenBefore = sourceCode.getTokenBefore(operatorToken);\n                const tokenAfter = sourceCode.getTokenAfter(operatorToken);\n                const textBefore = sourceCode.text.slice(tokenBefore.range[1], operatorToken.range[0]);\n                const textAfter = sourceCode.text.slice(operatorToken.range[1], tokenAfter.range[0]);\n                const hasLinebreakBefore = !astUtils.isTokenOnSameLine(tokenBefore, operatorToken);\n                const hasLinebreakAfter = !astUtils.isTokenOnSameLine(operatorToken, tokenAfter);\n                let newTextBefore, newTextAfter;\n\n                if (hasLinebreakBefore !== hasLinebreakAfter && desiredStyle !== \"none\") {\n\n                    // If there is a comment before and after the operator, don't do a fix.\n                    if (sourceCode.getTokenBefore(operatorToken, { includeComments: true }) !== tokenBefore && sourceCode.getTokenAfter(operatorToken, { includeComments: true }) !== tokenAfter) {\n                        return null;\n                    }\n\n                    /*\n                     * If there is only one linebreak and it's on the wrong side of the operator, swap the text before and after the operator.\n                     * foo &&\n                     *           bar\n                     * would get fixed to\n                     * foo\n                     *        && bar\n                     */\n                    newTextBefore = textAfter;\n                    newTextAfter = textBefore;\n                } else {\n                    const LINEBREAK_REGEX = astUtils.createGlobalLinebreakMatcher();\n\n                    // Otherwise, if no linebreak is desired and no comments interfere, replace the linebreaks with empty strings.\n                    newTextBefore = desiredStyle === \"before\" || textBefore.trim() ? textBefore : textBefore.replace(LINEBREAK_REGEX, \"\");\n                    newTextAfter = desiredStyle === \"after\" || textAfter.trim() ? textAfter : textAfter.replace(LINEBREAK_REGEX, \"\");\n\n                    // If there was no change (due to interfering comments), don't output a fix.\n                    if (newTextBefore === textBefore && newTextAfter === textAfter) {\n                        return null;\n                    }\n                }\n\n                if (newTextAfter === \"\" && tokenAfter.type === \"Punctuator\" && \"+-\".includes(operatorToken.value) && tokenAfter.value === operatorToken.value) {\n\n                    // To avoid accidentally creating a ++ or -- operator, insert a space if the operator is a +/- and the following token is a unary +/-.\n                    newTextAfter += \" \";\n                }\n\n                return fixer.replaceTextRange([tokenBefore.range[1], tokenAfter.range[0]], newTextBefore + operatorToken.value + newTextAfter);\n            };\n        }\n\n        /**\n         * Checks the operator placement\n         * @param {ASTNode} node The node to check\n         * @param {ASTNode} leftSide The node that comes before the operator in `node`\n         * @private\n         * @returns {void}\n         */\n        function validateNode(node, leftSide) {\n\n            // When the left part of a binary expression is a single expression wrapped in\n            // parentheses (ex: `(a) + b`), leftToken will be the last token of the expression\n            // and operatorToken will be the closing parenthesis.\n            // The leftToken should be the last closing parenthesis, and the operatorToken\n            // should be the token right after that.\n            const operatorToken = sourceCode.getTokenAfter(leftSide, astUtils.isNotClosingParenToken);\n            const leftToken = sourceCode.getTokenBefore(operatorToken);\n            const rightToken = sourceCode.getTokenAfter(operatorToken);\n            const operator = operatorToken.value;\n            const operatorStyleOverride = styleOverrides[operator];\n            const style = operatorStyleOverride || globalStyle;\n            const fix = getFixer(operatorToken, style);\n\n            // if single line\n            if (astUtils.isTokenOnSameLine(leftToken, operatorToken) &&\n                    astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n                // do nothing.\n\n            } else if (operatorStyleOverride !== \"ignore\" && !astUtils.isTokenOnSameLine(leftToken, operatorToken) &&\n                    !astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n                // lone operator\n                context.report({\n                    node,\n                    loc: {\n                        line: operatorToken.loc.end.line,\n                        column: operatorToken.loc.end.column\n                    },\n                    message: \"Bad line breaking before and after '{{operator}}'.\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            } else if (style === \"before\" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) {\n\n                context.report({\n                    node,\n                    loc: {\n                        line: operatorToken.loc.end.line,\n                        column: operatorToken.loc.end.column\n                    },\n                    message: \"'{{operator}}' should be placed at the beginning of the line.\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            } else if (style === \"after\" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n                context.report({\n                    node,\n                    loc: {\n                        line: operatorToken.loc.end.line,\n                        column: operatorToken.loc.end.column\n                    },\n                    message: \"'{{operator}}' should be placed at the end of the line.\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            } else if (style === \"none\") {\n\n                context.report({\n                    node,\n                    loc: {\n                        line: operatorToken.loc.end.line,\n                        column: operatorToken.loc.end.column\n                    },\n                    message: \"There should be no line break before or after '{{operator}}'.\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            }\n        }\n\n        /**\n         * Validates a binary expression using `validateNode`\n         * @param {BinaryExpression|LogicalExpression|AssignmentExpression} node node to be validated\n         * @returns {void}\n         */\n        function validateBinaryExpression(node) {\n            validateNode(node, node.left);\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            BinaryExpression: validateBinaryExpression,\n            LogicalExpression: validateBinaryExpression,\n            AssignmentExpression: validateBinaryExpression,\n            VariableDeclarator(node) {\n                if (node.init) {\n                    validateNode(node, node.id);\n                }\n            },\n            ConditionalExpression(node) {\n                validateNode(node, node.test);\n                validateNode(node, node.consequent);\n            }\n        };\n    }\n};\n","padded-blocks.js":"/**\n * @fileoverview A rule to ensure blank lines within blocks.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow padding within blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            blocks: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            switches: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            classes: {\n                                enum: [\"always\", \"never\"]\n                            }\n                        },\n                        additionalProperties: false,\n                        minProperties: 1\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const options = {};\n        const config = context.options[0] || \"always\";\n\n        if (typeof config === \"string\") {\n            const shouldHavePadding = config === \"always\";\n\n            options.blocks = shouldHavePadding;\n            options.switches = shouldHavePadding;\n            options.classes = shouldHavePadding;\n        } else {\n            if (config.hasOwnProperty(\"blocks\")) {\n                options.blocks = config.blocks === \"always\";\n            }\n            if (config.hasOwnProperty(\"switches\")) {\n                options.switches = config.switches === \"always\";\n            }\n            if (config.hasOwnProperty(\"classes\")) {\n                options.classes = config.classes === \"always\";\n            }\n        }\n\n        const ALWAYS_MESSAGE = \"Block must be padded by blank lines.\",\n            NEVER_MESSAGE = \"Block must not be padded by blank lines.\";\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Gets the open brace token from a given node.\n         * @param {ASTNode} node - A BlockStatement or SwitchStatement node from which to get the open brace.\n         * @returns {Token} The token of the open brace.\n         */\n        function getOpenBrace(node) {\n            if (node.type === \"SwitchStatement\") {\n                return sourceCode.getTokenBefore(node.cases[0]);\n            }\n            return sourceCode.getFirstToken(node);\n        }\n\n        /**\n         * Checks if the given parameter is a comment node\n         * @param {ASTNode|Token} node An AST node or token\n         * @returns {boolean} True if node is a comment\n         */\n        function isComment(node) {\n            return node.type === \"Line\" || node.type === \"Block\";\n        }\n\n        /**\n         * Checks if there is padding between two tokens\n         * @param {Token} first The first token\n         * @param {Token} second The second token\n         * @returns {boolean} True if there is at least a line between the tokens\n         */\n        function isPaddingBetweenTokens(first, second) {\n            return second.loc.start.line - first.loc.end.line >= 2;\n        }\n\n\n        /**\n         * Checks if the given token has a blank line after it.\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the token is followed by a blank line.\n         */\n        function getFirstBlockToken(token) {\n            let prev,\n                first = token;\n\n            do {\n                prev = first;\n                first = sourceCode.getTokenAfter(first, { includeComments: true });\n            } while (isComment(first) && first.loc.start.line === prev.loc.end.line);\n\n            return first;\n        }\n\n        /**\n         * Checks if the given token is preceeded by a blank line.\n         * @param {Token} token The token to check\n         * @returns {boolean} Whether or not the token is preceeded by a blank line\n         */\n        function getLastBlockToken(token) {\n            let last = token,\n                next;\n\n            do {\n                next = last;\n                last = sourceCode.getTokenBefore(last, { includeComments: true });\n            } while (isComment(last) && last.loc.end.line === next.loc.start.line);\n\n            return last;\n        }\n\n        /**\n         * Checks if a node should be padded, according to the rule config.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {boolean} True if the node should be padded, false otherwise.\n         */\n        function requirePaddingFor(node) {\n            switch (node.type) {\n                case \"BlockStatement\":\n                    return options.blocks;\n                case \"SwitchStatement\":\n                    return options.switches;\n                case \"ClassBody\":\n                    return options.classes;\n\n                /* istanbul ignore next */\n                default:\n                    throw new Error(\"unreachable\");\n            }\n        }\n\n        /**\n         * Checks the given BlockStatement node to be padded if the block is not empty.\n         * @param {ASTNode} node The AST node of a BlockStatement.\n         * @returns {void} undefined.\n         */\n        function checkPadding(node) {\n            const openBrace = getOpenBrace(node),\n                firstBlockToken = getFirstBlockToken(openBrace),\n                tokenBeforeFirst = sourceCode.getTokenBefore(firstBlockToken, { includeComments: true }),\n                closeBrace = sourceCode.getLastToken(node),\n                lastBlockToken = getLastBlockToken(closeBrace),\n                tokenAfterLast = sourceCode.getTokenAfter(lastBlockToken, { includeComments: true }),\n                blockHasTopPadding = isPaddingBetweenTokens(tokenBeforeFirst, firstBlockToken),\n                blockHasBottomPadding = isPaddingBetweenTokens(lastBlockToken, tokenAfterLast);\n\n            if (requirePaddingFor(node)) {\n                if (!blockHasTopPadding) {\n                    context.report({\n                        node,\n                        loc: { line: tokenBeforeFirst.loc.start.line, column: tokenBeforeFirst.loc.start.column },\n                        fix(fixer) {\n                            return fixer.insertTextAfter(tokenBeforeFirst, \"\\n\");\n                        },\n                        message: ALWAYS_MESSAGE\n                    });\n                }\n                if (!blockHasBottomPadding) {\n                    context.report({\n                        node,\n                        loc: { line: tokenAfterLast.loc.end.line, column: tokenAfterLast.loc.end.column - 1 },\n                        fix(fixer) {\n                            return fixer.insertTextBefore(tokenAfterLast, \"\\n\");\n                        },\n                        message: ALWAYS_MESSAGE\n                    });\n                }\n            } else {\n                if (blockHasTopPadding) {\n\n                    context.report({\n                        node,\n                        loc: { line: tokenBeforeFirst.loc.start.line, column: tokenBeforeFirst.loc.start.column },\n                        fix(fixer) {\n                            return fixer.replaceTextRange([tokenBeforeFirst.range[1], firstBlockToken.range[0] - firstBlockToken.loc.start.column], \"\\n\");\n                        },\n                        message: NEVER_MESSAGE\n                    });\n                }\n\n                if (blockHasBottomPadding) {\n\n                    context.report({\n                        node,\n                        loc: { line: tokenAfterLast.loc.end.line, column: tokenAfterLast.loc.end.column - 1 },\n                        message: NEVER_MESSAGE,\n                        fix(fixer) {\n                            return fixer.replaceTextRange([lastBlockToken.range[1], tokenAfterLast.range[0] - tokenAfterLast.loc.start.column], \"\\n\");\n                        }\n                    });\n                }\n            }\n        }\n\n        const rule = {};\n\n        if (options.hasOwnProperty(\"switches\")) {\n            rule.SwitchStatement = function(node) {\n                if (node.cases.length === 0) {\n                    return;\n                }\n                checkPadding(node);\n            };\n        }\n\n        if (options.hasOwnProperty(\"blocks\")) {\n            rule.BlockStatement = function(node) {\n                if (node.body.length === 0) {\n                    return;\n                }\n                checkPadding(node);\n            };\n        }\n\n        if (options.hasOwnProperty(\"classes\")) {\n            rule.ClassBody = function(node) {\n                if (node.body.length === 0) {\n                    return;\n                }\n                checkPadding(node);\n            };\n        }\n\n        return rule;\n    }\n};\n","padding-line-between-statements.js":"/**\n * @fileoverview Rule to require or disallow newlines between statements\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst LT = `[${Array.from(astUtils.LINEBREAKS).join(\"\")}]`;\nconst PADDING_LINE_SEQUENCE = new RegExp(\n    String.raw`^(\\s*?${LT})\\s*${LT}(\\s*;?)$`\n);\nconst CJS_EXPORT = /^(?:module\\s*\\.\\s*)?exports(?:\\s*\\.|\\s*\\[|$)/;\nconst CJS_IMPORT = /^require\\(/;\n\n/**\n * Creates tester which check if a node starts with specific keyword.\n *\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newKeywordTester(keyword) {\n    return {\n        test: (node, sourceCode) =>\n            sourceCode.getFirstToken(node).value === keyword\n    };\n}\n\n/**\n * Creates tester which check if a node is specific type.\n *\n * @param {string} type The node type to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newNodeTypeTester(type) {\n    return {\n        test: node =>\n            node.type === type\n    };\n}\n\n/**\n * Checks the given node is an expression statement of IIFE.\n *\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is an expression statement of IIFE.\n * @private\n */\nfunction isIIFEStatement(node) {\n    if (node.type === \"ExpressionStatement\") {\n        let call = node.expression;\n\n        if (call.type === \"UnaryExpression\") {\n            call = call.argument;\n        }\n        return call.type === \"CallExpression\" && astUtils.isFunction(call.callee);\n    }\n    return false;\n}\n\n/**\n * Checks whether the given node is a block-like statement.\n * This checks the last token of the node is the closing brace of a block.\n *\n * @param {SourceCode} sourceCode The source code to get tokens.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a block-like statement.\n * @private\n */\nfunction isBlockLikeStatement(sourceCode, node) {\n\n    // do-while with a block is a block-like statement.\n    if (node.type === \"DoWhileStatement\" && node.body.type === \"BlockStatement\") {\n        return true;\n    }\n\n    // IIFE is a block-like statement specially from\n    // JSCS#disallowPaddingNewLinesAfterBlocks.\n    if (isIIFEStatement(node)) {\n        return true;\n    }\n\n    // Checks the last token is a closing brace of blocks.\n    const lastToken = sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);\n    const belongingNode = lastToken && astUtils.isClosingBraceToken(lastToken)\n        ? sourceCode.getNodeByRangeIndex(lastToken.range[0])\n        : null;\n\n    return Boolean(belongingNode) && (\n        belongingNode.type === \"BlockStatement\" ||\n        belongingNode.type === \"SwitchStatement\"\n    );\n}\n\n/**\n * Check whether the given node is a directive or not.\n * @param {ASTNode} node The node to check.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {boolean} `true` if the node is a directive.\n */\nfunction isDirective(node, sourceCode) {\n    return (\n        node.type === \"ExpressionStatement\" &&\n        (\n            node.parent.type === \"Program\" ||\n            (\n                node.parent.type === \"BlockStatement\" &&\n                astUtils.isFunction(node.parent.parent)\n            )\n        ) &&\n        node.expression.type === \"Literal\" &&\n        typeof node.expression.value === \"string\" &&\n        !astUtils.isParenthesised(sourceCode, node.expression)\n    );\n}\n\n/**\n * Check whether the given node is a part of directive prologue or not.\n * @param {ASTNode} node The node to check.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {boolean} `true` if the node is a part of directive prologue.\n */\nfunction isDirectivePrologue(node, sourceCode) {\n    if (isDirective(node, sourceCode)) {\n        for (const sibling of node.parent.body) {\n            if (sibling === node) {\n                break;\n            }\n            if (!isDirective(sibling, sourceCode)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\n\n/**\n * Gets the actual last token.\n *\n * If a semicolon is semicolon-less style's semicolon, this ignores it.\n * For example:\n *\n *     foo()\n *     ;[1, 2, 3].forEach(bar)\n *\n * @param {SourceCode} sourceCode The source code to get tokens.\n * @param {ASTNode} node The node to get.\n * @returns {Token} The actual last token.\n * @private\n */\nfunction getActualLastToken(sourceCode, node) {\n    const semiToken = sourceCode.getLastToken(node);\n    const prevToken = sourceCode.getTokenBefore(semiToken);\n    const nextToken = sourceCode.getTokenAfter(semiToken);\n    const isSemicolonLessStyle = Boolean(\n        prevToken &&\n        nextToken &&\n        prevToken.range[0] >= node.range[0] &&\n        astUtils.isSemicolonToken(semiToken) &&\n        semiToken.loc.start.line !== prevToken.loc.end.line &&\n        semiToken.loc.end.line === nextToken.loc.start.line\n    );\n\n    return isSemicolonLessStyle ? prevToken : semiToken;\n}\n\n/**\n * This returns the concatenation of the first 2 captured strings.\n * @param {string} _ Unused. Whole matched string.\n * @param {string} trailingSpaces The trailing spaces of the first line.\n * @param {string} indentSpaces The indentation spaces of the last line.\n * @returns {string} The concatenation of trailingSpaces and indentSpaces.\n * @private\n */\nfunction replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) {\n    return trailingSpaces + indentSpaces;\n}\n\n/**\n * Check and report statements for `any` configuration.\n * It does nothing.\n *\n * @returns {void}\n * @private\n */\nfunction verifyForAny() {\n}\n\n/**\n * Check and report statements for `never` configuration.\n * This autofix removes blank lines between the given 2 statements.\n * However, if comments exist between 2 blank lines, it does not remove those\n * blank lines automatically.\n *\n * @param {RuleContext} context The rule context to report.\n * @param {ASTNode} _ Unused. The previous node to check.\n * @param {ASTNode} nextNode The next node to check.\n * @param {Array<Token[]>} paddingLines The array of token pairs that blank\n * lines exist between the pair.\n * @returns {void}\n * @private\n */\nfunction verifyForNever(context, _, nextNode, paddingLines) {\n    if (paddingLines.length === 0) {\n        return;\n    }\n\n    context.report({\n        node: nextNode,\n        message: \"Unexpected blank line before this statement.\",\n        fix(fixer) {\n            if (paddingLines.length >= 2) {\n                return null;\n            }\n\n            const prevToken = paddingLines[0][0];\n            const nextToken = paddingLines[0][1];\n            const start = prevToken.range[1];\n            const end = nextToken.range[0];\n            const text = context.getSourceCode().text\n                .slice(start, end)\n                .replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);\n\n            return fixer.replaceTextRange([start, end], text);\n        }\n    });\n}\n\n/**\n * Check and report statements for `always` configuration.\n * This autofix inserts a blank line between the given 2 statements.\n * If the `prevNode` has trailing comments, it inserts a blank line after the\n * trailing comments.\n *\n * @param {RuleContext} context The rule context to report.\n * @param {ASTNode} prevNode The previous node to check.\n * @param {ASTNode} nextNode The next node to check.\n * @param {Array<Token[]>} paddingLines The array of token pairs that blank\n * lines exist between the pair.\n * @returns {void}\n * @private\n */\nfunction verifyForAlways(context, prevNode, nextNode, paddingLines) {\n    if (paddingLines.length > 0) {\n        return;\n    }\n\n    context.report({\n        node: nextNode,\n        message: \"Expected blank line before this statement.\",\n        fix(fixer) {\n            const sourceCode = context.getSourceCode();\n            let prevToken = getActualLastToken(sourceCode, prevNode);\n            const nextToken = sourceCode.getFirstTokenBetween(\n                prevToken,\n                nextNode,\n                {\n                    includeComments: true,\n\n                    /**\n                     * Skip the trailing comments of the previous node.\n                     * This inserts a blank line after the last trailing comment.\n                     *\n                     * For example:\n                     *\n                     *     foo(); // trailing comment.\n                     *     // comment.\n                     *     bar();\n                     *\n                     * Get fixed to:\n                     *\n                     *     foo(); // trailing comment.\n                     *\n                     *     // comment.\n                     *     bar();\n                     *\n                     * @param {Token} token The token to check.\n                     * @returns {boolean} `true` if the token is not a trailing comment.\n                     * @private\n                     */\n                    filter(token) {\n                        if (astUtils.isTokenOnSameLine(prevToken, token)) {\n                            prevToken = token;\n                            return false;\n                        }\n                        return true;\n                    }\n                }\n            ) || nextNode;\n            const insertText = astUtils.isTokenOnSameLine(prevToken, nextToken)\n                ? \"\\n\\n\"\n                : \"\\n\";\n\n            return fixer.insertTextAfter(prevToken, insertText);\n        }\n    });\n}\n\n/**\n * Types of blank lines.\n * `any`, `never`, and `always` are defined.\n * Those have `verify` method to check and report statements.\n * @private\n */\nconst PaddingTypes = {\n    any: { verify: verifyForAny },\n    never: { verify: verifyForNever },\n    always: { verify: verifyForAlways }\n};\n\n/**\n * Types of statements.\n * Those have `test` method to check it matches to the given statement.\n * @private\n */\nconst StatementTypes = {\n    \"*\": { test: () => true },\n    \"block-like\": {\n        test: (node, sourceCode) => isBlockLikeStatement(sourceCode, node)\n    },\n    \"cjs-export\": {\n        test: (node, sourceCode) =>\n            node.type === \"ExpressionStatement\" &&\n            node.expression.type === \"AssignmentExpression\" &&\n            CJS_EXPORT.test(sourceCode.getText(node.expression.left))\n    },\n    \"cjs-import\": {\n        test: (node, sourceCode) =>\n            node.type === \"VariableDeclaration\" &&\n            node.declarations.length > 0 &&\n            Boolean(node.declarations[0].init) &&\n            CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init))\n    },\n    directive: {\n        test: isDirectivePrologue\n    },\n    expression: {\n        test: (node, sourceCode) =>\n            node.type === \"ExpressionStatement\" &&\n            !isDirectivePrologue(node, sourceCode)\n    },\n    \"multiline-block-like\": {\n        test: (node, sourceCode) =>\n            node.loc.start.line !== node.loc.end.line &&\n            isBlockLikeStatement(sourceCode, node)\n    },\n\n    block: newNodeTypeTester(\"BlockStatement\"),\n    empty: newNodeTypeTester(\"EmptyStatement\"),\n\n    break: newKeywordTester(\"break\"),\n    case: newKeywordTester(\"case\"),\n    class: newKeywordTester(\"class\"),\n    const: newKeywordTester(\"const\"),\n    continue: newKeywordTester(\"continue\"),\n    debugger: newKeywordTester(\"debugger\"),\n    default: newKeywordTester(\"default\"),\n    do: newKeywordTester(\"do\"),\n    export: newKeywordTester(\"export\"),\n    for: newKeywordTester(\"for\"),\n    function: newKeywordTester(\"function\"),\n    if: newKeywordTester(\"if\"),\n    import: newKeywordTester(\"import\"),\n    let: newKeywordTester(\"let\"),\n    return: newKeywordTester(\"return\"),\n    switch: newKeywordTester(\"switch\"),\n    throw: newKeywordTester(\"throw\"),\n    try: newKeywordTester(\"try\"),\n    var: newKeywordTester(\"var\"),\n    while: newKeywordTester(\"while\"),\n    with: newKeywordTester(\"with\")\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow padding lines between statements\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        fixable: \"whitespace\",\n        schema: {\n            definitions: {\n                paddingType: {\n                    enum: Object.keys(PaddingTypes)\n                },\n                statementType: {\n                    anyOf: [\n                        { enum: Object.keys(StatementTypes) },\n                        {\n                            type: \"array\",\n                            items: { enum: Object.keys(StatementTypes) },\n                            minItems: 1,\n                            uniqueItems: true,\n                            additionalItems: false\n                        }\n                    ]\n                }\n            },\n            type: \"array\",\n            items: {\n                type: \"object\",\n                properties: {\n                    blankLine: { $ref: \"#/definitions/paddingType\" },\n                    prev: { $ref: \"#/definitions/statementType\" },\n                    next: { $ref: \"#/definitions/statementType\" }\n                },\n                additionalProperties: false,\n                required: [\"blankLine\", \"prev\", \"next\"]\n            },\n            additionalItems: false\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const configureList = context.options || [];\n        let scopeInfo = null;\n\n        /**\n         * Processes to enter to new scope.\n         * This manages the current previous statement.\n         * @returns {void}\n         * @private\n         */\n        function enterScope() {\n            scopeInfo = {\n                upper: scopeInfo,\n                prevNode: null\n            };\n        }\n\n        /**\n         * Processes to exit from the current scope.\n         * @returns {void}\n         * @private\n         */\n        function exitScope() {\n            scopeInfo = scopeInfo.upper;\n        }\n\n        /**\n         * Checks whether the given node matches the given type.\n         *\n         * @param {ASTNode} node The statement node to check.\n         * @param {string|string[]} type The statement type to check.\n         * @returns {boolean} `true` if the statement node matched the type.\n         * @private\n         */\n        function match(node, type) {\n            while (node.type === \"LabeledStatement\") {\n                node = node.body;\n            }\n            if (Array.isArray(type)) {\n                return type.some(match.bind(null, node));\n            }\n            return StatementTypes[type].test(node, sourceCode);\n        }\n\n        /**\n         * Finds the last matched configure from configureList.\n         *\n         * @param {ASTNode} prevNode The previous statement to match.\n         * @param {ASTNode} nextNode The current statement to match.\n         * @returns {Object} The tester of the last matched configure.\n         * @private\n         */\n        function getPaddingType(prevNode, nextNode) {\n            for (let i = configureList.length - 1; i >= 0; --i) {\n                const configure = configureList[i];\n                const matched =\n                    match(prevNode, configure.prev) &&\n                    match(nextNode, configure.next);\n\n                if (matched) {\n                    return PaddingTypes[configure.blankLine];\n                }\n            }\n            return PaddingTypes.any;\n        }\n\n        /**\n         * Gets padding line sequences between the given 2 statements.\n         * Comments are separators of the padding line sequences.\n         *\n         * @param {ASTNode} prevNode The previous statement to count.\n         * @param {ASTNode} nextNode The current statement to count.\n         * @returns {Array<Token[]>} The array of token pairs.\n         * @private\n         */\n        function getPaddingLineSequences(prevNode, nextNode) {\n            const pairs = [];\n            let prevToken = getActualLastToken(sourceCode, prevNode);\n\n            if (nextNode.loc.start.line - prevToken.loc.end.line >= 2) {\n                do {\n                    const token = sourceCode.getTokenAfter(\n                        prevToken,\n                        { includeComments: true }\n                    );\n\n                    if (token.loc.start.line - prevToken.loc.end.line >= 2) {\n                        pairs.push([prevToken, token]);\n                    }\n                    prevToken = token;\n\n                } while (prevToken.range[0] < nextNode.range[0]);\n            }\n\n            return pairs;\n        }\n\n        /**\n         * Verify padding lines between the given node and the previous node.\n         *\n         * @param {ASTNode} node The node to verify.\n         * @returns {void}\n         * @private\n         */\n        function verify(node) {\n            const parentType = node.parent.type;\n            const validParent =\n                astUtils.STATEMENT_LIST_PARENTS.has(parentType) ||\n                parentType === \"SwitchStatement\";\n\n            if (!validParent) {\n                return;\n            }\n\n            // Save this node as the current previous statement.\n            const prevNode = scopeInfo.prevNode;\n\n            // Verify.\n            if (prevNode) {\n                const type = getPaddingType(prevNode, node);\n                const paddingLines = getPaddingLineSequences(prevNode, node);\n\n                type.verify(context, prevNode, node, paddingLines);\n            }\n\n            scopeInfo.prevNode = node;\n        }\n\n        /**\n         * Verify padding lines between the given node and the previous node.\n         * Then process to enter to new scope.\n         *\n         * @param {ASTNode} node The node to verify.\n         * @returns {void}\n         * @private\n         */\n        function verifyThenEnterScope(node) {\n            verify(node);\n            enterScope();\n        }\n\n        return {\n            Program: enterScope,\n            BlockStatement: enterScope,\n            SwitchStatement: enterScope,\n            \"Program:exit\": exitScope,\n            \"BlockStatement:exit\": exitScope,\n            \"SwitchStatement:exit\": exitScope,\n\n            \":statement\": verify,\n\n            SwitchCase: verifyThenEnterScope,\n            \"SwitchCase:exit\": exitScope\n        };\n    }\n};\n","prefer-arrow-callback.js":"/**\n * @fileoverview A rule to suggest using arrow functions as callbacks.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given variable is a function name.\n * @param {eslint-scope.Variable} variable - A variable to check.\n * @returns {boolean} `true` if the variable is a function name.\n */\nfunction isFunctionName(variable) {\n    return variable && variable.defs[0].type === \"FunctionName\";\n}\n\n/**\n * Checks whether or not a given MetaProperty node equals to a given value.\n * @param {ASTNode} node - A MetaProperty node to check.\n * @param {string} metaName - The name of `MetaProperty.meta`.\n * @param {string} propertyName - The name of `MetaProperty.property`.\n * @returns {boolean} `true` if the node is the specific value.\n */\nfunction checkMetaProperty(node, metaName, propertyName) {\n    return node.meta.name === metaName && node.property.name === propertyName;\n}\n\n/**\n * Gets the variable object of `arguments` which is defined implicitly.\n * @param {eslint-scope.Scope} scope - A scope to get.\n * @returns {eslint-scope.Variable} The found variable object.\n */\nfunction getVariableOfArguments(scope) {\n    const variables = scope.variables;\n\n    for (let i = 0; i < variables.length; ++i) {\n        const variable = variables[i];\n\n        if (variable.name === \"arguments\") {\n\n            /*\n             * If there was a parameter which is named \"arguments\", the\n             * implicit \"arguments\" is not defined.\n             * So does fast return with null.\n             */\n            return (variable.identifiers.length === 0) ? variable : null;\n        }\n    }\n\n    /* istanbul ignore next */\n    return null;\n}\n\n/**\n * Checkes whether or not a given node is a callback.\n * @param {ASTNode} node - A node to check.\n * @returns {Object}\n *   {boolean} retv.isCallback - `true` if the node is a callback.\n *   {boolean} retv.isLexicalThis - `true` if the node is with `.bind(this)`.\n */\nfunction getCallbackInfo(node) {\n    const retv = { isCallback: false, isLexicalThis: false };\n    let parent = node.parent;\n\n    while (node) {\n        switch (parent.type) {\n\n            // Checks parents recursively.\n\n            case \"LogicalExpression\":\n            case \"ConditionalExpression\":\n                break;\n\n            // Checks whether the parent node is `.bind(this)` call.\n            case \"MemberExpression\":\n                if (parent.object === node &&\n                    !parent.property.computed &&\n                    parent.property.type === \"Identifier\" &&\n                    parent.property.name === \"bind\" &&\n                    parent.parent.type === \"CallExpression\" &&\n                    parent.parent.callee === parent\n                ) {\n                    retv.isLexicalThis = (\n                        parent.parent.arguments.length === 1 &&\n                        parent.parent.arguments[0].type === \"ThisExpression\"\n                    );\n                    parent = parent.parent;\n                } else {\n                    return retv;\n                }\n                break;\n\n            // Checks whether the node is a callback.\n            case \"CallExpression\":\n            case \"NewExpression\":\n                if (parent.callee !== node) {\n                    retv.isCallback = true;\n                }\n                return retv;\n\n            default:\n                return retv;\n        }\n\n        node = parent;\n        parent = parent.parent;\n    }\n\n    /* istanbul ignore next */\n    throw new Error(\"unreachable\");\n}\n\n/**\n* Checks whether a simple list of parameters contains any duplicates. This does not handle complex\nparameter lists (e.g. with destructuring), since complex parameter lists are a SyntaxError with duplicate\nparameter names anyway. Instead, it always returns `false` for complex parameter lists.\n* @param {ASTNode[]} paramsList The list of parameters for a function\n* @returns {boolean} `true` if the list of parameters contains any duplicates\n*/\nfunction hasDuplicateParams(paramsList) {\n    return paramsList.every(param => param.type === \"Identifier\") && paramsList.length !== new Set(paramsList.map(param => param.name)).size;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require using arrow functions for callbacks\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowNamedFunctions: {\n                        type: \"boolean\"\n                    },\n                    allowUnboundThis: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n\n        const allowUnboundThis = options.allowUnboundThis !== false; // default to true\n        const allowNamedFunctions = options.allowNamedFunctions;\n        const sourceCode = context.getSourceCode();\n\n        /*\n         * {Array<{this: boolean, super: boolean, meta: boolean}>}\n         * - this - A flag which shows there are one or more ThisExpression.\n         * - super - A flag which shows there are one or more Super.\n         * - meta - A flag which shows there are one or more MethProperty.\n         */\n        let stack = [];\n\n        /**\n         * Pushes new function scope with all `false` flags.\n         * @returns {void}\n         */\n        function enterScope() {\n            stack.push({ this: false, super: false, meta: false });\n        }\n\n        /**\n         * Pops a function scope from the stack.\n         * @returns {{this: boolean, super: boolean, meta: boolean}} The information of the last scope.\n         */\n        function exitScope() {\n            return stack.pop();\n        }\n\n        return {\n\n            // Reset internal state.\n            Program() {\n                stack = [];\n            },\n\n            // If there are below, it cannot replace with arrow functions merely.\n            ThisExpression() {\n                const info = stack[stack.length - 1];\n\n                if (info) {\n                    info.this = true;\n                }\n            },\n\n            Super() {\n                const info = stack[stack.length - 1];\n\n                if (info) {\n                    info.super = true;\n                }\n            },\n\n            MetaProperty(node) {\n                const info = stack[stack.length - 1];\n\n                if (info && checkMetaProperty(node, \"new\", \"target\")) {\n                    info.meta = true;\n                }\n            },\n\n            // To skip nested scopes.\n            FunctionDeclaration: enterScope,\n            \"FunctionDeclaration:exit\": exitScope,\n\n            // Main.\n            FunctionExpression: enterScope,\n            \"FunctionExpression:exit\"(node) {\n                const scopeInfo = exitScope();\n\n                // Skip named function expressions\n                if (allowNamedFunctions && node.id && node.id.name) {\n                    return;\n                }\n\n                // Skip generators.\n                if (node.generator) {\n                    return;\n                }\n\n                // Skip recursive functions.\n                const nameVar = context.getDeclaredVariables(node)[0];\n\n                if (isFunctionName(nameVar) && nameVar.references.length > 0) {\n                    return;\n                }\n\n                // Skip if it's using arguments.\n                const variable = getVariableOfArguments(context.getScope());\n\n                if (variable && variable.references.length > 0) {\n                    return;\n                }\n\n                // Reports if it's a callback which can replace with arrows.\n                const callbackInfo = getCallbackInfo(node);\n\n                if (callbackInfo.isCallback &&\n                    (!allowUnboundThis || !scopeInfo.this || callbackInfo.isLexicalThis) &&\n                    !scopeInfo.super &&\n                    !scopeInfo.meta\n                ) {\n                    context.report({\n                        node,\n                        message: \"Unexpected function expression.\",\n                        fix(fixer) {\n                            if ((!callbackInfo.isLexicalThis && scopeInfo.this) || hasDuplicateParams(node.params)) {\n\n                                // If the callback function does not have .bind(this) and contains a reference to `this`, there\n                                // is no way to determine what `this` should be, so don't perform any fixes.\n                                // If the callback function has duplicates in its list of parameters (possible in sloppy mode),\n                                // don't replace it with an arrow function, because this is a SyntaxError with arrow functions.\n                                return null;\n                            }\n\n                            const paramsLeftParen = node.params.length ? sourceCode.getTokenBefore(node.params[0]) : sourceCode.getTokenBefore(node.body, 1);\n                            const paramsRightParen = sourceCode.getTokenBefore(node.body);\n                            const asyncKeyword = node.async ? \"async \" : \"\";\n                            const paramsFullText = sourceCode.text.slice(paramsLeftParen.range[0], paramsRightParen.range[1]);\n                            const arrowFunctionText = `${asyncKeyword}${paramsFullText} => ${sourceCode.getText(node.body)}`;\n\n                            /*\n                             * If the callback function has `.bind(this)`, replace it with an arrow function and remove the binding.\n                             * Otherwise, just replace the arrow function itself.\n                             */\n                            const replacedNode = callbackInfo.isLexicalThis ? node.parent.parent : node;\n\n                            /*\n                             * If the replaced node is part of a BinaryExpression, LogicalExpression, or MemberExpression, then\n                             * the arrow function needs to be parenthesized, because `foo || () => {}` is invalid syntax even\n                             * though `foo || function() {}` is valid.\n                             */\n                            const needsParens = replacedNode.parent.type !== \"CallExpression\" && replacedNode.parent.type !== \"ConditionalExpression\";\n                            const replacementText = needsParens ? `(${arrowFunctionText})` : arrowFunctionText;\n\n                            return fixer.replaceText(replacedNode, replacementText);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","prefer-const.js":"/**\n * @fileoverview A rule to suggest using of const declaration for variables that are never reassigned after declared.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst PATTERN_TYPE = /^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/;\nconst DECLARATION_HOST_TYPE = /^(?:Program|BlockStatement|SwitchCase)$/;\nconst DESTRUCTURING_HOST_TYPE = /^(?:VariableDeclarator|AssignmentExpression)$/;\n\n/**\n * Adds multiple items to the tail of an array.\n *\n * @param {any[]} array - A destination to add.\n * @param {any[]} values - Items to be added.\n * @returns {void}\n */\nconst pushAll = Function.apply.bind(Array.prototype.push);\n\n/**\n * Checks whether a given node is located at `ForStatement.init` or not.\n *\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is located at `ForStatement.init`.\n */\nfunction isInitOfForStatement(node) {\n    return node.parent.type === \"ForStatement\" && node.parent.init === node;\n}\n\n/**\n * Checks whether a given Identifier node becomes a VariableDeclaration or not.\n *\n * @param {ASTNode} identifier - An Identifier node to check.\n * @returns {boolean} `true` if the node can become a VariableDeclaration.\n */\nfunction canBecomeVariableDeclaration(identifier) {\n    let node = identifier.parent;\n\n    while (PATTERN_TYPE.test(node.type)) {\n        node = node.parent;\n    }\n\n    return (\n        node.type === \"VariableDeclarator\" ||\n        (\n            node.type === \"AssignmentExpression\" &&\n            node.parent.type === \"ExpressionStatement\" &&\n            DECLARATION_HOST_TYPE.test(node.parent.parent.type)\n        )\n    );\n}\n\n/**\n * Gets an identifier node of a given variable.\n *\n * If the initialization exists or one or more reading references exist before\n * the first assignment, the identifier node is the node of the declaration.\n * Otherwise, the identifier node is the node of the first assignment.\n *\n * If the variable should not change to const, this function returns null.\n * - If the variable is reassigned.\n * - If the variable is never initialized nor assigned.\n * - If the variable is initialized in a different scope from the declaration.\n * - If the unique assignment of the variable cannot change to a declaration.\n *   e.g. `if (a) b = 1` / `return (b = 1)`\n * - If the variable is declared in the global scope and `eslintUsed` is `true`.\n *   `/*exported foo` directive comment makes such variables. This rule does not\n *   warn such variables because this rule cannot distinguish whether the\n *   exported variables are reassigned or not.\n *\n * @param {eslint-scope.Variable} variable - A variable to get.\n * @param {boolean} ignoreReadBeforeAssign -\n *      The value of `ignoreReadBeforeAssign` option.\n * @returns {ASTNode|null}\n *      An Identifier node if the variable should change to const.\n *      Otherwise, null.\n */\nfunction getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {\n    if (variable.eslintUsed && variable.scope.type === \"global\") {\n        return null;\n    }\n\n    // Finds the unique WriteReference.\n    let writer = null;\n    let isReadBeforeInit = false;\n    const references = variable.references;\n\n    for (let i = 0; i < references.length; ++i) {\n        const reference = references[i];\n\n        if (reference.isWrite()) {\n            const isReassigned = (\n                writer !== null &&\n                writer.identifier !== reference.identifier\n            );\n\n            if (isReassigned) {\n                return null;\n            }\n            writer = reference;\n\n        } else if (reference.isRead() && writer === null) {\n            if (ignoreReadBeforeAssign) {\n                return null;\n            }\n            isReadBeforeInit = true;\n        }\n    }\n\n    // If the assignment is from a different scope, ignore it.\n    // If the assignment cannot change to a declaration, ignore it.\n    const shouldBeConst = (\n        writer !== null &&\n        writer.from === variable.scope &&\n        canBecomeVariableDeclaration(writer.identifier)\n    );\n\n    if (!shouldBeConst) {\n        return null;\n    }\n    if (isReadBeforeInit) {\n        return variable.defs[0].name;\n    }\n    return writer.identifier;\n}\n\n/**\n * Gets the VariableDeclarator/AssignmentExpression node that a given reference\n * belongs to.\n * This is used to detect a mix of reassigned and never reassigned in a\n * destructuring.\n *\n * @param {eslint-scope.Reference} reference - A reference to get.\n * @returns {ASTNode|null} A VariableDeclarator/AssignmentExpression node or\n *      null.\n */\nfunction getDestructuringHost(reference) {\n    if (!reference.isWrite()) {\n        return null;\n    }\n    let node = reference.identifier.parent;\n\n    while (PATTERN_TYPE.test(node.type)) {\n        node = node.parent;\n    }\n\n    if (!DESTRUCTURING_HOST_TYPE.test(node.type)) {\n        return null;\n    }\n    return node;\n}\n\n/**\n * Groups by the VariableDeclarator/AssignmentExpression node that each\n * reference of given variables belongs to.\n * This is used to detect a mix of reassigned and never reassigned in a\n * destructuring.\n *\n * @param {eslint-scope.Variable[]} variables - Variables to group by destructuring.\n * @param {boolean} ignoreReadBeforeAssign -\n *      The value of `ignoreReadBeforeAssign` option.\n * @returns {Map<ASTNode, ASTNode[]>} Grouped identifier nodes.\n */\nfunction groupByDestructuring(variables, ignoreReadBeforeAssign) {\n    const identifierMap = new Map();\n\n    for (let i = 0; i < variables.length; ++i) {\n        const variable = variables[i];\n        const references = variable.references;\n        const identifier = getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign);\n        let prevId = null;\n\n        for (let j = 0; j < references.length; ++j) {\n            const reference = references[j];\n            const id = reference.identifier;\n\n            // Avoid counting a reference twice or more for default values of\n            // destructuring.\n            if (id === prevId) {\n                continue;\n            }\n            prevId = id;\n\n            // Add the identifier node into the destructuring group.\n            const group = getDestructuringHost(reference);\n\n            if (group) {\n                if (identifierMap.has(group)) {\n                    identifierMap.get(group).push(identifier);\n                } else {\n                    identifierMap.set(group, [identifier]);\n                }\n            }\n        }\n    }\n\n    return identifierMap;\n}\n\n/**\n * Finds the nearest parent of node with a given type.\n *\n * @param {ASTNode} node â The node to search from.\n * @param {string} type â The type field of the parent node.\n * @param {Function} shouldStop â a predicate that returns true if the traversal should stop, and false otherwise.\n * @returns {ASTNode} The closest ancestor with the specified type; null if no such ancestor exists.\n */\nfunction findUp(node, type, shouldStop) {\n    if (!node || shouldStop(node)) {\n        return null;\n    }\n    if (node.type === type) {\n        return node;\n    }\n    return findUp(node.parent, type, shouldStop);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require `const` declarations for variables that are never reassigned after declared\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    destructuring: { enum: [\"any\", \"all\"] },\n                    ignoreReadBeforeAssign: { type: \"boolean\" }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const sourceCode = context.getSourceCode();\n        const checkingMixedDestructuring = options.destructuring !== \"all\";\n        const ignoreReadBeforeAssign = options.ignoreReadBeforeAssign === true;\n        const variables = [];\n\n        /**\n         * Reports given identifier nodes if all of the nodes should be declared\n         * as const.\n         *\n         * The argument 'nodes' is an array of Identifier nodes.\n         * This node is the result of 'getIdentifierIfShouldBeConst()', so it's\n         * nullable. In simple declaration or assignment cases, the length of\n         * the array is 1. In destructuring cases, the length of the array can\n         * be 2 or more.\n         *\n         * @param {(eslint-scope.Reference|null)[]} nodes -\n         *      References which are grouped by destructuring to report.\n         * @returns {void}\n         */\n        function checkGroup(nodes) {\n            const nodesToReport = nodes.filter(Boolean);\n\n            if (nodes.length && (checkingMixedDestructuring || nodesToReport.length === nodes.length)) {\n                const varDeclParent = findUp(nodes[0], \"VariableDeclaration\", parentNode => parentNode.type.endsWith(\"Statement\"));\n                const shouldFix = varDeclParent &&\n\n                    // If there are multiple variable declarations, like {let a = 1, b = 2}, then\n                    // do not attempt to fix if one of the declarations should be `const`. It's\n                    // too hard to know how the developer would want to automatically resolve the issue.\n                    varDeclParent.declarations.length === 1 &&\n\n                    // Don't do a fix unless the variable is initialized (or it's in a for-in or for-of loop)\n                    (varDeclParent.parent.type === \"ForInStatement\" || varDeclParent.parent.type === \"ForOfStatement\" || varDeclParent.declarations[0].init) &&\n\n                    // If options.destucturing is \"all\", then this warning will not occur unless\n                    // every assignment in the destructuring should be const. In that case, it's safe\n                    // to apply the fix.\n                    nodesToReport.length === nodes.length;\n\n                nodesToReport.forEach(node => {\n                    context.report({\n                        node,\n                        message: \"'{{name}}' is never reassigned. Use 'const' instead.\",\n                        data: node,\n                        fix: shouldFix ? fixer => fixer.replaceText(sourceCode.getFirstToken(varDeclParent), \"const\") : null\n                    });\n                });\n            }\n        }\n\n        return {\n            \"Program:exit\"() {\n                groupByDestructuring(variables, ignoreReadBeforeAssign).forEach(checkGroup);\n            },\n\n            VariableDeclaration(node) {\n                if (node.kind === \"let\" && !isInitOfForStatement(node)) {\n                    pushAll(variables, context.getDeclaredVariables(node));\n                }\n            }\n        };\n    }\n};\n","prefer-destructuring.js":"/**\n * @fileoverview Prefer destructuring from arrays and objects\n * @author Alex LaFroscia\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require destructuring from arrays and/or objects\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n        schema: [\n            {\n\n                // old support {array: Boolean, object: Boolean}\n                // new support {VariableDeclarator: {}, AssignmentExpression: {}}\n                oneOf: [\n                    {\n                        type: \"object\",\n                        properties: {\n                            VariableDeclarator: {\n                                type: \"object\",\n                                properties: {\n                                    array: {\n                                        type: \"boolean\"\n                                    },\n                                    object: {\n                                        type: \"boolean\"\n                                    }\n                                },\n                                additionalProperties: false\n                            },\n                            AssignmentExpression: {\n                                type: \"object\",\n                                properties: {\n                                    array: {\n                                        type: \"boolean\"\n                                    },\n                                    object: {\n                                        type: \"boolean\"\n                                    }\n                                },\n                                additionalProperties: false\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            array: {\n                                type: \"boolean\"\n                            },\n                            object: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    enforceForRenamedProperties: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n    create(context) {\n\n        const enabledTypes = context.options[0];\n        const enforceForRenamedProperties = context.options[1] && context.options[1].enforceForRenamedProperties;\n        let normalizedOptions = {\n            VariableDeclarator: { array: true, object: true },\n            AssignmentExpression: { array: true, object: true }\n        };\n\n        if (enabledTypes) {\n            normalizedOptions = typeof enabledTypes.array !== \"undefined\" || typeof enabledTypes.object !== \"undefined\"\n                ? { VariableDeclarator: enabledTypes, AssignmentExpression: enabledTypes }\n                : enabledTypes;\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * @param {string} nodeType \"AssignmentExpression\" or \"VariableDeclarator\"\n         * @param {string} destructuringType \"array\" or \"object\"\n         * @returns {boolean} `true` if the destructuring type should be checked for the given node\n         */\n        function shouldCheck(nodeType, destructuringType) {\n            return normalizedOptions &&\n                normalizedOptions[nodeType] &&\n                normalizedOptions[nodeType][destructuringType];\n        }\n\n        /**\n         * Determines if the given node is accessing an array index\n         *\n         * This is used to differentiate array index access from object property\n         * access.\n         *\n         * @param {ASTNode} node the node to evaluate\n         * @returns {boolean} whether or not the node is an integer\n         */\n        function isArrayIndexAccess(node) {\n            return Number.isInteger(node.property.value);\n        }\n\n        /**\n         * Report that the given node should use destructuring\n         *\n         * @param {ASTNode} reportNode the node to report\n         * @param {string} type the type of destructuring that should have been done\n         * @returns {void}\n         */\n        function report(reportNode, type) {\n            context.report({ node: reportNode, message: \"Use {{type}} destructuring.\", data: { type } });\n        }\n\n        /**\n         * Check that the `prefer-destructuring` rules are followed based on the\n         * given left- and right-hand side of the assignment.\n         *\n         * Pulled out into a separate method so that VariableDeclarators and\n         * AssignmentExpressions can share the same verification logic.\n         *\n         * @param {ASTNode} leftNode the left-hand side of the assignment\n         * @param {ASTNode} rightNode the right-hand side of the assignment\n         * @param {ASTNode} reportNode the node to report the error on\n         * @returns {void}\n         */\n        function performCheck(leftNode, rightNode, reportNode) {\n            if (rightNode.type !== \"MemberExpression\") {\n                return;\n            }\n\n            if (isArrayIndexAccess(rightNode)) {\n                if (shouldCheck(reportNode.type, \"array\")) {\n                    report(reportNode, \"array\");\n                }\n                return;\n            }\n\n            if (shouldCheck(reportNode.type, \"object\") && enforceForRenamedProperties) {\n                report(reportNode, \"object\");\n                return;\n            }\n\n            if (shouldCheck(reportNode.type, \"object\")) {\n                const property = rightNode.property;\n\n                if ((property.type === \"Literal\" && leftNode.name === property.value) || (property.type === \"Identifier\" &&\n                    leftNode.name === property.name)) {\n                    report(reportNode, \"object\");\n                }\n            }\n        }\n\n        /**\n         * Check if a given variable declarator is coming from an property access\n         * that should be using destructuring instead\n         *\n         * @param {ASTNode} node the variable declarator to check\n         * @returns {void}\n         */\n        function checkVariableDeclarator(node) {\n\n            // Skip if variable is declared without assignment\n            if (!node.init) {\n                return;\n            }\n\n            // We only care about member expressions past this point\n            if (node.init.type !== \"MemberExpression\") {\n                return;\n            }\n\n            performCheck(node.id, node.init, node);\n        }\n\n        /**\n         * Run the `prefer-destructuring` check on an AssignmentExpression\n         *\n         * @param {ASTNode} node the AssignmentExpression node\n         * @returns {void}\n         */\n        function checkAssigmentExpression(node) {\n            if (node.operator === \"=\") {\n                performCheck(node.left, node.right, node);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclarator: checkVariableDeclarator,\n            AssignmentExpression: checkAssigmentExpression\n        };\n    }\n};\n","prefer-numeric-literals.js":"/**\n * @fileoverview Rule to disallow `parseInt()` in favor of binary, octal, and hexadecimal literals\n * @author Annie Zhang, Henry Zhu\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks to see if a CallExpression's callee node is `parseInt` or\n * `Number.parseInt`.\n * @param {ASTNode} calleeNode The callee node to evaluate.\n * @returns {boolean} True if the callee is `parseInt` or `Number.parseInt`,\n * false otherwise.\n */\nfunction isParseInt(calleeNode) {\n    switch (calleeNode.type) {\n        case \"Identifier\":\n            return calleeNode.name === \"parseInt\";\n        case \"MemberExpression\":\n            return calleeNode.object.type === \"Identifier\" &&\n                calleeNode.object.name === \"Number\" &&\n                calleeNode.property.type === \"Identifier\" &&\n                calleeNode.property.name === \"parseInt\";\n\n        // no default\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const radixMap = {\n            2: \"binary\",\n            8: \"octal\",\n            16: \"hexadecimal\"\n        };\n\n        const prefixMap = {\n            2: \"0b\",\n            8: \"0o\",\n            16: \"0x\"\n        };\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n\n            CallExpression(node) {\n\n                // doesn't check parseInt() if it doesn't have a radix argument\n                if (node.arguments.length !== 2) {\n                    return;\n                }\n\n                // only error if the radix is 2, 8, or 16\n                const radixName = radixMap[node.arguments[1].value];\n\n                if (isParseInt(node.callee) &&\n                    radixName &&\n                    node.arguments[0].type === \"Literal\"\n                ) {\n                    context.report({\n                        node,\n                        message: \"Use {{radixName}} literals instead of {{functionName}}().\",\n                        data: {\n                            radixName,\n                            functionName: sourceCode.getText(node.callee)\n                        },\n                        fix(fixer) {\n                            const newPrefix = prefixMap[node.arguments[1].value];\n\n                            if (+(newPrefix + node.arguments[0].value) !== parseInt(node.arguments[0].value, node.arguments[1].value)) {\n\n                                // If the newly-produced literal would be invalid, (e.g. 0b1234),\n                                // or it would yield an incorrect parseInt result for some other reason, don't make a fix.\n                                return null;\n                            }\n                            return fixer.replaceText(node, prefixMap[node.arguments[1].value] + node.arguments[0].value);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","prefer-promise-reject-errors.js":"/**\n * @fileoverview restrict values that can be used as Promise rejection reasons\n * @author Teddy Katz\n */\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require using Error objects as Promise rejection reasons\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n        fixable: null,\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowEmptyReject: { type: \"boolean\" }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const ALLOW_EMPTY_REJECT = context.options.length && context.options[0].allowEmptyReject;\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n        * Checks the argument of a reject() or Promise.reject() CallExpression, and reports it if it can't be an Error\n        * @param {ASTNode} callExpression A CallExpression node which is used to reject a Promise\n        * @returns {void}\n        */\n        function checkRejectCall(callExpression) {\n            if (!callExpression.arguments.length && ALLOW_EMPTY_REJECT) {\n                return;\n            }\n            if (\n                !callExpression.arguments.length ||\n                !astUtils.couldBeError(callExpression.arguments[0]) ||\n                callExpression.arguments[0].type === \"Identifier\" && callExpression.arguments[0].name === \"undefined\"\n            ) {\n                context.report({\n                    node: callExpression,\n                    message: \"Expected the Promise rejection reason to be an Error.\"\n                });\n            }\n        }\n\n        /**\n        * Determines whether a function call is a Promise.reject() call\n        * @param {ASTNode} node A CallExpression node\n        * @returns {boolean} `true` if the call is a Promise.reject() call\n        */\n        function isPromiseRejectCall(node) {\n            return node.callee.type === \"MemberExpression\" &&\n                node.callee.object.type === \"Identifier\" && node.callee.object.name === \"Promise\" &&\n                node.callee.property.type === \"Identifier\" && node.callee.property.name === \"reject\";\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n\n            // Check `Promise.reject(value)` calls.\n            CallExpression(node) {\n                if (isPromiseRejectCall(node)) {\n                    checkRejectCall(node);\n                }\n            },\n\n            /*\n             * Check for `new Promise((resolve, reject) => {})`, and check for reject() calls.\n             * This function is run on \"NewExpression:exit\" instead of \"NewExpression\" to ensure that\n             * the nodes in the expression already have the `parent` property.\n             */\n            \"NewExpression:exit\"(node) {\n                if (\n                    node.callee.type === \"Identifier\" && node.callee.name === \"Promise\" &&\n                    node.arguments.length && astUtils.isFunction(node.arguments[0]) &&\n                    node.arguments[0].params.length > 1 && node.arguments[0].params[1].type === \"Identifier\"\n                ) {\n                    context.getDeclaredVariables(node.arguments[0])\n\n                        /*\n                        * Find the first variable that matches the second parameter's name.\n                        * If the first parameter has the same name as the second parameter, then the variable will actually\n                        * be \"declared\" when the first parameter is evaluated, but then it will be immediately overwritten\n                        * by the second parameter. It's not possible for an expression with the variable to be evaluated before\n                        * the variable is overwritten, because functions with duplicate parameters cannot have destructuring or\n                        * default assignments in their parameter lists. Therefore, it's not necessary to explicitly account for\n                        * this case.\n                        */\n                        .find(variable => variable.name === node.arguments[0].params[1].name)\n\n                        // Get the references to that variable.\n                        .references\n\n                        // Only check the references that read the parameter's value.\n                        .filter(ref => ref.isRead())\n\n                        // Only check the references that are used as the callee in a function call, e.g. `reject(foo)`.\n                        .filter(ref => ref.identifier.parent.type === \"CallExpression\" && ref.identifier === ref.identifier.parent.callee)\n\n                        // Check the argument of the function call to determine whether it's an Error.\n                        .forEach(ref => checkRejectCall(ref.identifier.parent));\n                }\n            }\n        };\n    }\n};\n","prefer-reflect.js":"/**\n * @fileoverview Rule to suggest using \"Reflect\" api over Function/Object methods\n * @author Keith Cirkel <http://keithcirkel.co.uk>\n * @deprecated in ESLint v3.9.0\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require `Reflect` methods where applicable\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            replacedBy: []\n        },\n\n        deprecated: true,\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            enum: [\n                                \"apply\",\n                                \"call\",\n                                \"delete\",\n                                \"defineProperty\",\n                                \"getOwnPropertyDescriptor\",\n                                \"getPrototypeOf\",\n                                \"setPrototypeOf\",\n                                \"isExtensible\",\n                                \"getOwnPropertyNames\",\n                                \"preventExtensions\"\n                            ]\n                        },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const existingNames = {\n            apply: \"Function.prototype.apply\",\n            call: \"Function.prototype.call\",\n            defineProperty: \"Object.defineProperty\",\n            getOwnPropertyDescriptor: \"Object.getOwnPropertyDescriptor\",\n            getPrototypeOf: \"Object.getPrototypeOf\",\n            setPrototypeOf: \"Object.setPrototypeOf\",\n            isExtensible: \"Object.isExtensible\",\n            getOwnPropertyNames: \"Object.getOwnPropertyNames\",\n            preventExtensions: \"Object.preventExtensions\"\n        };\n\n        const reflectSubsitutes = {\n            apply: \"Reflect.apply\",\n            call: \"Reflect.apply\",\n            defineProperty: \"Reflect.defineProperty\",\n            getOwnPropertyDescriptor: \"Reflect.getOwnPropertyDescriptor\",\n            getPrototypeOf: \"Reflect.getPrototypeOf\",\n            setPrototypeOf: \"Reflect.setPrototypeOf\",\n            isExtensible: \"Reflect.isExtensible\",\n            getOwnPropertyNames: \"Reflect.getOwnPropertyNames\",\n            preventExtensions: \"Reflect.preventExtensions\"\n        };\n\n        const exceptions = (context.options[0] || {}).exceptions || [];\n\n        /**\n         * Reports the Reflect violation based on the `existing` and `substitute`\n         * @param {Object} node The node that violates the rule.\n         * @param {string} existing The existing method name that has been used.\n         * @param {string} substitute The Reflect substitute that should be used.\n         * @returns {void}\n         */\n        function report(node, existing, substitute) {\n            context.report({\n                node,\n                message: \"Avoid using {{existing}}, instead use {{substitute}}.\",\n                data: {\n                    existing,\n                    substitute\n                }\n            });\n        }\n\n        return {\n            CallExpression(node) {\n                const methodName = (node.callee.property || {}).name;\n                const isReflectCall = (node.callee.object || {}).name === \"Reflect\";\n                const hasReflectSubsitute = reflectSubsitutes.hasOwnProperty(methodName);\n                const userConfiguredException = exceptions.indexOf(methodName) !== -1;\n\n                if (hasReflectSubsitute && !isReflectCall && !userConfiguredException) {\n                    report(node, existingNames[methodName], reflectSubsitutes[methodName]);\n                }\n            },\n            UnaryExpression(node) {\n                const isDeleteOperator = node.operator === \"delete\";\n                const targetsIdentifier = node.argument.type === \"Identifier\";\n                const userConfiguredException = exceptions.indexOf(\"delete\") !== -1;\n\n                if (isDeleteOperator && !targetsIdentifier && !userConfiguredException) {\n                    report(node, \"the delete keyword\", \"Reflect.deleteProperty\");\n                }\n            }\n        };\n\n    }\n};\n","prefer-rest-params.js":"/**\n * @fileoverview Rule to\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets the variable object of `arguments` which is defined implicitly.\n * @param {eslint-scope.Scope} scope - A scope to get.\n * @returns {eslint-scope.Variable} The found variable object.\n */\nfunction getVariableOfArguments(scope) {\n    const variables = scope.variables;\n\n    for (let i = 0; i < variables.length; ++i) {\n        const variable = variables[i];\n\n        if (variable.name === \"arguments\") {\n\n            // If there was a parameter which is named \"arguments\", the implicit \"arguments\" is not defined.\n            // So does fast return with null.\n            return (variable.identifiers.length === 0) ? variable : null;\n        }\n    }\n\n    /* istanbul ignore next : unreachable */\n    return null;\n}\n\n/**\n * Checks if the given reference is not normal member access.\n *\n * - arguments         .... true    // not member access\n * - arguments[i]      .... true    // computed member access\n * - arguments[0]      .... true    // computed member access\n * - arguments.length  .... false   // normal member access\n *\n * @param {eslint-scope.Reference} reference - The reference to check.\n * @returns {boolean} `true` if the reference is not normal member access.\n */\nfunction isNotNormalMemberAccess(reference) {\n    const id = reference.identifier;\n    const parent = id.parent;\n\n    return !(\n        parent.type === \"MemberExpression\" &&\n        parent.object === id &&\n        !parent.computed\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require rest parameters instead of `arguments`\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Reports a given reference.\n         *\n         * @param {eslint-scope.Reference} reference - A reference to report.\n         * @returns {void}\n         */\n        function report(reference) {\n            context.report({\n                node: reference.identifier,\n                loc: reference.identifier.loc,\n                message: \"Use the rest parameters instead of 'arguments'.\"\n            });\n        }\n\n        /**\n         * Reports references of the implicit `arguments` variable if exist.\n         *\n         * @returns {void}\n         */\n        function checkForArguments() {\n            const argumentsVar = getVariableOfArguments(context.getScope());\n\n            if (argumentsVar) {\n                argumentsVar\n                    .references\n                    .filter(isNotNormalMemberAccess)\n                    .forEach(report);\n            }\n        }\n\n        return {\n            \"FunctionDeclaration:exit\": checkForArguments,\n            \"FunctionExpression:exit\": checkForArguments\n        };\n    }\n};\n","prefer-spread.js":"/**\n * @fileoverview A rule to suggest using of the spread operator instead of `.apply()`.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a node is a `.apply()` for variadic.\n * @param {ASTNode} node - A CallExpression node to check.\n * @returns {boolean} Whether or not the node is a `.apply()` for variadic.\n */\nfunction isVariadicApplyCalling(node) {\n    return (\n        node.callee.type === \"MemberExpression\" &&\n        node.callee.property.type === \"Identifier\" &&\n        node.callee.property.name === \"apply\" &&\n        node.callee.computed === false &&\n        node.arguments.length === 2 &&\n        node.arguments[1].type !== \"ArrayExpression\" &&\n        node.arguments[1].type !== \"SpreadElement\"\n    );\n}\n\n/**\n * Checks whether or not the tokens of two given nodes are same.\n * @param {ASTNode} left - A node 1 to compare.\n * @param {ASTNode} right - A node 2 to compare.\n * @param {SourceCode} sourceCode - The ESLint source code object.\n * @returns {boolean} the source code for the given node.\n */\nfunction equalTokens(left, right, sourceCode) {\n    const tokensL = sourceCode.getTokens(left);\n    const tokensR = sourceCode.getTokens(right);\n\n    if (tokensL.length !== tokensR.length) {\n        return false;\n    }\n    for (let i = 0; i < tokensL.length; ++i) {\n        if (tokensL[i].type !== tokensR[i].type ||\n            tokensL[i].value !== tokensR[i].value\n        ) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Checks whether or not `thisArg` is not changed by `.apply()`.\n * @param {ASTNode|null} expectedThis - The node that is the owner of the applied function.\n * @param {ASTNode} thisArg - The node that is given to the first argument of the `.apply()`.\n * @param {RuleContext} context - The ESLint rule context object.\n * @returns {boolean} Whether or not `thisArg` is not changed by `.apply()`.\n */\nfunction isValidThisArg(expectedThis, thisArg, context) {\n    if (!expectedThis) {\n        return astUtils.isNullOrUndefined(thisArg);\n    }\n    return equalTokens(expectedThis, thisArg, context);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require spread operators instead of `.apply()`\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            CallExpression(node) {\n                if (!isVariadicApplyCalling(node)) {\n                    return;\n                }\n\n                const applied = node.callee.object;\n                const expectedThis = (applied.type === \"MemberExpression\") ? applied.object : null;\n                const thisArg = node.arguments[0];\n\n                if (isValidThisArg(expectedThis, thisArg, sourceCode)) {\n                    context.report({\n                        node,\n                        message: \"Use the spread operator instead of '.apply()'.\",\n                        fix(fixer) {\n                            if (expectedThis && expectedThis.type !== \"Identifier\") {\n\n                                // Don't fix cases where the `this` value could be a computed expression.\n                                return null;\n                            }\n\n                            const propertyDot = sourceCode.getFirstTokenBetween(applied, node.callee.property, token => token.value === \".\");\n\n                            return fixer.replaceTextRange([propertyDot.range[0], node.range[1]], `(...${sourceCode.getText(node.arguments[1])})`);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","prefer-template.js":"/**\n * @fileoverview A rule to suggest using template literals instead of string concatenation.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a concatenation.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is a concatenation.\n */\nfunction isConcatenation(node) {\n    return node.type === \"BinaryExpression\" && node.operator === \"+\";\n}\n\n/**\n * Gets the top binary expression node for concatenation in parents of a given node.\n * @param {ASTNode} node - A node to get.\n * @returns {ASTNode} the top binary expression node in parents of a given node.\n */\nfunction getTopConcatBinaryExpression(node) {\n    while (isConcatenation(node.parent)) {\n        node = node.parent;\n    }\n    return node;\n}\n\n/**\n* Checks whether or not a given binary expression has string literals.\n* @param {ASTNode} node - A node to check.\n* @returns {boolean} `true` if the node has string literals.\n*/\nfunction hasStringLiteral(node) {\n    if (isConcatenation(node)) {\n\n        // `left` is deeper than `right` normally.\n        return hasStringLiteral(node.right) || hasStringLiteral(node.left);\n    }\n    return astUtils.isStringLiteral(node);\n}\n\n/**\n * Checks whether or not a given binary expression has non string literals.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node has non string literals.\n */\nfunction hasNonStringLiteral(node) {\n    if (isConcatenation(node)) {\n\n        // `left` is deeper than `right` normally.\n        return hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left);\n    }\n    return !astUtils.isStringLiteral(node);\n}\n\n/**\n* Determines whether a given node will start with a template curly expression (`${}`) when being converted to a template literal.\n* @param {ASTNode} node The node that will be fixed to a template literal\n* @returns {boolean} `true` if the node will start with a template curly.\n*/\nfunction startsWithTemplateCurly(node) {\n    if (node.type === \"BinaryExpression\") {\n        return startsWithTemplateCurly(node.left);\n    }\n    if (node.type === \"TemplateLiteral\") {\n        return node.expressions.length && node.quasis.length && node.quasis[0].range[0] === node.quasis[0].range[1];\n    }\n    return node.type !== \"Literal\" || typeof node.value !== \"string\";\n}\n\n/**\n* Determines whether a given node end with a template curly expression (`${}`) when being converted to a template literal.\n* @param {ASTNode} node The node that will be fixed to a template literal\n* @returns {boolean} `true` if the node will end with a template curly.\n*/\nfunction endsWithTemplateCurly(node) {\n    if (node.type === \"BinaryExpression\") {\n        return startsWithTemplateCurly(node.right);\n    }\n    if (node.type === \"TemplateLiteral\") {\n        return node.expressions.length && node.quasis.length && node.quasis[node.quasis.length - 1].range[0] === node.quasis[node.quasis.length - 1].range[1];\n    }\n    return node.type !== \"Literal\" || typeof node.value !== \"string\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require template literals instead of string concatenation\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        let done = Object.create(null);\n\n        /**\n        * Gets the non-token text between two nodes, ignoring any other tokens that appear between the two tokens.\n        * @param {ASTNode} node1 The first node\n        * @param {ASTNode} node2 The second node\n        * @returns {string} The text between the nodes, excluding other tokens\n        */\n        function getTextBetween(node1, node2) {\n            const allTokens = [node1].concat(sourceCode.getTokensBetween(node1, node2)).concat(node2);\n            const sourceText = sourceCode.getText();\n\n            return allTokens.slice(0, -1).reduce((accumulator, token, index) => accumulator + sourceText.slice(token.range[1], allTokens[index + 1].range[0]), \"\");\n        }\n\n        /**\n        * Returns a template literal form of the given node.\n        * @param {ASTNode} currentNode A node that should be converted to a template literal\n        * @param {string} textBeforeNode Text that should appear before the node\n        * @param {string} textAfterNode Text that should appear after the node\n        * @returns {string} A string form of this node, represented as a template literal\n        */\n        function getTemplateLiteral(currentNode, textBeforeNode, textAfterNode) {\n            if (currentNode.type === \"Literal\" && typeof currentNode.value === \"string\") {\n\n                // If the current node is a string literal, escape any instances of ${ or ` to prevent them from being interpreted\n                // as a template placeholder. However, if the code already contains a backslash before the ${ or `\n                // for some reason, don't add another backslash, because that would change the meaning of the code (it would cause\n                // an actual backslash character to appear before the dollar sign).\n                return `\\`${currentNode.raw.slice(1, -1).replace(/\\\\*(\\${|`)/g, matched => {\n                    if (matched.lastIndexOf(\"\\\\\") % 2) {\n                        return `\\\\${matched}`;\n                    }\n                    return matched;\n\n                // Unescape any quotes that appear in the original Literal that no longer need to be escaped.\n                }).replace(new RegExp(`\\\\\\\\${currentNode.raw[0]}`, \"g\"), currentNode.raw[0])}\\``;\n            }\n\n            if (currentNode.type === \"TemplateLiteral\") {\n                return sourceCode.getText(currentNode);\n            }\n\n            if (isConcatenation(currentNode) && hasStringLiteral(currentNode) && hasNonStringLiteral(currentNode)) {\n                const plusSign = sourceCode.getFirstTokenBetween(currentNode.left, currentNode.right, token => token.value === \"+\");\n                const textBeforePlus = getTextBetween(currentNode.left, plusSign);\n                const textAfterPlus = getTextBetween(plusSign, currentNode.right);\n                const leftEndsWithCurly = endsWithTemplateCurly(currentNode.left);\n                const rightStartsWithCurly = startsWithTemplateCurly(currentNode.right);\n\n                if (leftEndsWithCurly) {\n\n                    // If the left side of the expression ends with a template curly, add the extra text to the end of the curly bracket.\n                    // `foo${bar}` /* comment */ + 'baz' --> `foo${bar /* comment */  }${baz}`\n                    return getTemplateLiteral(currentNode.left, textBeforeNode, textBeforePlus + textAfterPlus).slice(0, -1) +\n                        getTemplateLiteral(currentNode.right, null, textAfterNode).slice(1);\n                }\n                if (rightStartsWithCurly) {\n\n                    // Otherwise, if the right side of the expression starts with a template curly, add the text there.\n                    // 'foo' /* comment */ + `${bar}baz` --> `foo${ /* comment */  bar}baz`\n                    return getTemplateLiteral(currentNode.left, textBeforeNode, null).slice(0, -1) +\n                        getTemplateLiteral(currentNode.right, textBeforePlus + textAfterPlus, textAfterNode).slice(1);\n                }\n\n                // Otherwise, these nodes should not be combined into a template curly, since there is nowhere to put\n                // the text between them.\n                return `${getTemplateLiteral(currentNode.left, textBeforeNode, null)}${textBeforePlus}+${textAfterPlus}${getTemplateLiteral(currentNode.right, textAfterNode, null)}`;\n            }\n\n            return `\\`\\${${textBeforeNode || \"\"}${sourceCode.getText(currentNode)}${textAfterNode || \"\"}}\\``;\n        }\n\n        /**\n         * Reports if a given node is string concatenation with non string literals.\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {void}\n         */\n        function checkForStringConcat(node) {\n            if (!astUtils.isStringLiteral(node) || !isConcatenation(node.parent)) {\n                return;\n            }\n\n            const topBinaryExpr = getTopConcatBinaryExpression(node.parent);\n\n            // Checks whether or not this node had been checked already.\n            if (done[topBinaryExpr.range[0]]) {\n                return;\n            }\n            done[topBinaryExpr.range[0]] = true;\n\n            if (hasNonStringLiteral(topBinaryExpr)) {\n                context.report({\n                    node: topBinaryExpr,\n                    message: \"Unexpected string concatenation.\",\n                    fix(fixer) {\n                        return fixer.replaceText(topBinaryExpr, getTemplateLiteral(topBinaryExpr, null, null));\n                    }\n                });\n            }\n        }\n\n        return {\n            Program() {\n                done = Object.create(null);\n            },\n\n            Literal: checkForStringConcat,\n            TemplateLiteral: checkForStringConcat\n        };\n    }\n};\n","quote-props.js":"/**\n * @fileoverview Rule to flag non-quoted property names in object literals.\n * @author Mathias Bynens <http://mathiasbynens.be/>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst espree = require(\"espree\"),\n    keywords = require(\"../util/keywords\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require quotes around object literal property names\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"as-needed\", \"consistent\", \"consistent-as-needed\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"as-needed\", \"consistent\", \"consistent-as-needed\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                keywords: {\n                                    type: \"boolean\"\n                                },\n                                unnecessary: {\n                                    type: \"boolean\"\n                                },\n                                numbers: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        const MODE = context.options[0],\n            KEYWORDS = context.options[1] && context.options[1].keywords,\n            CHECK_UNNECESSARY = !context.options[1] || context.options[1].unnecessary !== false,\n            NUMBERS = context.options[1] && context.options[1].numbers,\n\n            MESSAGE_UNNECESSARY = \"Unnecessarily quoted property '{{property}}' found.\",\n            MESSAGE_UNQUOTED = \"Unquoted property '{{property}}' found.\",\n            MESSAGE_NUMERIC = \"Unquoted number literal '{{property}}' used as key.\",\n            MESSAGE_RESERVED = \"Unquoted reserved word '{{property}}' used as key.\",\n            sourceCode = context.getSourceCode();\n\n\n        /**\n         * Checks whether a certain string constitutes an ES3 token\n         * @param   {string} tokenStr - The string to be checked.\n         * @returns {boolean} `true` if it is an ES3 token.\n         */\n        function isKeyword(tokenStr) {\n            return keywords.indexOf(tokenStr) >= 0;\n        }\n\n        /**\n         * Checks if an espree-tokenized key has redundant quotes (i.e. whether quotes are unnecessary)\n         * @param   {string} rawKey The raw key value from the source\n         * @param   {espreeTokens} tokens The espree-tokenized node key\n         * @param   {boolean} [skipNumberLiterals=false] Indicates whether number literals should be checked\n         * @returns {boolean} Whether or not a key has redundant quotes.\n         * @private\n         */\n        function areQuotesRedundant(rawKey, tokens, skipNumberLiterals) {\n            return tokens.length === 1 && tokens[0].start === 0 && tokens[0].end === rawKey.length &&\n                ([\"Identifier\", \"Keyword\", \"Null\", \"Boolean\"].indexOf(tokens[0].type) >= 0 ||\n                (tokens[0].type === \"Numeric\" && !skipNumberLiterals && String(+tokens[0].value) === tokens[0].value));\n        }\n\n        /**\n        * Returns a string representation of a property node with quotes removed\n        * @param {ASTNode} key Key AST Node, which may or may not be quoted\n        * @returns {string} A replacement string for this property\n        */\n        function getUnquotedKey(key) {\n            return key.type === \"Identifier\" ? key.name : key.value;\n        }\n\n        /**\n        * Returns a string representation of a property node with quotes added\n        * @param {ASTNode} key Key AST Node, which may or may not be quoted\n        * @returns {string} A replacement string for this property\n        */\n        function getQuotedKey(key) {\n            if (key.type === \"Literal\" && typeof key.value === \"string\") {\n\n                // If the key is already a string literal, don't replace the quotes with double quotes.\n                return sourceCode.getText(key);\n            }\n\n            // Otherwise, the key is either an identifier or a number literal.\n            return `\"${key.type === \"Identifier\" ? key.name : key.value}\"`;\n        }\n\n        /**\n         * Ensures that a property's key is quoted only when necessary\n         * @param   {ASTNode} node Property AST node\n         * @returns {void}\n         */\n        function checkUnnecessaryQuotes(node) {\n            const key = node.key;\n\n            if (node.method || node.computed || node.shorthand) {\n                return;\n            }\n\n            if (key.type === \"Literal\" && typeof key.value === \"string\") {\n                let tokens;\n\n                try {\n                    tokens = espree.tokenize(key.value);\n                } catch (e) {\n                    return;\n                }\n\n                if (tokens.length !== 1) {\n                    return;\n                }\n\n                const isKeywordToken = isKeyword(tokens[0].value);\n\n                if (isKeywordToken && KEYWORDS) {\n                    return;\n                }\n\n                if (CHECK_UNNECESSARY && areQuotesRedundant(key.value, tokens, NUMBERS)) {\n                    context.report({\n                        node,\n                        message: MESSAGE_UNNECESSARY,\n                        data: { property: key.value },\n                        fix: fixer => fixer.replaceText(key, getUnquotedKey(key))\n                    });\n                }\n            } else if (KEYWORDS && key.type === \"Identifier\" && isKeyword(key.name)) {\n                context.report({\n                    node,\n                    message: MESSAGE_RESERVED,\n                    data: { property: key.name },\n                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n                });\n            } else if (NUMBERS && key.type === \"Literal\" && typeof key.value === \"number\") {\n                context.report({\n                    node,\n                    message: MESSAGE_NUMERIC,\n                    data: { property: key.value },\n                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n                });\n            }\n        }\n\n        /**\n         * Ensures that a property's key is quoted\n         * @param   {ASTNode} node Property AST node\n         * @returns {void}\n         */\n        function checkOmittedQuotes(node) {\n            const key = node.key;\n\n            if (!node.method && !node.computed && !node.shorthand && !(key.type === \"Literal\" && typeof key.value === \"string\")) {\n                context.report({\n                    node,\n                    message: MESSAGE_UNQUOTED,\n                    data: { property: key.name || key.value },\n                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n                });\n            }\n        }\n\n        /**\n         * Ensures that an object's keys are consistently quoted, optionally checks for redundancy of quotes\n         * @param   {ASTNode} node Property AST node\n         * @param   {boolean} checkQuotesRedundancy Whether to check quotes' redundancy\n         * @returns {void}\n         */\n        function checkConsistency(node, checkQuotesRedundancy) {\n            const quotedProps = [],\n                unquotedProps = [];\n            let keywordKeyName = null,\n                necessaryQuotes = false;\n\n            node.properties.forEach(property => {\n                const key = property.key;\n\n                if (!key || property.method || property.computed || property.shorthand) {\n                    return;\n                }\n\n                if (key.type === \"Literal\" && typeof key.value === \"string\") {\n\n                    quotedProps.push(property);\n\n                    if (checkQuotesRedundancy) {\n                        let tokens;\n\n                        try {\n                            tokens = espree.tokenize(key.value);\n                        } catch (e) {\n                            necessaryQuotes = true;\n                            return;\n                        }\n\n                        necessaryQuotes = necessaryQuotes || !areQuotesRedundant(key.value, tokens) || KEYWORDS && isKeyword(tokens[0].value);\n                    }\n                } else if (KEYWORDS && checkQuotesRedundancy && key.type === \"Identifier\" && isKeyword(key.name)) {\n                    unquotedProps.push(property);\n                    necessaryQuotes = true;\n                    keywordKeyName = key.name;\n                } else {\n                    unquotedProps.push(property);\n                }\n            });\n\n            if (checkQuotesRedundancy && quotedProps.length && !necessaryQuotes) {\n                quotedProps.forEach(property => {\n                    context.report({\n                        node: property,\n                        message: \"Properties shouldn't be quoted as all quotes are redundant.\",\n                        fix: fixer => fixer.replaceText(property.key, getUnquotedKey(property.key))\n                    });\n                });\n            } else if (unquotedProps.length && keywordKeyName) {\n                unquotedProps.forEach(property => {\n                    context.report({\n                        node: property,\n                        message: \"Properties should be quoted as '{{property}}' is a reserved word.\",\n                        data: { property: keywordKeyName },\n                        fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))\n                    });\n                });\n            } else if (quotedProps.length && unquotedProps.length) {\n                unquotedProps.forEach(property => {\n                    context.report({\n                        node: property,\n                        message: \"Inconsistently quoted property '{{key}}' found.\",\n                        data: { key: property.key.name || property.key.value },\n                        fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))\n                    });\n                });\n            }\n        }\n\n        return {\n            Property(node) {\n                if (MODE === \"always\" || !MODE) {\n                    checkOmittedQuotes(node);\n                }\n                if (MODE === \"as-needed\") {\n                    checkUnnecessaryQuotes(node);\n                }\n            },\n            ObjectExpression(node) {\n                if (MODE === \"consistent\") {\n                    checkConsistency(node, false);\n                }\n                if (MODE === \"consistent-as-needed\") {\n                    checkConsistency(node, true);\n                }\n            }\n        };\n\n    }\n};\n","quotes.js":"/**\n * @fileoverview A rule to choose between single and double quote marks\n * @author Matt DuVall <http://www.mattduvall.com/>, Brandon Payton\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst QUOTE_SETTINGS = {\n    double: {\n        quote: \"\\\"\",\n        alternateQuote: \"'\",\n        description: \"doublequote\"\n    },\n    single: {\n        quote: \"'\",\n        alternateQuote: \"\\\"\",\n        description: \"singlequote\"\n    },\n    backtick: {\n        quote: \"`\",\n        alternateQuote: \"\\\"\",\n        description: \"backtick\"\n    }\n};\n\n// An unescaped newline is a newline preceded by an even number of backslashes.\nconst UNESCAPED_LINEBREAK_PATTERN = new RegExp(String.raw`(^|[^\\\\])(\\\\\\\\)*[${Array.from(astUtils.LINEBREAKS).join(\"\")}]`);\n\n/**\n * Switches quoting of javascript string between ' \" and `\n * escaping and unescaping as necessary.\n * Only escaping of the minimal set of characters is changed.\n * Note: escaping of newlines when switching from backtick to other quotes is not handled.\n * @param {string} str - A string to convert.\n * @returns {string} The string with changed quotes.\n * @private\n */\nQUOTE_SETTINGS.double.convert =\nQUOTE_SETTINGS.single.convert =\nQUOTE_SETTINGS.backtick.convert = function(str) {\n    const newQuote = this.quote;\n    const oldQuote = str[0];\n\n    if (newQuote === oldQuote) {\n        return str;\n    }\n    return newQuote + str.slice(1, -1).replace(/\\\\(\\${|\\r\\n?|\\n|.)|[\"'`]|\\${|(\\r\\n?|\\n)/g, (match, escaped, newline) => {\n        if (escaped === oldQuote || oldQuote === \"`\" && escaped === \"${\") {\n            return escaped; // unescape\n        }\n        if (match === newQuote || newQuote === \"`\" && match === \"${\") {\n            return `\\\\${match}`; // escape\n        }\n        if (newline && oldQuote === \"`\") {\n            return \"\\\\n\"; // escape newlines\n        }\n        return match;\n    }) + newQuote;\n};\n\nconst AVOID_ESCAPE = \"avoid-escape\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce the consistent use of either backticks, double, or single quotes\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                enum: [\"single\", \"double\", \"backtick\"]\n            },\n            {\n                anyOf: [\n                    {\n                        enum: [\"avoid-escape\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            avoidEscape: {\n                                type: \"boolean\"\n                            },\n                            allowTemplateLiterals: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n\n        const quoteOption = context.options[0],\n            settings = QUOTE_SETTINGS[quoteOption || \"double\"],\n            options = context.options[1],\n            allowTemplateLiterals = options && options.allowTemplateLiterals === true,\n            sourceCode = context.getSourceCode();\n        let avoidEscape = options && options.avoidEscape === true;\n\n        // deprecated\n        if (options === AVOID_ESCAPE) {\n            avoidEscape = true;\n        }\n\n        /**\n         * Determines if a given node is part of JSX syntax.\n         *\n         * This function returns `true` in the following cases:\n         *\n         * - `<div className=\"foo\"></div>` ... If the literal is an attribute value, the parent of the literal is `JSXAttribute`.\n         * - `<div>foo</div>` ... If the literal is a text content, the parent of the literal is `JSXElement`.\n         *\n         * In particular, this function returns `false` in the following cases:\n         *\n         * - `<div className={\"foo\"}></div>`\n         * - `<div>{\"foo\"}</div>`\n         *\n         * In both cases, inside of the braces is handled as normal JavaScript.\n         * The braces are `JSXExpressionContainer` nodes.\n         *\n         * @param {ASTNode} node The Literal node to check.\n         * @returns {boolean} True if the node is a part of JSX, false if not.\n         * @private\n         */\n        function isJSXLiteral(node) {\n            return node.parent.type === \"JSXAttribute\" || node.parent.type === \"JSXElement\";\n        }\n\n        /**\n         * Checks whether or not a given node is a directive.\n         * The directive is a `ExpressionStatement` which has only a string literal.\n         * @param {ASTNode} node - A node to check.\n         * @returns {boolean} Whether or not the node is a directive.\n         * @private\n         */\n        function isDirective(node) {\n            return (\n                node.type === \"ExpressionStatement\" &&\n                node.expression.type === \"Literal\" &&\n                typeof node.expression.value === \"string\"\n            );\n        }\n\n        /**\n         * Checks whether or not a given node is a part of directive prologues.\n         * See also: http://www.ecma-international.org/ecma-262/6.0/#sec-directive-prologues-and-the-use-strict-directive\n         * @param {ASTNode} node - A node to check.\n         * @returns {boolean} Whether or not the node is a part of directive prologues.\n         * @private\n         */\n        function isPartOfDirectivePrologue(node) {\n            const block = node.parent.parent;\n\n            if (block.type !== \"Program\" && (block.type !== \"BlockStatement\" || !astUtils.isFunction(block.parent))) {\n                return false;\n            }\n\n            // Check the node is at a prologue.\n            for (let i = 0; i < block.body.length; ++i) {\n                const statement = block.body[i];\n\n                if (statement === node.parent) {\n                    return true;\n                }\n                if (!isDirective(statement)) {\n                    break;\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks whether or not a given node is allowed as non backtick.\n         * @param {ASTNode} node - A node to check.\n         * @returns {boolean} Whether or not the node is allowed as non backtick.\n         * @private\n         */\n        function isAllowedAsNonBacktick(node) {\n            const parent = node.parent;\n\n            switch (parent.type) {\n\n                // Directive Prologues.\n                case \"ExpressionStatement\":\n                    return isPartOfDirectivePrologue(node);\n\n                // LiteralPropertyName.\n                case \"Property\":\n                case \"MethodDefinition\":\n                    return parent.key === node && !parent.computed;\n\n                // ModuleSpecifier.\n                case \"ImportDeclaration\":\n                case \"ExportNamedDeclaration\":\n                case \"ExportAllDeclaration\":\n                    return parent.source === node;\n\n                // Others don't allow.\n                default:\n                    return false;\n            }\n        }\n\n        return {\n\n            Literal(node) {\n                const val = node.value,\n                    rawVal = node.raw;\n\n                if (settings && typeof val === \"string\") {\n                    let isValid = (quoteOption === \"backtick\" && isAllowedAsNonBacktick(node)) ||\n                        isJSXLiteral(node) ||\n                        astUtils.isSurroundedBy(rawVal, settings.quote);\n\n                    if (!isValid && avoidEscape) {\n                        isValid = astUtils.isSurroundedBy(rawVal, settings.alternateQuote) && rawVal.indexOf(settings.quote) >= 0;\n                    }\n\n                    if (!isValid) {\n                        context.report({\n                            node,\n                            message: \"Strings must use {{description}}.\",\n                            data: {\n                                description: settings.description\n                            },\n                            fix(fixer) {\n                                return fixer.replaceText(node, settings.convert(node.raw));\n                            }\n                        });\n                    }\n                }\n            },\n\n            TemplateLiteral(node) {\n\n                // If backticks are expected or it's a tagged template, then this shouldn't throw an errors\n                if (\n                    allowTemplateLiterals ||\n                    quoteOption === \"backtick\" ||\n                    node.parent.type === \"TaggedTemplateExpression\" && node === node.parent.quasi\n                ) {\n                    return;\n                }\n\n                // A warning should be produced if the template literal only has one TemplateElement, and has no unescaped newlines.\n                const shouldWarn = node.quasis.length === 1 && !UNESCAPED_LINEBREAK_PATTERN.test(node.quasis[0].value.raw);\n\n                if (shouldWarn) {\n                    context.report({\n                        node,\n                        message: \"Strings must use {{description}}.\",\n                        data: {\n                            description: settings.description\n                        },\n                        fix(fixer) {\n                            if (isPartOfDirectivePrologue(node)) {\n\n                                /*\n                                 * TemplateLiterals in a directive prologue aren't actually directives, but if they're\n                                 * in the directive prologue, then fixing them might turn them into directives and change\n                                 * the behavior of the code.\n                                 */\n                                return null;\n                            }\n                            return fixer.replaceText(node, settings.convert(sourceCode.getText(node)));\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","radix.js":"/**\n * @fileoverview Rule to flag use of parseInt without a radix argument\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst MODE_ALWAYS = \"always\",\n    MODE_AS_NEEDED = \"as-needed\";\n\n/**\n * Checks whether a given variable is shadowed or not.\n *\n * @param {eslint-scope.Variable} variable - A variable to check.\n * @returns {boolean} `true` if the variable is shadowed.\n */\nfunction isShadowed(variable) {\n    return variable.defs.length >= 1;\n}\n\n/**\n * Checks whether a given node is a MemberExpression of `parseInt` method or not.\n *\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is a MemberExpression of `parseInt`\n *      method.\n */\nfunction isParseIntMethod(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        !node.computed &&\n        node.property.type === \"Identifier\" &&\n        node.property.name === \"parseInt\"\n    );\n}\n\n/**\n * Checks whether a given node is a valid value of radix or not.\n *\n * The following values are invalid.\n *\n * - A literal except numbers.\n * - undefined.\n *\n * @param {ASTNode} radix - A node of radix to check.\n * @returns {boolean} `true` if the node is valid.\n */\nfunction isValidRadix(radix) {\n    return !(\n        (radix.type === \"Literal\" && typeof radix.value !== \"number\") ||\n        (radix.type === \"Identifier\" && radix.name === \"undefined\")\n    );\n}\n\n/**\n * Checks whether a given node is a default value of radix or not.\n *\n * @param {ASTNode} radix - A node of radix to check.\n * @returns {boolean} `true` if the node is the literal node of `10`.\n */\nfunction isDefaultRadix(radix) {\n    return radix.type === \"Literal\" && radix.value === 10;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce the consistent use of the radix argument when using `parseInt()`\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"as-needed\"]\n            }\n        ]\n    },\n\n    create(context) {\n        const mode = context.options[0] || MODE_ALWAYS;\n\n        /**\n         * Checks the arguments of a given CallExpression node and reports it if it\n         * offends this rule.\n         *\n         * @param {ASTNode} node - A CallExpression node to check.\n         * @returns {void}\n         */\n        function checkArguments(node) {\n            const args = node.arguments;\n\n            switch (args.length) {\n                case 0:\n                    context.report({\n                        node,\n                        message: \"Missing parameters.\"\n                    });\n                    break;\n\n                case 1:\n                    if (mode === MODE_ALWAYS) {\n                        context.report({\n                            node,\n                            message: \"Missing radix parameter.\"\n                        });\n                    }\n                    break;\n\n                default:\n                    if (mode === MODE_AS_NEEDED && isDefaultRadix(args[1])) {\n                        context.report({\n                            node,\n                            message: \"Redundant radix parameter.\"\n                        });\n                    } else if (!isValidRadix(args[1])) {\n                        context.report({\n                            node,\n                            message: \"Invalid radix parameter.\"\n                        });\n                    }\n                    break;\n            }\n        }\n\n        return {\n            \"Program:exit\"() {\n                const scope = context.getScope();\n                let variable;\n\n                // Check `parseInt()`\n                variable = astUtils.getVariableByName(scope, \"parseInt\");\n                if (!isShadowed(variable)) {\n                    variable.references.forEach(reference => {\n                        const node = reference.identifier;\n\n                        if (astUtils.isCallee(node)) {\n                            checkArguments(node.parent);\n                        }\n                    });\n                }\n\n                // Check `Number.parseInt()`\n                variable = astUtils.getVariableByName(scope, \"Number\");\n                if (!isShadowed(variable)) {\n                    variable.references.forEach(reference => {\n                        const node = reference.identifier.parent;\n\n                        if (isParseIntMethod(node) && astUtils.isCallee(node)) {\n                            checkArguments(node.parent);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","require-await.js":"/**\n * @fileoverview Rule to disallow async functions which have no `await` expression.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Capitalize the 1st letter of the given text.\n *\n * @param {string} text - The text to capitalize.\n * @returns {string} The text that the 1st letter was capitalized.\n */\nfunction capitalizeFirstLetter(text) {\n    return text[0].toUpperCase() + text.slice(1);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow async functions which have no `await` expression\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        let scopeInfo = null;\n\n        /**\n         * Push the scope info object to the stack.\n         *\n         * @returns {void}\n         */\n        function enterFunction() {\n            scopeInfo = {\n                upper: scopeInfo,\n                hasAwait: false\n            };\n        }\n\n        /**\n         * Pop the top scope info object from the stack.\n         * Also, it reports the function if needed.\n         *\n         * @param {ASTNode} node - The node to report.\n         * @returns {void}\n         */\n        function exitFunction(node) {\n            if (node.async && !scopeInfo.hasAwait && !astUtils.isEmptyFunction(node)) {\n                context.report({\n                    node,\n                    loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n                    message: \"{{name}} has no 'await' expression.\",\n                    data: {\n                        name: capitalizeFirstLetter(\n                            astUtils.getFunctionNameWithKind(node)\n                        )\n                    }\n                });\n            }\n\n            scopeInfo = scopeInfo.upper;\n        }\n\n        return {\n            FunctionDeclaration: enterFunction,\n            FunctionExpression: enterFunction,\n            ArrowFunctionExpression: enterFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            \"FunctionExpression:exit\": exitFunction,\n            \"ArrowFunctionExpression:exit\": exitFunction,\n\n            AwaitExpression() {\n                scopeInfo.hasAwait = true;\n            }\n        };\n    }\n};\n","require-jsdoc.js":"/**\n * @fileoverview Rule to check for jsdoc presence.\n * @author Gyandeep Singh\n */\n\"use strict\";\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require JSDoc comments\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    require: {\n                        type: \"object\",\n                        properties: {\n                            ClassDeclaration: {\n                                type: \"boolean\"\n                            },\n                            MethodDefinition: {\n                                type: \"boolean\"\n                            },\n                            FunctionDeclaration: {\n                                type: \"boolean\"\n                            },\n                            ArrowFunctionExpression: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const source = context.getSourceCode();\n        const DEFAULT_OPTIONS = {\n            FunctionDeclaration: true,\n            MethodDefinition: false,\n            ClassDeclaration: false\n        };\n        const options = Object.assign(DEFAULT_OPTIONS, context.options[0] && context.options[0].require || {});\n\n        /**\n         * Report the error message\n         * @param {ASTNode} node node to report\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({ node, message: \"Missing JSDoc comment.\" });\n        }\n\n        /**\n         * Check if the jsdoc comment is present for class methods\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function checkClassMethodJsDoc(node) {\n            if (node.parent.type === \"MethodDefinition\") {\n                const jsdocComment = source.getJSDocComment(node);\n\n                if (!jsdocComment) {\n                    report(node);\n                }\n            }\n        }\n\n        /**\n         * Check if the jsdoc comment is present or not.\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function checkJsDoc(node) {\n            const jsdocComment = source.getJSDocComment(node);\n\n            if (!jsdocComment) {\n                report(node);\n            }\n        }\n\n        return {\n            FunctionDeclaration(node) {\n                if (options.FunctionDeclaration) {\n                    checkJsDoc(node);\n                }\n            },\n            FunctionExpression(node) {\n                if (options.MethodDefinition) {\n                    checkClassMethodJsDoc(node);\n                }\n            },\n            ClassDeclaration(node) {\n                if (options.ClassDeclaration) {\n                    checkJsDoc(node);\n                }\n            },\n            ArrowFunctionExpression(node) {\n                if (options.ArrowFunctionExpression && node.parent.type === \"VariableDeclarator\") {\n                    checkJsDoc(node);\n                }\n            }\n        };\n    }\n};\n","require-yield.js":"/**\n * @fileoverview Rule to flag the generator functions that does not have yield.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require generator functions to contain `yield`\",\n            category: \"ECMAScript 6\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const stack = [];\n\n        /**\n         * If the node is a generator function, start counting `yield` keywords.\n         * @param {Node} node - A function node to check.\n         * @returns {void}\n         */\n        function beginChecking(node) {\n            if (node.generator) {\n                stack.push(0);\n            }\n        }\n\n        /**\n         * If the node is a generator function, end counting `yield` keywords, then\n         * reports result.\n         * @param {Node} node - A function node to check.\n         * @returns {void}\n         */\n        function endChecking(node) {\n            if (!node.generator) {\n                return;\n            }\n\n            const countYield = stack.pop();\n\n            if (countYield === 0 && node.body.body.length > 0) {\n                context.report({ node, message: \"This generator function does not have 'yield'.\" });\n            }\n        }\n\n        return {\n            FunctionDeclaration: beginChecking,\n            \"FunctionDeclaration:exit\": endChecking,\n            FunctionExpression: beginChecking,\n            \"FunctionExpression:exit\": endChecking,\n\n            // Increases the count of `yield` keyword.\n            YieldExpression() {\n\n                /* istanbul ignore else */\n                if (stack.length > 0) {\n                    stack[stack.length - 1] += 1;\n                }\n            }\n        };\n    }\n};\n","rest-spread-spacing.js":"/**\n * @fileoverview Enforce spacing between rest and spread operators and their expressions.\n * @author Kai Cataldo\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce spacing between rest and spread operators and their expressions\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n        fixable: \"whitespace\",\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode(),\n            alwaysSpace = context.options[0] === \"always\";\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Checks whitespace between rest/spread operators and their expressions\n         * @param {ASTNode} node - The node to check\n         * @returns {void}\n         */\n        function checkWhiteSpace(node) {\n            const operator = sourceCode.getFirstToken(node),\n                nextToken = sourceCode.getTokenAfter(operator),\n                hasWhitespace = sourceCode.isSpaceBetweenTokens(operator, nextToken);\n            let type;\n\n            switch (node.type) {\n                case \"SpreadElement\":\n                    type = \"spread\";\n                    break;\n                case \"RestElement\":\n                    type = \"rest\";\n                    break;\n                case \"ExperimentalSpreadProperty\":\n                    type = \"spread property\";\n                    break;\n                case \"ExperimentalRestProperty\":\n                    type = \"rest property\";\n                    break;\n                default:\n                    return;\n            }\n\n            if (alwaysSpace && !hasWhitespace) {\n                context.report({\n                    node,\n                    loc: {\n                        line: operator.loc.end.line,\n                        column: operator.loc.end.column\n                    },\n                    message: \"Expected whitespace after {{type}} operator.\",\n                    data: {\n                        type\n                    },\n                    fix(fixer) {\n                        return fixer.replaceTextRange([operator.range[1], nextToken.range[0]], \" \");\n                    }\n                });\n            } else if (!alwaysSpace && hasWhitespace) {\n                context.report({\n                    node,\n                    loc: {\n                        line: operator.loc.end.line,\n                        column: operator.loc.end.column\n                    },\n                    message: \"Unexpected whitespace after {{type}} operator.\",\n                    data: {\n                        type\n                    },\n                    fix(fixer) {\n                        return fixer.removeRange([operator.range[1], nextToken.range[0]]);\n                    }\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            SpreadElement: checkWhiteSpace,\n            RestElement: checkWhiteSpace,\n            ExperimentalSpreadProperty: checkWhiteSpace,\n            ExperimentalRestProperty: checkWhiteSpace\n        };\n    }\n};\n","semi-spacing.js":"/**\n * @fileoverview Validates spacing before and after semicolon\n * @author Mathias Schreck\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing before and after semicolons\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: {\n                        type: \"boolean\"\n                    },\n                    after: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const config = context.options[0],\n            sourceCode = context.getSourceCode();\n        let requireSpaceBefore = false,\n            requireSpaceAfter = true;\n\n        if (typeof config === \"object\") {\n            if (config.hasOwnProperty(\"before\")) {\n                requireSpaceBefore = config.before;\n            }\n            if (config.hasOwnProperty(\"after\")) {\n                requireSpaceAfter = config.after;\n            }\n        }\n\n        /**\n         * Checks if a given token has leading whitespace.\n         * @param {Object} token The token to check.\n         * @returns {boolean} True if the given token has leading space, false if not.\n         */\n        function hasLeadingSpace(token) {\n            const tokenBefore = sourceCode.getTokenBefore(token);\n\n            return tokenBefore && astUtils.isTokenOnSameLine(tokenBefore, token) && sourceCode.isSpaceBetweenTokens(tokenBefore, token);\n        }\n\n        /**\n         * Checks if a given token has trailing whitespace.\n         * @param {Object} token The token to check.\n         * @returns {boolean} True if the given token has trailing space, false if not.\n         */\n        function hasTrailingSpace(token) {\n            const tokenAfter = sourceCode.getTokenAfter(token);\n\n            return tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter) && sourceCode.isSpaceBetweenTokens(token, tokenAfter);\n        }\n\n        /**\n         * Checks if the given token is the last token in its line.\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the token is the last in its line.\n         */\n        function isLastTokenInCurrentLine(token) {\n            const tokenAfter = sourceCode.getTokenAfter(token);\n\n            return !(tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter));\n        }\n\n        /**\n         * Checks if the given token is the first token in its line\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the token is the first in its line.\n         */\n        function isFirstTokenInCurrentLine(token) {\n            const tokenBefore = sourceCode.getTokenBefore(token);\n\n            return !(tokenBefore && astUtils.isTokenOnSameLine(token, tokenBefore));\n        }\n\n        /**\n         * Checks if the next token of a given token is a closing parenthesis.\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the next token of a given token is a closing parenthesis.\n         */\n        function isBeforeClosingParen(token) {\n            const nextToken = sourceCode.getTokenAfter(token);\n\n            return (nextToken && astUtils.isClosingBraceToken(nextToken) || astUtils.isClosingParenToken(nextToken));\n        }\n\n        /**\n         * Reports if the given token has invalid spacing.\n         * @param {Token} token The semicolon token to check.\n         * @param {ASTNode} node The corresponding node of the token.\n         * @returns {void}\n         */\n        function checkSemicolonSpacing(token, node) {\n            if (astUtils.isSemicolonToken(token)) {\n                const location = token.loc.start;\n\n                if (hasLeadingSpace(token)) {\n                    if (!requireSpaceBefore) {\n                        context.report({\n                            node,\n                            loc: location,\n                            message: \"Unexpected whitespace before semicolon.\",\n                            fix(fixer) {\n                                const tokenBefore = sourceCode.getTokenBefore(token);\n\n                                return fixer.removeRange([tokenBefore.range[1], token.range[0]]);\n                            }\n                        });\n                    }\n                } else {\n                    if (requireSpaceBefore) {\n                        context.report({\n                            node,\n                            loc: location,\n                            message: \"Missing whitespace before semicolon.\",\n                            fix(fixer) {\n                                return fixer.insertTextBefore(token, \" \");\n                            }\n                        });\n                    }\n                }\n\n                if (!isFirstTokenInCurrentLine(token) && !isLastTokenInCurrentLine(token) && !isBeforeClosingParen(token)) {\n                    if (hasTrailingSpace(token)) {\n                        if (!requireSpaceAfter) {\n                            context.report({\n                                node,\n                                loc: location,\n                                message: \"Unexpected whitespace after semicolon.\",\n                                fix(fixer) {\n                                    const tokenAfter = sourceCode.getTokenAfter(token);\n\n                                    return fixer.removeRange([token.range[1], tokenAfter.range[0]]);\n                                }\n                            });\n                        }\n                    } else {\n                        if (requireSpaceAfter) {\n                            context.report({\n                                node,\n                                loc: location,\n                                message: \"Missing whitespace after semicolon.\",\n                                fix(fixer) {\n                                    return fixer.insertTextAfter(token, \" \");\n                                }\n                            });\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Checks the spacing of the semicolon with the assumption that the last token is the semicolon.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkNode(node) {\n            const token = sourceCode.getLastToken(node);\n\n            checkSemicolonSpacing(token, node);\n        }\n\n        return {\n            VariableDeclaration: checkNode,\n            ExpressionStatement: checkNode,\n            BreakStatement: checkNode,\n            ContinueStatement: checkNode,\n            DebuggerStatement: checkNode,\n            ReturnStatement: checkNode,\n            ThrowStatement: checkNode,\n            ImportDeclaration: checkNode,\n            ExportNamedDeclaration: checkNode,\n            ExportAllDeclaration: checkNode,\n            ExportDefaultDeclaration: checkNode,\n            ForStatement(node) {\n                if (node.init) {\n                    checkSemicolonSpacing(sourceCode.getTokenAfter(node.init), node);\n                }\n\n                if (node.test) {\n                    checkSemicolonSpacing(sourceCode.getTokenAfter(node.test), node);\n                }\n            }\n        };\n    }\n};\n","semi-style.js":"/**\n * @fileoverview Rule to enforce location of semicolons.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst SELECTOR = `:matches(${\n    [\n        \"BreakStatement\", \"ContinueStatement\", \"DebuggerStatement\",\n        \"DoWhileStatement\", \"EmptyStatement\", \"ExportAllDeclaration\",\n        \"ExportDefaultDeclaration\", \"ExportNamedDeclaration\",\n        \"ExpressionStatement\", \"ImportDeclaration\", \"ReturnStatement\",\n        \"ThrowStatement\", \"VariableDeclaration\"\n    ].join(\",\")\n})`;\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce location of semicolons\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        schema: [{ enum: [\"last\", \"first\"] }],\n        fixable: \"whitespace\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const option = context.options[0] || \"last\";\n\n        /**\n         * Check whether comments exist between the given 2 tokens.\n         * @param {Token} left The left token to check.\n         * @param {Token} right The right token to check.\n         * @returns {boolean} `true` if comments exist between the given 2 tokens.\n         */\n        function commentsExistBetween(left, right) {\n            return sourceCode.getFirstTokenBetween(\n                left,\n                right,\n                {\n                    includeComments: true,\n                    filter: astUtils.isCommentToken\n                }\n            ) !== null;\n        }\n\n        /**\n         * Check the given semicolon token.\n         * @param {Token} semiToken The semicolon token to check.\n         * @param {\"first\"|\"last\"} expected The expected location to check.\n         * @returns {void}\n         */\n        function check(semiToken, expected) {\n            const prevToken = sourceCode.getTokenBefore(semiToken);\n            const nextToken = sourceCode.getTokenAfter(semiToken);\n            const prevIsSameLine = !prevToken || astUtils.isTokenOnSameLine(prevToken, semiToken);\n            const nextIsSameLine = !nextToken || astUtils.isTokenOnSameLine(semiToken, nextToken);\n\n            if ((expected === \"last\" && !prevIsSameLine) || (expected === \"first\" && !nextIsSameLine)) {\n                context.report({\n                    loc: semiToken.loc,\n                    message: \"Expected this semicolon to be at {{pos}}.\",\n                    data: {\n                        pos: (expected === \"last\")\n                            ? \"the end of the previous line\"\n                            : \"the beginning of the next line\"\n                    },\n                    fix(fixer) {\n                        if (prevToken && nextToken && commentsExistBetween(prevToken, nextToken)) {\n                            return null;\n                        }\n\n                        const start = prevToken ? prevToken.range[1] : semiToken.range[0];\n                        const end = nextToken ? nextToken.range[0] : semiToken.range[1];\n                        const text = (expected === \"last\") ? \";\\n\" : \"\\n;\";\n\n                        return fixer.replaceTextRange([start, end], text);\n                    }\n                });\n            }\n        }\n\n        return {\n            [SELECTOR](node) {\n                const lastToken = sourceCode.getLastToken(node);\n\n                if (astUtils.isSemicolonToken(lastToken)) {\n                    check(lastToken, option);\n                }\n            },\n\n            ForStatement(node) {\n                const firstSemi = node.init && sourceCode.getTokenAfter(node.init, astUtils.isSemicolonToken);\n                const secondSemi = node.test && sourceCode.getTokenAfter(node.test, astUtils.isSemicolonToken);\n\n                if (firstSemi) {\n                    check(firstSemi, \"last\");\n                }\n                if (secondSemi) {\n                    check(secondSemi, \"last\");\n                }\n            }\n        };\n    }\n};\n","semi.js":"/**\n * @fileoverview Rule to flag missing semicolons.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst FixTracker = require(\"../util/fix-tracker\");\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow semicolons instead of ASI\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"code\",\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"never\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                omitLastInOneLineBlock: { type: \"boolean\" }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        }\n    },\n\n    create(context) {\n\n        const OPT_OUT_PATTERN = /^[-[(/+`]/; // One of [(/+-`\n        const options = context.options[1];\n        const never = context.options[0] === \"never\",\n            exceptOneLine = options && options.omitLastInOneLineBlock === true,\n            sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Reports a semicolon error with appropriate location and message.\n         * @param {ASTNode} node The node with an extra or missing semicolon.\n         * @param {boolean} missing True if the semicolon is missing.\n         * @returns {void}\n         */\n        function report(node, missing) {\n            const lastToken = sourceCode.getLastToken(node);\n            let message,\n                fix,\n                loc = lastToken.loc;\n\n            if (!missing) {\n                message = \"Missing semicolon.\";\n                loc = loc.end;\n                fix = function(fixer) {\n                    return fixer.insertTextAfter(lastToken, \";\");\n                };\n            } else {\n                message = \"Extra semicolon.\";\n                loc = loc.start;\n                fix = function(fixer) {\n\n                    // Expand the replacement range to include the surrounding\n                    // tokens to avoid conflicting with no-extra-semi.\n                    // https://github.com/eslint/eslint/issues/7928\n                    return new FixTracker(fixer, sourceCode)\n                        .retainSurroundingTokens(lastToken)\n                        .remove(lastToken);\n                };\n            }\n\n            context.report({\n                node,\n                loc,\n                message,\n                fix\n            });\n\n        }\n\n        /**\n         * Check if a semicolon is unnecessary, only true if:\n         *   - next token is on a new line and is not one of the opt-out tokens\n         *   - next token is a valid statement divider\n         * @param {Token} lastToken last token of current node.\n         * @returns {boolean} whether the semicolon is unnecessary.\n         */\n        function isUnnecessarySemicolon(lastToken) {\n            if (!astUtils.isSemicolonToken(lastToken)) {\n                return false;\n            }\n\n            const nextToken = sourceCode.getTokenAfter(lastToken);\n\n            if (!nextToken) {\n                return true;\n            }\n\n            const lastTokenLine = lastToken.loc.end.line;\n            const nextTokenLine = nextToken.loc.start.line;\n            const isOptOutToken = OPT_OUT_PATTERN.test(nextToken.value) && nextToken.value !== \"++\" && nextToken.value !== \"--\";\n            const isDivider = (astUtils.isClosingBraceToken(nextToken) || astUtils.isSemicolonToken(nextToken));\n\n            return (lastTokenLine !== nextTokenLine && !isOptOutToken) || isDivider;\n        }\n\n        /**\n         * Checks a node to see if it's in a one-liner block statement.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} whether the node is in a one-liner block statement.\n         */\n        function isOneLinerBlock(node) {\n            const nextToken = sourceCode.getTokenAfter(node);\n\n            if (!nextToken || nextToken.value !== \"}\") {\n                return false;\n            }\n\n            const parent = node.parent;\n\n            return parent && parent.type === \"BlockStatement\" &&\n              parent.loc.start.line === parent.loc.end.line;\n        }\n\n        /**\n         * Checks a node to see if it's followed by a semicolon.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkForSemicolon(node) {\n            const lastToken = sourceCode.getLastToken(node);\n\n            if (never) {\n                if (isUnnecessarySemicolon(lastToken)) {\n                    report(node, true);\n                }\n            } else {\n                if (!astUtils.isSemicolonToken(lastToken)) {\n                    if (!exceptOneLine || !isOneLinerBlock(node)) {\n                        report(node);\n                    }\n                } else {\n                    if (exceptOneLine && isOneLinerBlock(node)) {\n                        report(node, true);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Checks to see if there's a semicolon after a variable declaration.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkForSemicolonForVariableDeclaration(node) {\n            const ancestors = context.getAncestors(),\n                parentIndex = ancestors.length - 1,\n                parent = ancestors[parentIndex];\n\n            if ((parent.type !== \"ForStatement\" || parent.init !== node) &&\n                (!/^For(?:In|Of)Statement/.test(parent.type) || parent.left !== node)\n            ) {\n                checkForSemicolon(node);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclaration: checkForSemicolonForVariableDeclaration,\n            ExpressionStatement: checkForSemicolon,\n            ReturnStatement: checkForSemicolon,\n            ThrowStatement: checkForSemicolon,\n            DoWhileStatement: checkForSemicolon,\n            DebuggerStatement: checkForSemicolon,\n            BreakStatement: checkForSemicolon,\n            ContinueStatement: checkForSemicolon,\n            ImportDeclaration: checkForSemicolon,\n            ExportAllDeclaration: checkForSemicolon,\n            ExportNamedDeclaration(node) {\n                if (!node.declaration) {\n                    checkForSemicolon(node);\n                }\n            },\n            ExportDefaultDeclaration(node) {\n                if (!/(?:Class|Function)Declaration/.test(node.declaration.type)) {\n                    checkForSemicolon(node);\n                }\n            }\n        };\n\n    }\n};\n","sort-imports.js":"/**\n * @fileoverview Rule to require sorting of import declarations\n * @author Christian Schuller\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce sorted import declarations within modules\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreCase: {\n                        type: \"boolean\"\n                    },\n                    memberSyntaxSortOrder: {\n                        type: \"array\",\n                        items: {\n                            enum: [\"none\", \"all\", \"multiple\", \"single\"]\n                        },\n                        uniqueItems: true,\n                        minItems: 4,\n                        maxItems: 4\n                    },\n                    ignoreMemberSort: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        const configuration = context.options[0] || {},\n            ignoreCase = configuration.ignoreCase || false,\n            ignoreMemberSort = configuration.ignoreMemberSort || false,\n            memberSyntaxSortOrder = configuration.memberSyntaxSortOrder || [\"none\", \"all\", \"multiple\", \"single\"],\n            sourceCode = context.getSourceCode();\n        let previousDeclaration = null;\n\n        /**\n         * Gets the used member syntax style.\n         *\n         * import \"my-module.js\" --> none\n         * import * as myModule from \"my-module.js\" --> all\n         * import {myMember} from \"my-module.js\" --> single\n         * import {foo, bar} from  \"my-module.js\" --> multiple\n         *\n         * @param {ASTNode} node - the ImportDeclaration node.\n         * @returns {string} used member parameter style, [\"all\", \"multiple\", \"single\"]\n         */\n        function usedMemberSyntax(node) {\n            if (node.specifiers.length === 0) {\n                return \"none\";\n            } else if (node.specifiers[0].type === \"ImportNamespaceSpecifier\") {\n                return \"all\";\n            } else if (node.specifiers.length === 1) {\n                return \"single\";\n            }\n            return \"multiple\";\n\n        }\n\n        /**\n         * Gets the group by member parameter index for given declaration.\n         * @param {ASTNode} node - the ImportDeclaration node.\n         * @returns {number} the declaration group by member index.\n         */\n        function getMemberParameterGroupIndex(node) {\n            return memberSyntaxSortOrder.indexOf(usedMemberSyntax(node));\n        }\n\n        /**\n         * Gets the local name of the first imported module.\n         * @param {ASTNode} node - the ImportDeclaration node.\n         * @returns {?string} the local name of the first imported module.\n         */\n        function getFirstLocalMemberName(node) {\n            if (node.specifiers[0]) {\n                return node.specifiers[0].local.name;\n            }\n            return null;\n\n        }\n\n        return {\n            ImportDeclaration(node) {\n                if (previousDeclaration) {\n                    const currentMemberSyntaxGroupIndex = getMemberParameterGroupIndex(node),\n                        previousMemberSyntaxGroupIndex = getMemberParameterGroupIndex(previousDeclaration);\n                    let currentLocalMemberName = getFirstLocalMemberName(node),\n                        previousLocalMemberName = getFirstLocalMemberName(previousDeclaration);\n\n                    if (ignoreCase) {\n                        previousLocalMemberName = previousLocalMemberName && previousLocalMemberName.toLowerCase();\n                        currentLocalMemberName = currentLocalMemberName && currentLocalMemberName.toLowerCase();\n                    }\n\n                    // When the current declaration uses a different member syntax,\n                    // then check if the ordering is correct.\n                    // Otherwise, make a default string compare (like rule sort-vars to be consistent) of the first used local member name.\n                    if (currentMemberSyntaxGroupIndex !== previousMemberSyntaxGroupIndex) {\n                        if (currentMemberSyntaxGroupIndex < previousMemberSyntaxGroupIndex) {\n                            context.report({\n                                node,\n                                message: \"Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax.\",\n                                data: {\n                                    syntaxA: memberSyntaxSortOrder[currentMemberSyntaxGroupIndex],\n                                    syntaxB: memberSyntaxSortOrder[previousMemberSyntaxGroupIndex]\n                                }\n                            });\n                        }\n                    } else {\n                        if (previousLocalMemberName &&\n                            currentLocalMemberName &&\n                            currentLocalMemberName < previousLocalMemberName\n                        ) {\n                            context.report({\n                                node,\n                                message: \"Imports should be sorted alphabetically.\"\n                            });\n                        }\n                    }\n                }\n\n                if (!ignoreMemberSort) {\n                    const importSpecifiers = node.specifiers.filter(specifier => specifier.type === \"ImportSpecifier\");\n                    const getSortableName = ignoreCase ? specifier => specifier.local.name.toLowerCase() : specifier => specifier.local.name;\n                    const firstUnsortedIndex = importSpecifiers.map(getSortableName).findIndex((name, index, array) => array[index - 1] > name);\n\n                    if (firstUnsortedIndex !== -1) {\n                        context.report({\n                            node: importSpecifiers[firstUnsortedIndex],\n                            message: \"Member '{{memberName}}' of the import declaration should be sorted alphabetically.\",\n                            data: { memberName: importSpecifiers[firstUnsortedIndex].local.name },\n                            fix(fixer) {\n                                if (importSpecifiers.some(specifier => sourceCode.getCommentsBefore(specifier).length || sourceCode.getCommentsAfter(specifier).length)) {\n\n                                    // If there are comments in the ImportSpecifier list, don't rearrange the specifiers.\n                                    return null;\n                                }\n\n                                return fixer.replaceTextRange(\n                                    [importSpecifiers[0].range[0], importSpecifiers[importSpecifiers.length - 1].range[1]],\n                                    importSpecifiers\n\n                                        // Clone the importSpecifiers array to avoid mutating it\n                                        .slice()\n\n                                        // Sort the array into the desired order\n                                        .sort((specifierA, specifierB) => {\n                                            const aName = getSortableName(specifierA);\n                                            const bName = getSortableName(specifierB);\n\n                                            return aName > bName ? 1 : -1;\n                                        })\n\n                                        // Build a string out of the sorted list of import specifiers and the text between the originals\n                                        .reduce((sourceText, specifier, index) => {\n                                            const textAfterSpecifier = index === importSpecifiers.length - 1\n                                                ? \"\"\n                                                : sourceCode.getText().slice(importSpecifiers[index].range[1], importSpecifiers[index + 1].range[0]);\n\n                                            return sourceText + sourceCode.getText(specifier) + textAfterSpecifier;\n                                        }, \"\")\n                                );\n                            }\n                        });\n                    }\n                }\n\n                previousDeclaration = node;\n            }\n        };\n    }\n};\n","sort-keys.js":"/**\n * @fileoverview Rule to require object keys to be sorted\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\"),\n    naturalCompare = require(\"natural-compare\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets the property name of the given `Property` node.\n *\n * - If the property's key is an `Identifier` node, this returns the key's name\n *   whether it's a computed property or not.\n * - If the property has a static name, this returns the static name.\n * - Otherwise, this returns null.\n *\n * @param {ASTNode} node - The `Property` node to get.\n * @returns {string|null} The property name or null.\n * @private\n */\nfunction getPropertyName(node) {\n    return astUtils.getStaticPropertyName(node) || node.key.name || null;\n}\n\n/**\n * Functions which check that the given 2 names are in specific order.\n *\n * Postfix `I` is meant insensitive.\n * Postfix `N` is meant natual.\n *\n * @private\n */\nconst isValidOrders = {\n    asc(a, b) {\n        return a <= b;\n    },\n    ascI(a, b) {\n        return a.toLowerCase() <= b.toLowerCase();\n    },\n    ascN(a, b) {\n        return naturalCompare(a, b) <= 0;\n    },\n    ascIN(a, b) {\n        return naturalCompare(a.toLowerCase(), b.toLowerCase()) <= 0;\n    },\n    desc(a, b) {\n        return isValidOrders.asc(b, a);\n    },\n    descI(a, b) {\n        return isValidOrders.ascI(b, a);\n    },\n    descN(a, b) {\n        return isValidOrders.ascN(b, a);\n    },\n    descIN(a, b) {\n        return isValidOrders.ascIN(b, a);\n    }\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require object keys to be sorted\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        schema: [\n            {\n                enum: [\"asc\", \"desc\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    caseSensitive: {\n                        type: \"boolean\"\n                    },\n                    natural: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        // Parse options.\n        const order = context.options[0] || \"asc\";\n        const options = context.options[1];\n        const insensitive = (options && options.caseSensitive) === false;\n        const natual = Boolean(options && options.natural);\n        const isValidOrder = isValidOrders[\n            order + (insensitive ? \"I\" : \"\") + (natual ? \"N\" : \"\")\n        ];\n\n        // The stack to save the previous property's name for each object literals.\n        let stack = null;\n\n        return {\n            ObjectExpression() {\n                stack = {\n                    upper: stack,\n                    prevName: null\n                };\n            },\n\n            \"ObjectExpression:exit\"() {\n                stack = stack.upper;\n            },\n\n            Property(node) {\n                if (node.parent.type === \"ObjectPattern\") {\n                    return;\n                }\n\n                const prevName = stack.prevName;\n                const thisName = getPropertyName(node);\n\n                stack.prevName = thisName || prevName;\n\n                if (!prevName || !thisName) {\n                    return;\n                }\n\n                if (!isValidOrder(prevName, thisName)) {\n                    context.report({\n                        node,\n                        loc: node.key.loc,\n                        message: \"Expected object keys to be in {{natual}}{{insensitive}}{{order}}ending order. '{{thisName}}' should be before '{{prevName}}'.\",\n                        data: {\n                            thisName,\n                            prevName,\n                            order,\n                            insensitive: insensitive ? \"insensitive \" : \"\",\n                            natual: natual ? \"natural \" : \"\"\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","sort-vars.js":"/**\n * @fileoverview Rule to require sorting of variables within a single Variable Declaration block\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require variables within the same declaration block to be sorted\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreCase: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const configuration = context.options[0] || {},\n            ignoreCase = configuration.ignoreCase || false;\n\n        return {\n            VariableDeclaration(node) {\n                const idDeclarations = node.declarations.filter(decl => decl.id.type === \"Identifier\");\n\n                idDeclarations.slice(1).reduce((memo, decl) => {\n                    let lastVariableName = memo.id.name,\n                        currenVariableName = decl.id.name;\n\n                    if (ignoreCase) {\n                        lastVariableName = lastVariableName.toLowerCase();\n                        currenVariableName = currenVariableName.toLowerCase();\n                    }\n\n                    if (currenVariableName < lastVariableName) {\n                        context.report({ node: decl, message: \"Variables within the same declaration block should be sorted alphabetically.\" });\n                        return memo;\n                    }\n                    return decl;\n\n                }, idDeclarations[0]);\n            }\n        };\n    }\n};\n","space-before-blocks.js":"/**\n * @fileoverview A rule to ensure whitespace before blocks.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing before blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            keywords: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            functions: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            classes: {\n                                enum: [\"always\", \"never\"]\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const config = context.options[0],\n            sourceCode = context.getSourceCode();\n        let checkFunctions = true,\n            checkKeywords = true,\n            checkClasses = true;\n\n        if (typeof config === \"object\") {\n            checkFunctions = config.functions !== \"never\";\n            checkKeywords = config.keywords !== \"never\";\n            checkClasses = config.classes !== \"never\";\n        } else if (config === \"never\") {\n            checkFunctions = false;\n            checkKeywords = false;\n            checkClasses = false;\n        }\n\n        /**\n         * Checks whether or not a given token is an arrow operator (=>) or a keyword\n         * in order to avoid to conflict with `arrow-spacing` and `keyword-spacing`.\n         *\n         * @param {Token} token - A token to check.\n         * @returns {boolean} `true` if the token is an arrow operator.\n         */\n        function isConflicted(token) {\n            return (token.type === \"Punctuator\" && token.value === \"=>\") || token.type === \"Keyword\";\n        }\n\n        /**\n         * Checks the given BlockStatement node has a preceding space if it doesnât start on a new line.\n         * @param {ASTNode|Token} node The AST node of a BlockStatement.\n         * @returns {void} undefined.\n         */\n        function checkPrecedingSpace(node) {\n            const precedingToken = sourceCode.getTokenBefore(node);\n\n            if (precedingToken && !isConflicted(precedingToken) && astUtils.isTokenOnSameLine(precedingToken, node)) {\n                const hasSpace = sourceCode.isSpaceBetweenTokens(precedingToken, node);\n                const parent = context.getAncestors().pop();\n                let requireSpace;\n\n                if (parent.type === \"FunctionExpression\" || parent.type === \"FunctionDeclaration\") {\n                    requireSpace = checkFunctions;\n                } else if (node.type === \"ClassBody\") {\n                    requireSpace = checkClasses;\n                } else {\n                    requireSpace = checkKeywords;\n                }\n\n                if (requireSpace) {\n                    if (!hasSpace) {\n                        context.report({\n                            node,\n                            message: \"Missing space before opening brace.\",\n                            fix(fixer) {\n                                return fixer.insertTextBefore(node, \" \");\n                            }\n                        });\n                    }\n                } else {\n                    if (hasSpace) {\n                        context.report({\n                            node,\n                            message: \"Unexpected space before opening brace.\",\n                            fix(fixer) {\n                                return fixer.removeRange([precedingToken.range[1], node.range[0]]);\n                            }\n                        });\n                    }\n                }\n            }\n        }\n\n        /**\n         * Checks if the CaseBlock of an given SwitchStatement node has a preceding space.\n         * @param {ASTNode} node The node of a SwitchStatement.\n         * @returns {void} undefined.\n         */\n        function checkSpaceBeforeCaseBlock(node) {\n            const cases = node.cases;\n            let openingBrace;\n\n            if (cases.length > 0) {\n                openingBrace = sourceCode.getTokenBefore(cases[0]);\n            } else {\n                openingBrace = sourceCode.getLastToken(node, 1);\n            }\n\n            checkPrecedingSpace(openingBrace);\n        }\n\n        return {\n            BlockStatement: checkPrecedingSpace,\n            ClassBody: checkPrecedingSpace,\n            SwitchStatement: checkSpaceBeforeCaseBlock\n        };\n\n    }\n};\n","space-before-function-paren.js":"/**\n * @fileoverview Rule to validate spacing before function paren.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing before `function` definition opening parenthesis\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            anonymous: {\n                                enum: [\"always\", \"never\", \"ignore\"]\n                            },\n                            named: {\n                                enum: [\"always\", \"never\", \"ignore\"]\n                            },\n                            asyncArrow: {\n                                enum: [\"always\", \"never\", \"ignore\"]\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const baseConfig = typeof context.options[0] === \"string\" ? context.options[0] : \"always\";\n        const overrideConfig = typeof context.options[0] === \"object\" ? context.options[0] : {};\n\n        /**\n         * Determines whether a function has a name.\n         * @param {ASTNode} node The function node.\n         * @returns {boolean} Whether the function has a name.\n         */\n        function isNamedFunction(node) {\n            if (node.id) {\n                return true;\n            }\n\n            const parent = node.parent;\n\n            return parent.type === \"MethodDefinition\" ||\n                (parent.type === \"Property\" &&\n                    (\n                        parent.kind === \"get\" ||\n                        parent.kind === \"set\" ||\n                        parent.method\n                    )\n                );\n        }\n\n        /**\n         * Gets the config for a given function\n         * @param {ASTNode} node The function node\n         * @returns {string} \"always\", \"never\", or \"ignore\"\n         */\n        function getConfigForFunction(node) {\n            if (node.type === \"ArrowFunctionExpression\") {\n\n                // Always ignore non-async functions and arrow functions without parens, e.g. async foo => bar\n                if (node.async && astUtils.isOpeningParenToken(sourceCode.getFirstToken(node, { skip: 1 }))) {\n                    return overrideConfig.asyncArrow || baseConfig;\n                }\n            } else if (isNamedFunction(node)) {\n                return overrideConfig.named || baseConfig;\n\n            // `generator-star-spacing` should warn anonymous generators. E.g. `function* () {}`\n            } else if (!node.generator) {\n                return overrideConfig.anonymous || baseConfig;\n            }\n\n            return \"ignore\";\n        }\n\n        /**\n         * Checks the parens of a function node\n         * @param {ASTNode} node A function node\n         * @returns {void}\n         */\n        function checkFunction(node) {\n            const functionConfig = getConfigForFunction(node);\n\n            if (functionConfig === \"ignore\") {\n                return;\n            }\n\n            const rightToken = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);\n            const leftToken = sourceCode.getTokenBefore(rightToken);\n            const hasSpacing = sourceCode.isSpaceBetweenTokens(leftToken, rightToken);\n\n            if (hasSpacing && functionConfig === \"never\") {\n                context.report({\n                    node,\n                    loc: leftToken.loc.end,\n                    message: \"Unexpected space before function parentheses.\",\n                    fix: fixer => fixer.removeRange([leftToken.range[1], rightToken.range[0]])\n                });\n            } else if (!hasSpacing && functionConfig === \"always\") {\n                context.report({\n                    node,\n                    loc: leftToken.loc.end,\n                    message: \"Missing space before function parentheses.\",\n                    fix: fixer => fixer.insertTextAfter(leftToken, \" \")\n                });\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: checkFunction,\n            FunctionDeclaration: checkFunction,\n            FunctionExpression: checkFunction\n        };\n    }\n};\n","space-in-parens.js":"/**\n * @fileoverview Disallows or enforces spaces inside of parentheses.\n * @author Jonathan Rajavuori\n */\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing inside parentheses\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            enum: [\"{}\", \"[]\", \"()\", \"empty\"]\n                        },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const MISSING_SPACE_MESSAGE = \"There must be a space inside this paren.\",\n            REJECTED_SPACE_MESSAGE = \"There should be no spaces inside this paren.\",\n            ALWAYS = context.options[0] === \"always\",\n\n            exceptionsArrayOptions = (context.options.length === 2) ? context.options[1].exceptions : [],\n            options = {};\n        let exceptions;\n\n        if (exceptionsArrayOptions.length) {\n            options.braceException = exceptionsArrayOptions.indexOf(\"{}\") !== -1;\n            options.bracketException = exceptionsArrayOptions.indexOf(\"[]\") !== -1;\n            options.parenException = exceptionsArrayOptions.indexOf(\"()\") !== -1;\n            options.empty = exceptionsArrayOptions.indexOf(\"empty\") !== -1;\n        }\n\n        /**\n         * Produces an object with the opener and closer exception values\n         * @param {Object} opts The exception options\n         * @returns {Object} `openers` and `closers` exception values\n         * @private\n         */\n        function getExceptions() {\n            const openers = [],\n                closers = [];\n\n            if (options.braceException) {\n                openers.push(\"{\");\n                closers.push(\"}\");\n            }\n\n            if (options.bracketException) {\n                openers.push(\"[\");\n                closers.push(\"]\");\n            }\n\n            if (options.parenException) {\n                openers.push(\"(\");\n                closers.push(\")\");\n            }\n\n            if (options.empty) {\n                openers.push(\")\");\n                closers.push(\"(\");\n            }\n\n            return {\n                openers,\n                closers\n            };\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Determines if a token is one of the exceptions for the opener paren\n         * @param {Object} token The token to check\n         * @returns {boolean} True if the token is one of the exceptions for the opener paren\n         */\n        function isOpenerException(token) {\n            return token.type === \"Punctuator\" && exceptions.openers.indexOf(token.value) >= 0;\n        }\n\n        /**\n         * Determines if a token is one of the exceptions for the closer paren\n         * @param {Object} token The token to check\n         * @returns {boolean} True if the token is one of the exceptions for the closer paren\n         */\n        function isCloserException(token) {\n            return token.type === \"Punctuator\" && exceptions.closers.indexOf(token.value) >= 0;\n        }\n\n        /**\n         * Determines if an opener paren should have a missing space after it\n         * @param {Object} left The paren token\n         * @param {Object} right The token after it\n         * @returns {boolean} True if the paren should have a space\n         */\n        function shouldOpenerHaveSpace(left, right) {\n            if (sourceCode.isSpaceBetweenTokens(left, right)) {\n                return false;\n            }\n\n            if (ALWAYS) {\n                if (astUtils.isClosingParenToken(right)) {\n                    return false;\n                }\n                return !isOpenerException(right);\n            }\n            return isOpenerException(right);\n\n        }\n\n        /**\n         * Determines if an closer paren should have a missing space after it\n         * @param {Object} left The token before the paren\n         * @param {Object} right The paren token\n         * @returns {boolean} True if the paren should have a space\n         */\n        function shouldCloserHaveSpace(left, right) {\n            if (astUtils.isOpeningParenToken(left)) {\n                return false;\n            }\n\n            if (sourceCode.isSpaceBetweenTokens(left, right)) {\n                return false;\n            }\n\n            if (ALWAYS) {\n                return !isCloserException(left);\n            }\n            return isCloserException(left);\n\n        }\n\n        /**\n         * Determines if an opener paren should not have an existing space after it\n         * @param {Object} left The paren token\n         * @param {Object} right The token after it\n         * @returns {boolean} True if the paren should reject the space\n         */\n        function shouldOpenerRejectSpace(left, right) {\n            if (right.type === \"Line\") {\n                return false;\n            }\n\n            if (!astUtils.isTokenOnSameLine(left, right)) {\n                return false;\n            }\n\n            if (!sourceCode.isSpaceBetweenTokens(left, right)) {\n                return false;\n            }\n\n            if (ALWAYS) {\n                return isOpenerException(right);\n            }\n            return !isOpenerException(right);\n\n        }\n\n        /**\n         * Determines if an closer paren should not have an existing space after it\n         * @param {Object} left The token before the paren\n         * @param {Object} right The paren token\n         * @returns {boolean} True if the paren should reject the space\n         */\n        function shouldCloserRejectSpace(left, right) {\n            if (astUtils.isOpeningParenToken(left)) {\n                return false;\n            }\n\n            if (!astUtils.isTokenOnSameLine(left, right)) {\n                return false;\n            }\n\n            if (!sourceCode.isSpaceBetweenTokens(left, right)) {\n                return false;\n            }\n\n            if (ALWAYS) {\n                return isCloserException(left);\n            }\n            return !isCloserException(left);\n\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: function checkParenSpaces(node) {\n                exceptions = getExceptions();\n                const tokens = sourceCode.tokensAndComments;\n\n                tokens.forEach((token, i) => {\n                    const prevToken = tokens[i - 1];\n                    const nextToken = tokens[i + 1];\n\n                    if (!astUtils.isOpeningParenToken(token) && !astUtils.isClosingParenToken(token)) {\n                        return;\n                    }\n\n                    if (token.value === \"(\" && shouldOpenerHaveSpace(token, nextToken)) {\n                        context.report({\n                            node,\n                            loc: token.loc.start,\n                            message: MISSING_SPACE_MESSAGE,\n                            fix(fixer) {\n                                return fixer.insertTextAfter(token, \" \");\n                            }\n                        });\n                    } else if (token.value === \"(\" && shouldOpenerRejectSpace(token, nextToken)) {\n                        context.report({\n                            node,\n                            loc: token.loc.start,\n                            message: REJECTED_SPACE_MESSAGE,\n                            fix(fixer) {\n                                return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                            }\n                        });\n                    } else if (token.value === \")\" && shouldCloserHaveSpace(prevToken, token)) {\n\n                        // context.report(node, token.loc.start, MISSING_SPACE_MESSAGE);\n                        context.report({\n                            node,\n                            loc: token.loc.start,\n                            message: MISSING_SPACE_MESSAGE,\n                            fix(fixer) {\n                                return fixer.insertTextBefore(token, \" \");\n                            }\n                        });\n                    } else if (token.value === \")\" && shouldCloserRejectSpace(prevToken, token)) {\n                        context.report({\n                            node,\n                            loc: token.loc.start,\n                            message: REJECTED_SPACE_MESSAGE,\n                            fix(fixer) {\n                                return fixer.removeRange([prevToken.range[1], token.range[0]]);\n                            }\n                        });\n                    }\n                });\n            }\n        };\n\n    }\n};\n","space-infix-ops.js":"/**\n * @fileoverview Require spaces around infix operators\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require spacing around infix operators\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    int32Hint: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const int32Hint = context.options[0] ? context.options[0].int32Hint === true : false;\n\n        const OPERATORS = [\n            \"*\", \"/\", \"%\", \"+\", \"-\", \"<<\", \">>\", \">>>\", \"<\", \"<=\", \">\", \">=\", \"in\",\n            \"instanceof\", \"==\", \"!=\", \"===\", \"!==\", \"&\", \"^\", \"|\", \"&&\", \"||\", \"=\",\n            \"+=\", \"-=\", \"*=\", \"/=\", \"%=\", \"<<=\", \">>=\", \">>>=\", \"&=\", \"^=\", \"|=\",\n            \"?\", \":\", \",\", \"**\"\n        ];\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Returns the first token which violates the rule\n         * @param {ASTNode} left - The left node of the main node\n         * @param {ASTNode} right - The right node of the main node\n         * @returns {Object} The violator token or null\n         * @private\n         */\n        function getFirstNonSpacedToken(left, right) {\n            const tokens = sourceCode.getTokensBetween(left, right, 1);\n\n            for (let i = 1, l = tokens.length - 1; i < l; ++i) {\n                const op = tokens[i];\n\n                if (\n                    (op.type === \"Punctuator\" || op.type === \"Keyword\") &&\n                    OPERATORS.indexOf(op.value) >= 0 &&\n                    (tokens[i - 1].range[1] >= op.range[0] || op.range[1] >= tokens[i + 1].range[0])\n                ) {\n                    return op;\n                }\n            }\n            return null;\n        }\n\n        /**\n         * Reports an AST node as a rule violation\n         * @param {ASTNode} mainNode - The node to report\n         * @param {Object} culpritToken - The token which has a problem\n         * @returns {void}\n         * @private\n         */\n        function report(mainNode, culpritToken) {\n            context.report({\n                node: mainNode,\n                loc: culpritToken.loc.start,\n                message: \"Infix operators must be spaced.\",\n                fix(fixer) {\n                    const previousToken = sourceCode.getTokenBefore(culpritToken);\n                    const afterToken = sourceCode.getTokenAfter(culpritToken);\n                    let fixString = \"\";\n\n                    if (culpritToken.range[0] - previousToken.range[1] === 0) {\n                        fixString = \" \";\n                    }\n\n                    fixString += culpritToken.value;\n\n                    if (afterToken.range[0] - culpritToken.range[1] === 0) {\n                        fixString += \" \";\n                    }\n\n                    return fixer.replaceText(culpritToken, fixString);\n                }\n            });\n        }\n\n        /**\n         * Check if the node is binary then report\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkBinary(node) {\n            const leftNode = (node.left.typeAnnotation) ? node.left.typeAnnotation : node.left;\n            const rightNode = node.right;\n\n            const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode);\n\n            if (nonSpacedNode) {\n                if (!(int32Hint && sourceCode.getText(node).endsWith(\"|0\"))) {\n                    report(node, nonSpacedNode);\n                }\n            }\n        }\n\n        /**\n         * Check if the node is conditional\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkConditional(node) {\n            const nonSpacedConsequesntNode = getFirstNonSpacedToken(node.test, node.consequent);\n            const nonSpacedAlternateNode = getFirstNonSpacedToken(node.consequent, node.alternate);\n\n            if (nonSpacedConsequesntNode) {\n                report(node, nonSpacedConsequesntNode);\n            } else if (nonSpacedAlternateNode) {\n                report(node, nonSpacedAlternateNode);\n            }\n        }\n\n        /**\n         * Check if the node is a variable\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkVar(node) {\n            const leftNode = (node.id.typeAnnotation) ? node.id.typeAnnotation : node.id;\n            const rightNode = node.init;\n\n            if (rightNode) {\n                const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode);\n\n                if (nonSpacedNode) {\n                    report(node, nonSpacedNode);\n                }\n            }\n        }\n\n        return {\n            AssignmentExpression: checkBinary,\n            AssignmentPattern: checkBinary,\n            BinaryExpression: checkBinary,\n            LogicalExpression: checkBinary,\n            ConditionalExpression: checkConditional,\n            VariableDeclarator: checkVar\n        };\n\n    }\n};\n","space-unary-ops.js":"/**\n * @fileoverview This rule shoud require or disallow spaces before or after unary operations.\n * @author Marcin Kumorek\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing before or after unary operators\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    words: {\n                        type: \"boolean\"\n                    },\n                    nonwords: {\n                        type: \"boolean\"\n                    },\n                    overrides: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"boolean\"\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = context.options && Array.isArray(context.options) && context.options[0] || { words: true, nonwords: false };\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n        * Check if the node is the first \"!\" in a \"!!\" convert to Boolean expression\n        * @param {ASTnode} node AST node\n        * @returns {boolean} Whether or not the node is first \"!\" in \"!!\"\n        */\n        function isFirstBangInBangBangExpression(node) {\n            return node && node.type === \"UnaryExpression\" && node.argument.operator === \"!\" &&\n                node.argument && node.argument.type === \"UnaryExpression\" && node.argument.operator === \"!\";\n        }\n\n        /**\n        * Check if the node's child argument is an \"ObjectExpression\"\n        * @param {ASTnode} node AST node\n        * @returns {boolean} Whether or not the argument's type is \"ObjectExpression\"\n        */\n        function isArgumentObjectExpression(node) {\n            return node.argument && node.argument.type && node.argument.type === \"ObjectExpression\";\n        }\n\n        /**\n        * Checks if an override exists for a given operator.\n        * @param {string} operator Operator\n        * @returns {boolean} Whether or not an override has been provided for the operator\n        */\n        function overrideExistsForOperator(operator) {\n            return options.overrides && options.overrides.hasOwnProperty(operator);\n        }\n\n        /**\n        * Gets the value that the override was set to for this operator\n        * @param {string} operator Operator\n        * @returns {boolean} Whether or not an override enforces a space with this operator\n        */\n        function overrideEnforcesSpaces(operator) {\n            return options.overrides[operator];\n        }\n\n        /**\n        * Verify Unary Word Operator has spaces after the word operator\n        * @param {ASTnode} node AST node\n        * @param {Object} firstToken first token from the AST node\n        * @param {Object} secondToken second token from the AST node\n        * @param {string} word The word to be used for reporting\n        * @returns {void}\n        */\n        function verifyWordHasSpaces(node, firstToken, secondToken, word) {\n            if (secondToken.range[0] === firstToken.range[1]) {\n                context.report({\n                    node,\n                    message: \"Unary word operator '{{word}}' must be followed by whitespace.\",\n                    data: {\n                        word\n                    },\n                    fix(fixer) {\n                        return fixer.insertTextAfter(firstToken, \" \");\n                    }\n                });\n            }\n        }\n\n        /**\n        * Verify Unary Word Operator doesn't have spaces after the word operator\n        * @param {ASTnode} node AST node\n        * @param {Object} firstToken first token from the AST node\n        * @param {Object} secondToken second token from the AST node\n        * @param {string} word The word to be used for reporting\n        * @returns {void}\n        */\n        function verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word) {\n            if (isArgumentObjectExpression(node)) {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node,\n                        message: \"Unexpected space after unary word operator '{{word}}'.\",\n                        data: {\n                            word\n                        },\n                        fix(fixer) {\n                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n        * Check Unary Word Operators for spaces after the word operator\n        * @param {ASTnode} node AST node\n        * @param {Object} firstToken first token from the AST node\n        * @param {Object} secondToken second token from the AST node\n        * @param {string} word The word to be used for reporting\n        * @returns {void}\n        */\n        function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {\n            word = word || firstToken.value;\n\n            if (overrideExistsForOperator(word)) {\n                if (overrideEnforcesSpaces(word)) {\n                    verifyWordHasSpaces(node, firstToken, secondToken, word);\n                } else {\n                    verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n                }\n            } else if (options.words) {\n                verifyWordHasSpaces(node, firstToken, secondToken, word);\n            } else {\n                verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n            }\n        }\n\n        /**\n        * Verifies YieldExpressions satisfy spacing requirements\n        * @param {ASTnode} node AST node\n        * @returns {void}\n        */\n        function checkForSpacesAfterYield(node) {\n            const tokens = sourceCode.getFirstTokens(node, 3),\n                word = \"yield\";\n\n            if (!node.argument || node.delegate) {\n                return;\n            }\n\n            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);\n        }\n\n        /**\n        * Verifies AwaitExpressions satisfy spacing requirements\n        * @param {ASTNode} node AwaitExpression AST node\n        * @returns {void}\n        */\n        function checkForSpacesAfterAwait(node) {\n            const tokens = sourceCode.getFirstTokens(node, 3);\n\n            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], \"await\");\n        }\n\n        /**\n        * Verifies UnaryExpression, UpdateExpression and NewExpression have spaces before or after the operator\n        * @param {ASTnode} node AST node\n        * @param {Object} firstToken First token in the expression\n        * @param {Object} secondToken Second token in the expression\n        * @returns {void}\n        */\n        function verifyNonWordsHaveSpaces(node, firstToken, secondToken) {\n            if (node.prefix) {\n                if (isFirstBangInBangBangExpression(node)) {\n                    return;\n                }\n                if (firstToken.range[1] === secondToken.range[0]) {\n                    context.report({\n                        node,\n                        message: \"Unary operator '{{operator}}' must be followed by whitespace.\",\n                        data: {\n                            operator: firstToken.value\n                        },\n                        fix(fixer) {\n                            return fixer.insertTextAfter(firstToken, \" \");\n                        }\n                    });\n                }\n            } else {\n                if (firstToken.range[1] === secondToken.range[0]) {\n                    context.report({\n                        node,\n                        message: \"Space is required before unary expressions '{{token}}'.\",\n                        data: {\n                            token: secondToken.value\n                        },\n                        fix(fixer) {\n                            return fixer.insertTextBefore(secondToken, \" \");\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n        * Verifies UnaryExpression, UpdateExpression and NewExpression don't have spaces before or after the operator\n        * @param {ASTnode} node AST node\n        * @param {Object} firstToken First token in the expression\n        * @param {Object} secondToken Second token in the expression\n        * @returns {void}\n        */\n        function verifyNonWordsDontHaveSpaces(node, firstToken, secondToken) {\n            if (node.prefix) {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node,\n                        message: \"Unexpected space after unary operator '{{operator}}'.\",\n                        data: {\n                            operator: firstToken.value\n                        },\n                        fix(fixer) {\n                            if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {\n                                return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                            }\n                            return null;\n                        }\n                    });\n                }\n            } else {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node,\n                        message: \"Unexpected space before unary operator '{{operator}}'.\",\n                        data: {\n                            operator: secondToken.value\n                        },\n                        fix(fixer) {\n                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n        * Verifies UnaryExpression, UpdateExpression and NewExpression satisfy spacing requirements\n        * @param {ASTnode} node AST node\n        * @returns {void}\n        */\n        function checkForSpaces(node) {\n            const tokens = node.type === \"UpdateExpression\" && !node.prefix\n                ? sourceCode.getLastTokens(node, 2)\n                : sourceCode.getFirstTokens(node, 2);\n            const firstToken = tokens[0];\n            const secondToken = tokens[1];\n\n            if ((node.type === \"NewExpression\" || node.prefix) && firstToken.type === \"Keyword\") {\n                checkUnaryWordOperatorForSpaces(node, firstToken, secondToken);\n                return;\n            }\n\n            const operator = node.prefix ? tokens[0].value : tokens[1].value;\n\n            if (overrideExistsForOperator(operator)) {\n                if (overrideEnforcesSpaces(operator)) {\n                    verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n                } else {\n                    verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n                }\n            } else if (options.nonwords) {\n                verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n            } else {\n                verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            UnaryExpression: checkForSpaces,\n            UpdateExpression: checkForSpaces,\n            NewExpression: checkForSpaces,\n            YieldExpression: checkForSpacesAfterYield,\n            AwaitExpression: checkForSpacesAfterAwait\n        };\n\n    }\n};\n","spaced-comment.js":"/**\n * @fileoverview Source code for spaced-comments rule\n * @author Gyandeep Singh\n */\n\"use strict\";\n\nconst lodash = require(\"lodash\");\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Escapes the control characters of a given string.\n * @param {string} s - A string to escape.\n * @returns {string} An escaped string.\n */\nfunction escape(s) {\n    const isOneChar = s.length === 1;\n\n    s = lodash.escapeRegExp(s);\n    return isOneChar ? s : `(?:${s})`;\n}\n\n/**\n * Escapes the control characters of a given string.\n * And adds a repeat flag.\n * @param {string} s - A string to escape.\n * @returns {string} An escaped string.\n */\nfunction escapeAndRepeat(s) {\n    return `${escape(s)}+`;\n}\n\n/**\n * Parses `markers` option.\n * If markers don't include `\"*\"`, this adds `\"*\"` to allow JSDoc comments.\n * @param {string[]} [markers] - A marker list.\n * @returns {string[]} A marker list.\n */\nfunction parseMarkersOption(markers) {\n    markers = markers ? markers.slice(0) : [];\n\n    // `*` is a marker for JSDoc comments.\n    if (markers.indexOf(\"*\") === -1) {\n        markers.push(\"*\");\n    }\n\n    return markers;\n}\n\n/**\n * Creates string pattern for exceptions.\n * Generated pattern:\n *\n * 1. A space or an exception pattern sequence.\n *\n * @param {string[]} exceptions - An exception pattern list.\n * @returns {string} A regular expression string for exceptions.\n */\nfunction createExceptionsPattern(exceptions) {\n    let pattern = \"\";\n\n    /*\n     * A space or an exception pattern sequence.\n     * []                 ==> \"\\s\"\n     * [\"-\"]              ==> \"(?:\\s|\\-+$)\"\n     * [\"-\", \"=\"]         ==> \"(?:\\s|(?:\\-+|=+)$)\"\n     * [\"-\", \"=\", \"--==\"] ==> \"(?:\\s|(?:\\-+|=+|(?:\\-\\-==)+)$)\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5Cs%7C(%3F%3A%5C-%2B%7C%3D%2B%7C(%3F%3A%5C-%5C-%3D%3D)%2B)%24)\n     */\n    if (exceptions.length === 0) {\n\n        // a space.\n        pattern += \"\\\\s\";\n    } else {\n\n        // a space or...\n        pattern += \"(?:\\\\s|\";\n\n        if (exceptions.length === 1) {\n\n            // a sequence of the exception pattern.\n            pattern += escapeAndRepeat(exceptions[0]);\n        } else {\n\n            // a sequence of one of the exception patterns.\n            pattern += \"(?:\";\n            pattern += exceptions.map(escapeAndRepeat).join(\"|\");\n            pattern += \")\";\n        }\n        pattern += `(?:$|[${Array.from(astUtils.LINEBREAKS).join(\"\")}]))`;\n    }\n\n    return pattern;\n}\n\n/**\n * Creates RegExp object for `always` mode.\n * Generated pattern for beginning of comment:\n *\n * 1. First, a marker or nothing.\n * 2. Next, a space or an exception pattern sequence.\n *\n * @param {string[]} markers - A marker list.\n * @param {string[]} exceptions - An exception pattern list.\n * @returns {RegExp} A RegExp object for the beginning of a comment in `always` mode.\n */\nfunction createAlwaysStylePattern(markers, exceptions) {\n    let pattern = \"^\";\n\n    /*\n     * A marker or nothing.\n     * [\"*\"]            ==> \"\\*?\"\n     * [\"*\", \"!\"]       ==> \"(?:\\*|!)?\"\n     * [\"*\", \"/\", \"!<\"] ==> \"(?:\\*|\\/|(?:!<))?\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5C*%7C%5C%2F%7C(%3F%3A!%3C))%3F\n     */\n    if (markers.length === 1) {\n\n        // the marker.\n        pattern += escape(markers[0]);\n    } else {\n\n        // one of markers.\n        pattern += \"(?:\";\n        pattern += markers.map(escape).join(\"|\");\n        pattern += \")\";\n    }\n\n    pattern += \"?\"; // or nothing.\n    pattern += createExceptionsPattern(exceptions);\n\n    return new RegExp(pattern);\n}\n\n/**\n * Creates RegExp object for `never` mode.\n * Generated pattern for beginning of comment:\n *\n * 1. First, a marker or nothing (captured).\n * 2. Next, a space or a tab.\n *\n * @param {string[]} markers - A marker list.\n * @returns {RegExp} A RegExp object for `never` mode.\n */\nfunction createNeverStylePattern(markers) {\n    const pattern = `^(${markers.map(escape).join(\"|\")})?[ \\t]+`;\n\n    return new RegExp(pattern);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing after the `//` or `/*` in a comment\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    markers: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    line: {\n                        type: \"object\",\n                        properties: {\n                            exceptions: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            },\n                            markers: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    block: {\n                        type: \"object\",\n                        properties: {\n                            exceptions: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            },\n                            markers: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            },\n                            balanced: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n\n        // Unless the first option is never, require a space\n        const requireSpace = context.options[0] !== \"never\";\n\n        /*\n         * Parse the second options.\n         * If markers don't include `\"*\"`, it's added automatically for JSDoc\n         * comments.\n         */\n        const config = context.options[1] || {};\n        const balanced = config.block && config.block.balanced;\n\n        const styleRules = [\"block\", \"line\"].reduce((rule, type) => {\n            const markers = parseMarkersOption(config[type] && config[type].markers || config.markers);\n            const exceptions = config[type] && config[type].exceptions || config.exceptions || [];\n            const endNeverPattern = \"[ \\t]+$\";\n\n            // Create RegExp object for valid patterns.\n            rule[type] = {\n                beginRegex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),\n                endRegex: balanced && requireSpace ? new RegExp(`${createExceptionsPattern(exceptions)}$`) : new RegExp(endNeverPattern),\n                hasExceptions: exceptions.length > 0,\n                markers: new RegExp(`^(${markers.map(escape).join(\"|\")})`)\n            };\n\n            return rule;\n        }, {});\n\n        /**\n         * Reports a beginning spacing error with an appropriate message.\n         * @param {ASTNode} node - A comment node to check.\n         * @param {string} message - An error message to report.\n         * @param {Array} match - An array of match results for markers.\n         * @param {string} refChar - Character used for reference in the error message.\n         * @returns {void}\n         */\n        function reportBegin(node, message, match, refChar) {\n            const type = node.type.toLowerCase(),\n                commentIdentifier = type === \"block\" ? \"/*\" : \"//\";\n\n            context.report({\n                node,\n                fix(fixer) {\n                    const start = node.range[0];\n                    let end = start + 2;\n\n                    if (requireSpace) {\n                        if (match) {\n                            end += match[0].length;\n                        }\n                        return fixer.insertTextAfterRange([start, end], \" \");\n                    }\n                    end += match[0].length;\n                    return fixer.replaceTextRange([start, end], commentIdentifier + (match[1] ? match[1] : \"\"));\n\n                },\n                message,\n                data: { refChar }\n            });\n        }\n\n        /**\n         * Reports an ending spacing error with an appropriate message.\n         * @param {ASTNode} node - A comment node to check.\n         * @param {string} message - An error message to report.\n         * @param {string} match - An array of the matched whitespace characters.\n         * @returns {void}\n         */\n        function reportEnd(node, message, match) {\n            context.report({\n                node,\n                fix(fixer) {\n                    if (requireSpace) {\n                        return fixer.insertTextAfterRange([node.range[0], node.range[1] - 2], \" \");\n                    }\n                    const end = node.range[1] - 2,\n                        start = end - match[0].length;\n\n                    return fixer.replaceTextRange([start, end], \"\");\n\n                },\n                message\n            });\n        }\n\n        /**\n         * Reports a given comment if it's invalid.\n         * @param {ASTNode} node - a comment node to check.\n         * @returns {void}\n         */\n        function checkCommentForSpace(node) {\n            const type = node.type.toLowerCase(),\n                rule = styleRules[type],\n                commentIdentifier = type === \"block\" ? \"/*\" : \"//\";\n\n            // Ignores empty comments.\n            if (node.value.length === 0) {\n                return;\n            }\n\n            const beginMatch = rule.beginRegex.exec(node.value);\n            const endMatch = rule.endRegex.exec(node.value);\n\n            // Checks.\n            if (requireSpace) {\n                if (!beginMatch) {\n                    const hasMarker = rule.markers.exec(node.value);\n                    const marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;\n\n                    if (rule.hasExceptions) {\n                        reportBegin(node, \"Expected exception block, space or tab after '{{refChar}}' in comment.\", hasMarker, marker);\n                    } else {\n                        reportBegin(node, \"Expected space or tab after '{{refChar}}' in comment.\", hasMarker, marker);\n                    }\n                }\n\n                if (balanced && type === \"block\" && !endMatch) {\n                    reportEnd(node, \"Expected space or tab before '*/' in comment.\");\n                }\n            } else {\n                if (beginMatch) {\n                    if (!beginMatch[1]) {\n                        reportBegin(node, \"Unexpected space or tab after '{{refChar}}' in comment.\", beginMatch, commentIdentifier);\n                    } else {\n                        reportBegin(node, \"Unexpected space or tab after marker ({{refChar}}) in comment.\", beginMatch, beginMatch[1]);\n                    }\n                }\n\n                if (balanced && type === \"block\" && endMatch) {\n                    reportEnd(node, \"Unexpected space or tab before '*/' in comment.\", endMatch);\n                }\n            }\n        }\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments.filter(token => token.type !== \"Shebang\").forEach(checkCommentForSpace);\n            }\n        };\n    }\n};\n","strict.js":"/**\n * @fileoverview Rule to control usage of strict mode directives.\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst messages = {\n    function: \"Use the function form of 'use strict'.\",\n    global: \"Use the global form of 'use strict'.\",\n    multiple: \"Multiple 'use strict' directives.\",\n    never: \"Strict mode is not permitted.\",\n    unnecessary: \"Unnecessary 'use strict' directive.\",\n    module: \"'use strict' is unnecessary inside of modules.\",\n    implied: \"'use strict' is unnecessary when implied strict mode is enabled.\",\n    unnecessaryInClasses: \"'use strict' is unnecessary inside of classes.\",\n    nonSimpleParameterList: \"'use strict' directive inside a function with non-simple parameter list throws a syntax error since ES2016.\",\n    wrap: \"Wrap {{name}} in a function with 'use strict' directive.\"\n};\n\n/**\n * Gets all of the Use Strict Directives in the Directive Prologue of a group of\n * statements.\n * @param {ASTNode[]} statements Statements in the program or function body.\n * @returns {ASTNode[]} All of the Use Strict Directives.\n */\nfunction getUseStrictDirectives(statements) {\n    const directives = [];\n\n    for (let i = 0; i < statements.length; i++) {\n        const statement = statements[i];\n\n        if (\n            statement.type === \"ExpressionStatement\" &&\n            statement.expression.type === \"Literal\" &&\n            statement.expression.value === \"use strict\"\n        ) {\n            directives[i] = statement;\n        } else {\n            break;\n        }\n    }\n\n    return directives;\n}\n\n/**\n * Checks whether a given parameter is a simple parameter.\n *\n * @param {ASTNode} node - A pattern node to check.\n * @returns {boolean} `true` if the node is an Identifier node.\n */\nfunction isSimpleParameter(node) {\n    return node.type === \"Identifier\";\n}\n\n/**\n * Checks whether a given parameter list is a simple parameter list.\n *\n * @param {ASTNode[]} params - A parameter list to check.\n * @returns {boolean} `true` if the every parameter is an Identifier node.\n */\nfunction isSimpleParameterList(params) {\n    return params.every(isSimpleParameter);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow strict mode directives\",\n            category: \"Strict Mode\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"never\", \"global\", \"function\", \"safe\"]\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        const ecmaFeatures = context.parserOptions.ecmaFeatures || {},\n            scopes = [],\n            classScopes = [];\n        let mode = context.options[0] || \"safe\";\n\n        if (ecmaFeatures.impliedStrict) {\n            mode = \"implied\";\n        } else if (mode === \"safe\") {\n            mode = ecmaFeatures.globalReturn ? \"global\" : \"function\";\n        }\n\n        /**\n        * Determines whether a reported error should be fixed, depending on the error type.\n        * @param {string} errorType The type of error\n        * @returns {boolean} `true` if the reported error should be fixed\n        */\n        function shouldFix(errorType) {\n            return errorType === \"multiple\" || errorType === \"unnecessary\" || errorType === \"module\" || errorType === \"implied\" || errorType === \"unnecessaryInClasses\";\n        }\n\n        /**\n        * Gets a fixer function to remove a given 'use strict' directive.\n        * @param {ASTNode} node The directive that should be removed\n        * @returns {Function} A fixer function\n        */\n        function getFixFunction(node) {\n            return fixer => fixer.remove(node);\n        }\n\n        /**\n         * Report a slice of an array of nodes with a given message.\n         * @param {ASTNode[]} nodes Nodes.\n         * @param {string} start Index to start from.\n         * @param {string} end Index to end before.\n         * @param {string} message Message to display.\n         * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)\n         * @returns {void}\n         */\n        function reportSlice(nodes, start, end, message, fix) {\n            nodes.slice(start, end).forEach(node => {\n                context.report({ node, message, fix: fix ? getFixFunction(node) : null });\n            });\n        }\n\n        /**\n         * Report all nodes in an array with a given message.\n         * @param {ASTNode[]} nodes Nodes.\n         * @param {string} message Message to display.\n         * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)\n         * @returns {void}\n         */\n        function reportAll(nodes, message, fix) {\n            reportSlice(nodes, 0, nodes.length, message, fix);\n        }\n\n        /**\n         * Report all nodes in an array, except the first, with a given message.\n         * @param {ASTNode[]} nodes Nodes.\n         * @param {string} message Message to display.\n         * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)\n         * @returns {void}\n         */\n        function reportAllExceptFirst(nodes, message, fix) {\n            reportSlice(nodes, 1, nodes.length, message, fix);\n        }\n\n        /**\n         * Entering a function in 'function' mode pushes a new nested scope onto the\n         * stack. The new scope is true if the nested function is strict mode code.\n         * @param {ASTNode} node The function declaration or expression.\n         * @param {ASTNode[]} useStrictDirectives The Use Strict Directives of the node.\n         * @returns {void}\n         */\n        function enterFunctionInFunctionMode(node, useStrictDirectives) {\n            const isInClass = classScopes.length > 0,\n                isParentGlobal = scopes.length === 0 && classScopes.length === 0,\n                isParentStrict = scopes.length > 0 && scopes[scopes.length - 1],\n                isStrict = useStrictDirectives.length > 0;\n\n            if (isStrict) {\n                if (!isSimpleParameterList(node.params)) {\n                    context.report({ node: useStrictDirectives[0], message: messages.nonSimpleParameterList });\n                } else if (isParentStrict) {\n                    context.report({ node: useStrictDirectives[0], message: messages.unnecessary, fix: getFixFunction(useStrictDirectives[0]) });\n                } else if (isInClass) {\n                    context.report({ node: useStrictDirectives[0], message: messages.unnecessaryInClasses, fix: getFixFunction(useStrictDirectives[0]) });\n                }\n\n                reportAllExceptFirst(useStrictDirectives, messages.multiple, true);\n            } else if (isParentGlobal) {\n                if (isSimpleParameterList(node.params)) {\n                    context.report({ node, message: messages.function });\n                } else {\n                    context.report({\n                        node,\n                        message: messages.wrap,\n                        data: { name: astUtils.getFunctionNameWithKind(node) }\n                    });\n                }\n            }\n\n            scopes.push(isParentStrict || isStrict);\n        }\n\n        /**\n         * Exiting a function in 'function' mode pops its scope off the stack.\n         * @returns {void}\n         */\n        function exitFunctionInFunctionMode() {\n            scopes.pop();\n        }\n\n        /**\n         * Enter a function and either:\n         * - Push a new nested scope onto the stack (in 'function' mode).\n         * - Report all the Use Strict Directives (in the other modes).\n         * @param {ASTNode} node The function declaration or expression.\n         * @returns {void}\n         */\n        function enterFunction(node) {\n            const isBlock = node.body.type === \"BlockStatement\",\n                useStrictDirectives = isBlock\n                    ? getUseStrictDirectives(node.body.body) : [];\n\n            if (mode === \"function\") {\n                enterFunctionInFunctionMode(node, useStrictDirectives);\n            } else if (useStrictDirectives.length > 0) {\n                if (isSimpleParameterList(node.params)) {\n                    reportAll(useStrictDirectives, messages[mode], shouldFix(mode));\n                } else {\n                    context.report({ node: useStrictDirectives[0], message: messages.nonSimpleParameterList });\n                    reportAllExceptFirst(useStrictDirectives, messages.multiple, true);\n                }\n            }\n        }\n\n        const rule = {\n            Program(node) {\n                const useStrictDirectives = getUseStrictDirectives(node.body);\n\n                if (node.sourceType === \"module\") {\n                    mode = \"module\";\n                }\n\n                if (mode === \"global\") {\n                    if (node.body.length > 0 && useStrictDirectives.length === 0) {\n                        context.report({ node, message: messages.global });\n                    }\n                    reportAllExceptFirst(useStrictDirectives, messages.multiple, true);\n                } else {\n                    reportAll(useStrictDirectives, messages[mode], shouldFix(mode));\n                }\n            },\n            FunctionDeclaration: enterFunction,\n            FunctionExpression: enterFunction,\n            ArrowFunctionExpression: enterFunction\n        };\n\n        if (mode === \"function\") {\n            Object.assign(rule, {\n\n                // Inside of class bodies are always strict mode.\n                ClassBody() {\n                    classScopes.push(true);\n                },\n                \"ClassBody:exit\"() {\n                    classScopes.pop();\n                },\n\n                \"FunctionDeclaration:exit\": exitFunctionInFunctionMode,\n                \"FunctionExpression:exit\": exitFunctionInFunctionMode,\n                \"ArrowFunctionExpression:exit\": exitFunctionInFunctionMode\n            });\n        }\n\n        return rule;\n    }\n};\n","switch-colon-spacing.js":"/**\n * @fileoverview Rule to enforce spacing around colons of switch statements.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce spacing around colons of switch statements\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: { type: \"boolean\" },\n                    after: { type: \"boolean\" }\n                },\n                additionalProperties: false\n            }\n        ],\n        fixable: \"whitespace\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = context.options[0] || {};\n        const beforeSpacing = options.before === true; // false by default\n        const afterSpacing = options.after !== false; // true by default\n\n        /**\n         * Get the colon token of the given SwitchCase node.\n         * @param {ASTNode} node The SwitchCase node to get.\n         * @returns {Token} The colon token of the node.\n         */\n        function getColonToken(node) {\n            if (node.test) {\n                return sourceCode.getTokenAfter(node.test, astUtils.isColonToken);\n            }\n            return sourceCode.getFirstToken(node, 1);\n        }\n\n        /**\n         * Check whether the spacing between the given 2 tokens is valid or not.\n         * @param {Token} left The left token to check.\n         * @param {Token} right The right token to check.\n         * @param {boolean} expected The expected spacing to check. `true` if there should be a space.\n         * @returns {boolean} `true` if the spacing between the tokens is valid.\n         */\n        function isValidSpacing(left, right, expected) {\n            return (\n                astUtils.isClosingBraceToken(right) ||\n                !astUtils.isTokenOnSameLine(left, right) ||\n                sourceCode.isSpaceBetweenTokens(left, right) === expected\n            );\n        }\n\n        /**\n         * Check whether comments exist between the given 2 tokens.\n         * @param {Token} left The left token to check.\n         * @param {Token} right The right token to check.\n         * @returns {boolean} `true` if comments exist between the given 2 tokens.\n         */\n        function commentsExistBetween(left, right) {\n            return sourceCode.getFirstTokenBetween(\n                left,\n                right,\n                {\n                    includeComments: true,\n                    filter: astUtils.isCommentToken\n                }\n            ) !== null;\n        }\n\n        /**\n         * Fix the spacing between the given 2 tokens.\n         * @param {RuleFixer} fixer The fixer to fix.\n         * @param {Token} left The left token of fix range.\n         * @param {Token} right The right token of fix range.\n         * @param {boolean} spacing The spacing style. `true` if there should be a space.\n         * @returns {Fix|null} The fix object.\n         */\n        function fix(fixer, left, right, spacing) {\n            if (commentsExistBetween(left, right)) {\n                return null;\n            }\n            if (spacing) {\n                return fixer.insertTextAfter(left, \" \");\n            }\n            return fixer.removeRange([left.range[1], right.range[0]]);\n        }\n\n        return {\n            SwitchCase(node) {\n                const colonToken = getColonToken(node);\n                const beforeToken = sourceCode.getTokenBefore(colonToken);\n                const afterToken = sourceCode.getTokenAfter(colonToken);\n\n                if (!isValidSpacing(beforeToken, colonToken, beforeSpacing)) {\n                    context.report({\n                        node,\n                        loc: colonToken.loc,\n                        message: \"{{verb}} space(s) before this colon.\",\n                        data: { verb: beforeSpacing ? \"Expected\" : \"Unexpected\" },\n                        fix: fixer => fix(fixer, beforeToken, colonToken, beforeSpacing)\n                    });\n                }\n                if (!isValidSpacing(colonToken, afterToken, afterSpacing)) {\n                    context.report({\n                        node,\n                        loc: colonToken.loc,\n                        message: \"{{verb}} space(s) after this colon.\",\n                        data: { verb: afterSpacing ? \"Expected\" : \"Unexpected\" },\n                        fix: fixer => fix(fixer, colonToken, afterToken, afterSpacing)\n                    });\n                }\n            }\n        };\n    }\n};\n","symbol-description.js":"/**\n * @fileoverview Rule to enforce description with the `Symbol` object\n * @author Jarek Rencz\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require symbol descriptions\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Reports if node does not conform the rule in case rule is set to\n         * report missing description\n         *\n         * @param {ASTNode} node - A CallExpression node to check.\n         * @returns {void}\n         */\n        function checkArgument(node) {\n            if (node.arguments.length === 0) {\n                context.report({\n                    node,\n                    message: \"Expected Symbol to have a description.\"\n                });\n            }\n        }\n\n        return {\n            \"Program:exit\"() {\n                const scope = context.getScope();\n                const variable = astUtils.getVariableByName(scope, \"Symbol\");\n\n                if (variable && variable.defs.length === 0) {\n                    variable.references.forEach(reference => {\n                        const node = reference.identifier;\n\n                        if (astUtils.isCallee(node)) {\n                            checkArgument(node.parent);\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","template-curly-spacing.js":"/**\n * @fileoverview Rule to enforce spacing around embedded expressions of template strings\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst OPEN_PAREN = /\\$\\{$/;\nconst CLOSE_PAREN = /^\\}/;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow spacing around embedded expressions of template strings\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            { enum: [\"always\", \"never\"] }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const always = context.options[0] === \"always\";\n        const prefix = always ? \"Expected\" : \"Unexpected\";\n\n        /**\n         * Checks spacing before `}` of a given token.\n         * @param {Token} token - A token to check. This is a Template token.\n         * @returns {void}\n         */\n        function checkSpacingBefore(token) {\n            const prevToken = sourceCode.getTokenBefore(token);\n\n            if (prevToken &&\n                CLOSE_PAREN.test(token.value) &&\n                astUtils.isTokenOnSameLine(prevToken, token) &&\n                sourceCode.isSpaceBetweenTokens(prevToken, token) !== always\n            ) {\n                context.report({\n                    loc: token.loc.start,\n                    message: \"{{prefix}} space(s) before '}'.\",\n                    data: {\n                        prefix\n                    },\n                    fix(fixer) {\n                        if (always) {\n                            return fixer.insertTextBefore(token, \" \");\n                        }\n                        return fixer.removeRange([\n                            prevToken.range[1],\n                            token.range[0]\n                        ]);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Checks spacing after `${` of a given token.\n         * @param {Token} token - A token to check. This is a Template token.\n         * @returns {void}\n         */\n        function checkSpacingAfter(token) {\n            const nextToken = sourceCode.getTokenAfter(token);\n\n            if (nextToken &&\n                OPEN_PAREN.test(token.value) &&\n                astUtils.isTokenOnSameLine(token, nextToken) &&\n                sourceCode.isSpaceBetweenTokens(token, nextToken) !== always\n            ) {\n                context.report({\n                    loc: {\n                        line: token.loc.end.line,\n                        column: token.loc.end.column - 2\n                    },\n                    message: \"{{prefix}} space(s) after '${'.\",\n                    data: {\n                        prefix\n                    },\n                    fix(fixer) {\n                        if (always) {\n                            return fixer.insertTextAfter(token, \" \");\n                        }\n                        return fixer.removeRange([\n                            token.range[1],\n                            nextToken.range[0]\n                        ]);\n                    }\n                });\n            }\n        }\n\n        return {\n            TemplateElement(node) {\n                const token = sourceCode.getFirstToken(node);\n\n                checkSpacingBefore(token);\n                checkSpacingAfter(token);\n            }\n        };\n    }\n};\n","template-tag-spacing.js":"/**\n * @fileoverview Rule to check spacing between template tags and their literals\n * @author Jonathan Wilsson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow spacing between template tags and their literals\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            { enum: [\"always\", \"never\"] }\n        ]\n    },\n\n    create(context) {\n        const never = context.options[0] !== \"always\";\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Check if a space is present between a template tag and its literal\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkSpacing(node) {\n            const tagToken = sourceCode.getTokenBefore(node.quasi);\n            const literalToken = sourceCode.getFirstToken(node.quasi);\n            const hasWhitespace = sourceCode.isSpaceBetweenTokens(tagToken, literalToken);\n\n            if (never && hasWhitespace) {\n                context.report({\n                    node,\n                    loc: tagToken.loc.start,\n                    message: \"Unexpected space between template tag and template literal.\",\n                    fix(fixer) {\n                        const comments = sourceCode.getCommentsBefore(node.quasi);\n\n                        // Don't fix anything if there's a single line comment after the template tag\n                        if (comments.some(comment => comment.type === \"Line\")) {\n                            return null;\n                        }\n\n                        return fixer.replaceTextRange(\n                            [tagToken.range[1], literalToken.range[0]],\n                            comments.reduce((text, comment) => text + sourceCode.getText(comment), \"\")\n                        );\n                    }\n                });\n            } else if (!never && !hasWhitespace) {\n                context.report({\n                    node,\n                    loc: tagToken.loc.start,\n                    message: \"Missing space between template tag and template literal.\",\n                    fix(fixer) {\n                        return fixer.insertTextAfter(tagToken, \" \");\n                    }\n                });\n            }\n        }\n\n        return {\n            TaggedTemplateExpression: checkSpacing\n        };\n    }\n};\n","unicode-bom.js":"/**\n * @fileoverview Require or disallow Unicode BOM\n * @author Andrew Johnston <https://github.com/ehjay>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow Unicode byte order mark (BOM)\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            }\n        ]\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            Program: function checkUnicodeBOM(node) {\n\n                const sourceCode = context.getSourceCode(),\n                    location = { column: 0, line: 1 },\n                    requireBOM = context.options[0] || \"never\";\n\n                if (!sourceCode.hasBOM && (requireBOM === \"always\")) {\n                    context.report({\n                        node,\n                        loc: location,\n                        message: \"Expected Unicode BOM (Byte Order Mark).\",\n                        fix(fixer) {\n                            return fixer.insertTextBeforeRange([0, 1], \"\\uFEFF\");\n                        }\n                    });\n                } else if (sourceCode.hasBOM && (requireBOM === \"never\")) {\n                    context.report({\n                        node,\n                        loc: location,\n                        message: \"Unexpected Unicode BOM (Byte Order Mark).\",\n                        fix(fixer) {\n                            return fixer.removeRange([-1, 0]);\n                        }\n                    });\n                }\n            }\n\n        };\n\n    }\n};\n","use-isnan.js":"/**\n * @fileoverview Rule to flag comparisons to the value NaN\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require calls to `isNaN()` when checking for `NaN`\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n            BinaryExpression(node) {\n                if (/^(?:[<>]|[!=]=)=?$/.test(node.operator) && (node.left.name === \"NaN\" || node.right.name === \"NaN\")) {\n                    context.report({ node, message: \"Use the isNaN function to compare with NaN.\" });\n                }\n            }\n        };\n\n    }\n};\n","valid-jsdoc.js":"/**\n * @fileoverview Validates JSDoc comments are syntactically correct\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst doctrine = require(\"doctrine\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce valid JSDoc comments\",\n            category: \"Possible Errors\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    prefer: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"string\"\n                        }\n                    },\n                    preferType: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"string\"\n                        }\n                    },\n                    requireReturn: {\n                        type: \"boolean\"\n                    },\n                    requireParamDescription: {\n                        type: \"boolean\"\n                    },\n                    requireReturnDescription: {\n                        type: \"boolean\"\n                    },\n                    matchDescription: {\n                        type: \"string\"\n                    },\n                    requireReturnType: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const options = context.options[0] || {},\n            prefer = options.prefer || {},\n            sourceCode = context.getSourceCode(),\n\n            // these both default to true, so you have to explicitly make them false\n            requireReturn = options.requireReturn !== false,\n            requireParamDescription = options.requireParamDescription !== false,\n            requireReturnDescription = options.requireReturnDescription !== false,\n            requireReturnType = options.requireReturnType !== false,\n            preferType = options.preferType || {},\n            checkPreferType = Object.keys(preferType).length !== 0;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // Using a stack to store if a function returns or not (handling nested functions)\n        const fns = [];\n\n        /**\n         * Check if node type is a Class\n         * @param {ASTNode} node node to check.\n         * @returns {boolean} True is its a class\n         * @private\n         */\n        function isTypeClass(node) {\n            return node.type === \"ClassExpression\" || node.type === \"ClassDeclaration\";\n        }\n\n        /**\n         * When parsing a new function, store it in our function stack.\n         * @param {ASTNode} node A function node to check.\n         * @returns {void}\n         * @private\n         */\n        function startFunction(node) {\n            fns.push({\n                returnPresent: (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\") ||\n                    isTypeClass(node)\n            });\n        }\n\n        /**\n         * Indicate that return has been found in the current function.\n         * @param {ASTNode} node The return node.\n         * @returns {void}\n         * @private\n         */\n        function addReturn(node) {\n            const functionState = fns[fns.length - 1];\n\n            if (functionState && node.argument !== null) {\n                functionState.returnPresent = true;\n            }\n        }\n\n        /**\n         * Check if return tag type is void or undefined\n         * @param {Object} tag JSDoc tag\n         * @returns {boolean} True if its of type void or undefined\n         * @private\n         */\n        function isValidReturnType(tag) {\n            return tag.type === null || tag.type.name === \"void\" || tag.type.type === \"UndefinedLiteral\";\n        }\n\n        /**\n         * Check if type should be validated based on some exceptions\n         * @param {Object} type JSDoc tag\n         * @returns {boolean} True if it can be validated\n         * @private\n         */\n        function canTypeBeValidated(type) {\n            return type !== \"UndefinedLiteral\" && // {undefined} as there is no name property available.\n                   type !== \"NullLiteral\" && // {null}\n                   type !== \"NullableLiteral\" && // {?}\n                   type !== \"FunctionType\" && // {function(a)}\n                   type !== \"AllLiteral\"; // {*}\n        }\n\n        /**\n         * Extract the current and expected type based on the input type object\n         * @param {Object} type JSDoc tag\n         * @returns {Object} current and expected type object\n         * @private\n         */\n        function getCurrentExpectedTypes(type) {\n            let currentType;\n\n            if (type.name) {\n                currentType = type.name;\n            } else if (type.expression) {\n                currentType = type.expression.name;\n            }\n\n            const expectedType = currentType && preferType[currentType];\n\n            return {\n                currentType,\n                expectedType\n            };\n        }\n\n        /**\n         * Validate type for a given JSDoc node\n         * @param {Object} jsdocNode JSDoc node\n         * @param {Object} type JSDoc tag\n         * @returns {void}\n         * @private\n         */\n        function validateType(jsdocNode, type) {\n            if (!type || !canTypeBeValidated(type.type)) {\n                return;\n            }\n\n            const typesToCheck = [];\n            let elements = [];\n\n            switch (type.type) {\n                case \"TypeApplication\": // {Array.<String>}\n                    elements = type.applications[0].type === \"UnionType\" ? type.applications[0].elements : type.applications;\n                    typesToCheck.push(getCurrentExpectedTypes(type));\n                    break;\n                case \"RecordType\": // {{20:String}}\n                    elements = type.fields;\n                    break;\n                case \"UnionType\": // {String|number|Test}\n                case \"ArrayType\": // {[String, number, Test]}\n                    elements = type.elements;\n                    break;\n                case \"FieldType\": // Array.<{count: number, votes: number}>\n                    if (type.value) {\n                        typesToCheck.push(getCurrentExpectedTypes(type.value));\n                    }\n                    break;\n                default:\n                    typesToCheck.push(getCurrentExpectedTypes(type));\n            }\n\n            elements.forEach(validateType.bind(null, jsdocNode));\n\n            typesToCheck.forEach(typeToCheck => {\n                if (typeToCheck.expectedType &&\n                    typeToCheck.expectedType !== typeToCheck.currentType) {\n                    context.report({\n                        node: jsdocNode,\n                        message: \"Use '{{expectedType}}' instead of '{{currentType}}'.\",\n                        data: {\n                            currentType: typeToCheck.currentType,\n                            expectedType: typeToCheck.expectedType\n                        }\n                    });\n                }\n            });\n        }\n\n        /**\n         * Validate the JSDoc node and output warnings if anything is wrong.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkJSDoc(node) {\n            const jsdocNode = sourceCode.getJSDocComment(node),\n                functionData = fns.pop(),\n                params = Object.create(null);\n            let hasReturns = false,\n                hasConstructor = false,\n                isInterface = false,\n                isOverride = false,\n                isAbstract = false;\n\n            // make sure only to validate JSDoc comments\n            if (jsdocNode) {\n                let jsdoc;\n\n                try {\n                    jsdoc = doctrine.parse(jsdocNode.value, {\n                        strict: true,\n                        unwrap: true,\n                        sloppy: true\n                    });\n                } catch (ex) {\n\n                    if (/braces/i.test(ex.message)) {\n                        context.report({ node: jsdocNode, message: \"JSDoc type missing brace.\" });\n                    } else {\n                        context.report({ node: jsdocNode, message: \"JSDoc syntax error.\" });\n                    }\n\n                    return;\n                }\n\n                jsdoc.tags.forEach(tag => {\n\n                    switch (tag.title.toLowerCase()) {\n\n                        case \"param\":\n                        case \"arg\":\n                        case \"argument\":\n                            if (!tag.type) {\n                                context.report({ node: jsdocNode, message: \"Missing JSDoc parameter type for '{{name}}'.\", data: { name: tag.name } });\n                            }\n\n                            if (!tag.description && requireParamDescription) {\n                                context.report({ node: jsdocNode, message: \"Missing JSDoc parameter description for '{{name}}'.\", data: { name: tag.name } });\n                            }\n\n                            if (params[tag.name]) {\n                                context.report({ node: jsdocNode, message: \"Duplicate JSDoc parameter '{{name}}'.\", data: { name: tag.name } });\n                            } else if (tag.name.indexOf(\".\") === -1) {\n                                params[tag.name] = 1;\n                            }\n                            break;\n\n                        case \"return\":\n                        case \"returns\":\n                            hasReturns = true;\n\n                            if (!requireReturn && !functionData.returnPresent && (tag.type === null || !isValidReturnType(tag)) && !isAbstract) {\n                                context.report({\n                                    node: jsdocNode,\n                                    message: \"Unexpected @{{title}} tag; function has no return statement.\",\n                                    data: {\n                                        title: tag.title\n                                    }\n                                });\n                            } else {\n                                if (requireReturnType && !tag.type) {\n                                    context.report({ node: jsdocNode, message: \"Missing JSDoc return type.\" });\n                                }\n\n                                if (!isValidReturnType(tag) && !tag.description && requireReturnDescription) {\n                                    context.report({ node: jsdocNode, message: \"Missing JSDoc return description.\" });\n                                }\n                            }\n\n                            break;\n\n                        case \"constructor\":\n                        case \"class\":\n                            hasConstructor = true;\n                            break;\n\n                        case \"override\":\n                        case \"inheritdoc\":\n                            isOverride = true;\n                            break;\n\n                        case \"abstract\":\n                        case \"virtual\":\n                            isAbstract = true;\n                            break;\n\n                        case \"interface\":\n                            isInterface = true;\n                            break;\n\n                        // no default\n                    }\n\n                    // check tag preferences\n                    if (prefer.hasOwnProperty(tag.title) && tag.title !== prefer[tag.title]) {\n                        context.report({ node: jsdocNode, message: \"Use @{{name}} instead.\", data: { name: prefer[tag.title] } });\n                    }\n\n                    // validate the types\n                    if (checkPreferType && tag.type) {\n                        validateType(jsdocNode, tag.type);\n                    }\n                });\n\n                // check for functions missing @returns\n                if (!isOverride && !hasReturns && !hasConstructor && !isInterface &&\n                    node.parent.kind !== \"get\" && node.parent.kind !== \"constructor\" &&\n                    node.parent.kind !== \"set\" && !isTypeClass(node)) {\n                    if (requireReturn || functionData.returnPresent) {\n                        context.report({\n                            node: jsdocNode,\n                            message: \"Missing JSDoc @{{returns}} for function.\",\n                            data: {\n                                returns: prefer.returns || \"returns\"\n                            }\n                        });\n                    }\n                }\n\n                // check the parameters\n                const jsdocParams = Object.keys(params);\n\n                if (node.params) {\n                    node.params.forEach((param, i) => {\n                        if (param.type === \"AssignmentPattern\") {\n                            param = param.left;\n                        }\n\n                        const name = param.name;\n\n                        // TODO(nzakas): Figure out logical things to do with destructured, default, rest params\n                        if (param.type === \"Identifier\") {\n                            if (jsdocParams[i] && (name !== jsdocParams[i])) {\n                                context.report({\n                                    node: jsdocNode,\n                                    message: \"Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.\",\n                                    data: {\n                                        name,\n                                        jsdocName: jsdocParams[i]\n                                    }\n                                });\n                            } else if (!params[name] && !isOverride) {\n                                context.report({\n                                    node: jsdocNode,\n                                    message: \"Missing JSDoc for parameter '{{name}}'.\",\n                                    data: {\n                                        name\n                                    }\n                                });\n                            }\n                        }\n                    });\n                }\n\n                if (options.matchDescription) {\n                    const regex = new RegExp(options.matchDescription);\n\n                    if (!regex.test(jsdoc.description)) {\n                        context.report({ node: jsdocNode, message: \"JSDoc description does not satisfy the regex pattern.\" });\n                    }\n                }\n\n            }\n\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ArrowFunctionExpression: startFunction,\n            FunctionExpression: startFunction,\n            FunctionDeclaration: startFunction,\n            ClassExpression: startFunction,\n            ClassDeclaration: startFunction,\n            \"ArrowFunctionExpression:exit\": checkJSDoc,\n            \"FunctionExpression:exit\": checkJSDoc,\n            \"FunctionDeclaration:exit\": checkJSDoc,\n            \"ClassExpression:exit\": checkJSDoc,\n            \"ClassDeclaration:exit\": checkJSDoc,\n            ReturnStatement: addReturn\n        };\n\n    }\n};\n","valid-typeof.js":"/**\n * @fileoverview Ensures that the results of typeof are compared against a valid string\n * @author Ian Christian Myers\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce comparing `typeof` expressions against valid strings\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    requireStringLiterals: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const VALID_TYPES = [\"symbol\", \"undefined\", \"object\", \"boolean\", \"number\", \"string\", \"function\"],\n            OPERATORS = [\"==\", \"===\", \"!=\", \"!==\"];\n\n        const requireStringLiterals = context.options[0] && context.options[0].requireStringLiterals;\n\n        /**\n        * Determines whether a node is a typeof expression.\n        * @param {ASTNode} node The node\n        * @returns {boolean} `true` if the node is a typeof expression\n        */\n        function isTypeofExpression(node) {\n            return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            UnaryExpression(node) {\n                if (isTypeofExpression(node)) {\n                    const parent = context.getAncestors().pop();\n\n                    if (parent.type === \"BinaryExpression\" && OPERATORS.indexOf(parent.operator) !== -1) {\n                        const sibling = parent.left === node ? parent.right : parent.left;\n\n                        if (sibling.type === \"Literal\" || sibling.type === \"TemplateLiteral\" && !sibling.expressions.length) {\n                            const value = sibling.type === \"Literal\" ? sibling.value : sibling.quasis[0].value.cooked;\n\n                            if (VALID_TYPES.indexOf(value) === -1) {\n                                context.report({ node: sibling, message: \"Invalid typeof comparison value.\" });\n                            }\n                        } else if (requireStringLiterals && !isTypeofExpression(sibling)) {\n                            context.report({ node: sibling, message: \"Typeof comparisons should be to string literals.\" });\n                        }\n                    }\n                }\n            }\n\n        };\n\n    }\n};\n","vars-on-top.js":"/**\n * @fileoverview Rule to enforce var declarations are only at the top of a function.\n * @author Danny Fritz\n * @author Gyandeep Singh\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require `var` declarations be placed at the top of their containing scope\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const errorMessage = \"All 'var' declarations must be at the top of the function scope.\";\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * @param {ASTNode} node - any node\n         * @returns {boolean} whether the given node structurally represents a directive\n         */\n        function looksLikeDirective(node) {\n            return node.type === \"ExpressionStatement\" &&\n                node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n        }\n\n        /**\n         * Check to see if its a ES6 import declaration\n         * @param {ASTNode} node - any node\n         * @returns {boolean} whether the given node represents a import declaration\n         */\n        function looksLikeImport(node) {\n            return node.type === \"ImportDeclaration\" || node.type === \"ImportSpecifier\" ||\n                node.type === \"ImportDefaultSpecifier\" || node.type === \"ImportNamespaceSpecifier\";\n        }\n\n        /**\n         * Checks whether a given node is a variable declaration or not.\n         *\n         * @param {ASTNode} node - any node\n         * @returns {boolean} `true` if the node is a variable declaration.\n         */\n        function isVariableDeclaration(node) {\n            return (\n                node.type === \"VariableDeclaration\" ||\n                (\n                    node.type === \"ExportNamedDeclaration\" &&\n                    node.declaration &&\n                    node.declaration.type === \"VariableDeclaration\"\n                )\n            );\n        }\n\n        /**\n         * Checks whether this variable is on top of the block body\n         * @param {ASTNode} node - The node to check\n         * @param {ASTNode[]} statements - collection of ASTNodes for the parent node block\n         * @returns {boolean} True if var is on top otherwise false\n         */\n        function isVarOnTop(node, statements) {\n            const l = statements.length;\n            let i = 0;\n\n            // skip over directives\n            for (; i < l; ++i) {\n                if (!looksLikeDirective(statements[i]) && !looksLikeImport(statements[i])) {\n                    break;\n                }\n            }\n\n            for (; i < l; ++i) {\n                if (!isVariableDeclaration(statements[i])) {\n                    return false;\n                }\n                if (statements[i] === node) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks whether variable is on top at the global level\n         * @param {ASTNode} node - The node to check\n         * @param {ASTNode} parent - Parent of the node\n         * @returns {void}\n         */\n        function globalVarCheck(node, parent) {\n            if (!isVarOnTop(node, parent.body)) {\n                context.report({ node, message: errorMessage });\n            }\n        }\n\n        /**\n         * Checks whether variable is on top at functional block scope level\n         * @param {ASTNode} node - The node to check\n         * @param {ASTNode} parent - Parent of the node\n         * @param {ASTNode} grandParent - Parent of the node's parent\n         * @returns {void}\n         */\n        function blockScopeVarCheck(node, parent, grandParent) {\n            if (!(/Function/.test(grandParent.type) &&\n                    parent.type === \"BlockStatement\" &&\n                    isVarOnTop(node, parent.body))) {\n                context.report({ node, message: errorMessage });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclaration(node) {\n                const ancestors = context.getAncestors();\n                let parent = ancestors.pop();\n                let grandParent = ancestors.pop();\n\n                if (node.kind === \"var\") { // check variable is `var` type and not `let` or `const`\n                    if (parent.type === \"ExportNamedDeclaration\") {\n                        node = parent;\n                        parent = grandParent;\n                        grandParent = ancestors.pop();\n                    }\n\n                    if (parent.type === \"Program\") { // That means its a global variable\n                        globalVarCheck(node, parent);\n                    } else {\n                        blockScopeVarCheck(node, parent, grandParent);\n                    }\n                }\n            }\n        };\n\n    }\n};\n","wrap-iife.js":"/**\n * @fileoverview Rule to flag when IIFE is not wrapped in parens\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require parentheses around immediate `function` invocations\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"outside\", \"inside\", \"any\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    functionPrototypeMethods: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        const style = context.options[0] || \"outside\";\n        const includeFunctionPrototypeMethods = (context.options[1] && context.options[1].functionPrototypeMethods) || false;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Check if the node is wrapped in ()\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} True if it is wrapped\n         * @private\n         */\n        function wrapped(node) {\n            return astUtils.isParenthesised(sourceCode, node);\n        }\n\n        /**\n        * Get the function node from an IIFE\n        * @param {ASTNode} node node to evaluate\n        * @returns {ASTNode} node that is the function expression of the given IIFE, or null if none exist\n        */\n        function getFunctionNodeFromIIFE(node) {\n            const callee = node.callee;\n\n            if (callee.type === \"FunctionExpression\") {\n                return callee;\n            }\n\n            if (includeFunctionPrototypeMethods &&\n                callee.type === \"MemberExpression\" &&\n                callee.object.type === \"FunctionExpression\" &&\n                (astUtils.getStaticPropertyName(callee) === \"call\" || astUtils.getStaticPropertyName(callee) === \"apply\")\n            ) {\n                return callee.object;\n            }\n\n            return null;\n        }\n\n\n        return {\n            CallExpression(node) {\n                const innerNode = getFunctionNodeFromIIFE(node);\n\n                if (!innerNode) {\n                    return;\n                }\n\n                const callExpressionWrapped = wrapped(node),\n                    functionExpressionWrapped = wrapped(innerNode);\n\n                if (!callExpressionWrapped && !functionExpressionWrapped) {\n                    context.report({\n                        node,\n                        message: \"Wrap an immediate function invocation in parentheses.\",\n                        fix(fixer) {\n                            const nodeToSurround = style === \"inside\" ? innerNode : node;\n\n                            return fixer.replaceText(nodeToSurround, `(${sourceCode.getText(nodeToSurround)})`);\n                        }\n                    });\n                } else if (style === \"inside\" && !functionExpressionWrapped) {\n                    context.report({\n                        node,\n                        message: \"Wrap only the function expression in parens.\",\n                        fix(fixer) {\n\n                            /*\n                             * The outer call expression will always be wrapped at this point.\n                             * Replace the range between the end of the function expression and the end of the call expression.\n                             * for example, in `(function(foo) {}(bar))`, the range `(bar))` should get replaced with `)(bar)`.\n                             * Replace the parens from the outer expression, and parenthesize the function expression.\n                             */\n                            const parenAfter = sourceCode.getTokenAfter(node);\n\n                            return fixer.replaceTextRange(\n                                [innerNode.range[1], parenAfter.range[1]],\n                                `)${sourceCode.getText().slice(innerNode.range[1], parenAfter.range[0])}`\n                            );\n                        }\n                    });\n                } else if (style === \"outside\" && !callExpressionWrapped) {\n                    context.report({\n                        node,\n                        message: \"Move the invocation into the parens that contain the function.\",\n                        fix(fixer) {\n\n                            /*\n                             * The inner function expression will always be wrapped at this point.\n                             * It's only necessary to replace the range between the end of the function expression\n                             * and the call expression. For example, in `(function(foo) {})(bar)`, the range `)(bar)`\n                             * should get replaced with `(bar))`.\n                             */\n                            const parenAfter = sourceCode.getTokenAfter(innerNode);\n\n                            return fixer.replaceTextRange(\n                                [parenAfter.range[0], node.range[1]],\n                                `${sourceCode.getText().slice(parenAfter.range[1], node.range[1])})`\n                            );\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","wrap-regex.js":"/**\n * @fileoverview Rule to flag when regex literals are not wrapped in parens\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require parenthesis around regex literals\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n\n            Literal(node) {\n                const token = sourceCode.getFirstToken(node),\n                    nodeType = token.type;\n\n                if (nodeType === \"RegularExpression\") {\n                    const source = sourceCode.getTokenBefore(node);\n                    const ancestors = context.getAncestors();\n                    const grandparent = ancestors[ancestors.length - 1];\n\n                    if (grandparent.type === \"MemberExpression\" && grandparent.object === node &&\n                        (!source || source.value !== \"(\")) {\n                        context.report({\n                            node,\n                            message: \"Wrap the regexp literal in parens to disambiguate the slash.\",\n                            fix: fixer => fixer.replaceText(node, `(${sourceCode.getText(node)})`)\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","yield-star-spacing.js":"/**\n * @fileoverview Rule to check the spacing around the * in yield* expressions.\n * @author Bryan Smith\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow spacing around the `*` in `yield*` expressions\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"before\", \"after\", \"both\", \"neither\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            before: { type: \"boolean\" },\n                            after: { type: \"boolean\" }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const mode = (function(option) {\n            if (!option || typeof option === \"string\") {\n                return {\n                    before: { before: true, after: false },\n                    after: { before: false, after: true },\n                    both: { before: true, after: true },\n                    neither: { before: false, after: false }\n                }[option || \"after\"];\n            }\n            return option;\n        }(context.options[0]));\n\n        /**\n         * Checks the spacing between two tokens before or after the star token.\n         * @param {string} side Either \"before\" or \"after\".\n         * @param {Token} leftToken `function` keyword token if side is \"before\", or\n         *     star token if side is \"after\".\n         * @param {Token} rightToken Star token if side is \"before\", or identifier\n         *     token if side is \"after\".\n         * @returns {void}\n         */\n        function checkSpacing(side, leftToken, rightToken) {\n            if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken) !== mode[side]) {\n                const after = leftToken.value === \"*\";\n                const spaceRequired = mode[side];\n                const node = after ? leftToken : rightToken;\n                const type = spaceRequired ? \"Missing\" : \"Unexpected\";\n                const message = \"{{type}} space {{side}} *.\";\n\n                context.report({\n                    node,\n                    message,\n                    data: {\n                        type,\n                        side\n                    },\n                    fix(fixer) {\n                        if (spaceRequired) {\n                            if (after) {\n                                return fixer.insertTextAfter(node, \" \");\n                            }\n                            return fixer.insertTextBefore(node, \" \");\n                        }\n                        return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Enforces the spacing around the star if node is a yield* expression.\n         * @param {ASTNode} node A yield expression node.\n         * @returns {void}\n         */\n        function checkExpression(node) {\n            if (!node.delegate) {\n                return;\n            }\n\n            const tokens = sourceCode.getFirstTokens(node, 3);\n            const yieldToken = tokens[0];\n            const starToken = tokens[1];\n            const nextToken = tokens[2];\n\n            checkSpacing(\"before\", yieldToken, starToken);\n            checkSpacing(\"after\", starToken, nextToken);\n        }\n\n        return {\n            YieldExpression: checkExpression\n        };\n\n    }\n};\n","yoda.js":"/**\n * @fileoverview Rule to require or disallow yoda comparisons\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//--------------------------------------------------------------------------\n// Requirements\n//--------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\n * Determines whether an operator is a comparison operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether or not it is a comparison operator.\n */\nfunction isComparisonOperator(operator) {\n    return (/^(==|===|!=|!==|<|>|<=|>=)$/).test(operator);\n}\n\n/**\n * Determines whether an operator is an equality operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether or not it is an equality operator.\n */\nfunction isEqualityOperator(operator) {\n    return (/^(==|===)$/).test(operator);\n}\n\n/**\n * Determines whether an operator is one used in a range test.\n * Allowed operators are `<` and `<=`.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether the operator is used in range tests.\n */\nfunction isRangeTestOperator(operator) {\n    return [\"<\", \"<=\"].indexOf(operator) >= 0;\n}\n\n/**\n * Determines whether a non-Literal node is a negative number that should be\n * treated as if it were a single Literal node.\n * @param {ASTNode} node Node to test.\n * @returns {boolean} True if the node is a negative number that looks like a\n *                    real literal and should be treated as such.\n */\nfunction looksLikeLiteral(node) {\n    return (node.type === \"UnaryExpression\" &&\n        node.operator === \"-\" &&\n        node.prefix &&\n        node.argument.type === \"Literal\" &&\n        typeof node.argument.value === \"number\");\n}\n\n/**\n * Attempts to derive a Literal node from nodes that are treated like literals.\n * @param {ASTNode} node Node to normalize.\n * @param {number} [defaultValue] The default value to be returned if the node\n *                                is not a Literal.\n * @returns {ASTNode} One of the following options.\n *  1. The original node if the node is already a Literal\n *  2. A normalized Literal node with the negative number as the value if the\n *     node represents a negative number literal.\n *  3. The Literal node which has the `defaultValue` argument if it exists.\n *  4. Otherwise `null`.\n */\nfunction getNormalizedLiteral(node, defaultValue) {\n    if (node.type === \"Literal\") {\n        return node;\n    }\n\n    if (looksLikeLiteral(node)) {\n        return {\n            type: \"Literal\",\n            value: -node.argument.value,\n            raw: `-${node.argument.value}`\n        };\n    }\n\n    if (defaultValue) {\n        return {\n            type: \"Literal\",\n            value: defaultValue,\n            raw: String(defaultValue)\n        };\n    }\n\n    return null;\n}\n\n/**\n * Checks whether two expressions reference the same value. For example:\n *     a = a\n *     a.b = a.b\n *     a[0] = a[0]\n *     a['b'] = a['b']\n * @param   {ASTNode} a Left side of the comparison.\n * @param   {ASTNode} b Right side of the comparison.\n * @returns {boolean}   True if both sides match and reference the same value.\n */\nfunction same(a, b) {\n    if (a.type !== b.type) {\n        return false;\n    }\n\n    switch (a.type) {\n        case \"Identifier\":\n            return a.name === b.name;\n\n        case \"Literal\":\n            return a.value === b.value;\n\n        case \"MemberExpression\": {\n            const nameA = astUtils.getStaticPropertyName(a);\n\n            // x.y = x[\"y\"]\n            if (nameA) {\n                return (\n                    same(a.object, b.object) &&\n                    nameA === astUtils.getStaticPropertyName(b)\n                );\n            }\n\n            // x[0] = x[0]\n            // x[y] = x[y]\n            // x.y = x.y\n            return (\n                a.computed === b.computed &&\n                same(a.object, b.object) &&\n                same(a.property, b.property)\n            );\n        }\n\n        case \"ThisExpression\":\n            return true;\n\n        default:\n            return false;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow \\\"Yoda\\\" conditions\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptRange: {\n                        type: \"boolean\"\n                    },\n                    onlyEquality: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        // Default to \"never\" (!always) if no option\n        const always = (context.options[0] === \"always\");\n        const exceptRange = (context.options[1] && context.options[1].exceptRange);\n        const onlyEquality = (context.options[1] && context.options[1].onlyEquality);\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether node represents a range test.\n         * A range test is a \"between\" test like `(0 <= x && x < 1)` or an \"outside\"\n         * test like `(x < 0 || 1 <= x)`. It must be wrapped in parentheses, and\n         * both operators must be `<` or `<=`. Finally, the literal on the left side\n         * must be less than or equal to the literal on the right side so that the\n         * test makes any sense.\n         * @param {ASTNode} node LogicalExpression node to test.\n         * @returns {boolean} Whether node is a range test.\n         */\n        function isRangeTest(node) {\n            const left = node.left,\n                right = node.right;\n\n            /**\n             * Determines whether node is of the form `0 <= x && x < 1`.\n             * @returns {boolean} Whether node is a \"between\" range test.\n             */\n            function isBetweenTest() {\n                let leftLiteral, rightLiteral;\n\n                return (node.operator === \"&&\" &&\n                    (leftLiteral = getNormalizedLiteral(left.left)) &&\n                    (rightLiteral = getNormalizedLiteral(right.right, Number.POSITIVE_INFINITY)) &&\n                    leftLiteral.value <= rightLiteral.value &&\n                    same(left.right, right.left));\n            }\n\n            /**\n             * Determines whether node is of the form `x < 0 || 1 <= x`.\n             * @returns {boolean} Whether node is an \"outside\" range test.\n             */\n            function isOutsideTest() {\n                let leftLiteral, rightLiteral;\n\n                return (node.operator === \"||\" &&\n                    (leftLiteral = getNormalizedLiteral(left.right, Number.NEGATIVE_INFINITY)) &&\n                    (rightLiteral = getNormalizedLiteral(right.left)) &&\n                    leftLiteral.value <= rightLiteral.value &&\n                    same(left.left, right.right));\n            }\n\n            /**\n             * Determines whether node is wrapped in parentheses.\n             * @returns {boolean} Whether node is preceded immediately by an open\n             *                    paren token and followed immediately by a close\n             *                    paren token.\n             */\n            function isParenWrapped() {\n                return astUtils.isParenthesised(sourceCode, node);\n            }\n\n            return (node.type === \"LogicalExpression\" &&\n                left.type === \"BinaryExpression\" &&\n                right.type === \"BinaryExpression\" &&\n                isRangeTestOperator(left.operator) &&\n                isRangeTestOperator(right.operator) &&\n                (isBetweenTest() || isOutsideTest()) &&\n                isParenWrapped());\n        }\n\n        const OPERATOR_FLIP_MAP = {\n            \"===\": \"===\",\n            \"!==\": \"!==\",\n            \"==\": \"==\",\n            \"!=\": \"!=\",\n            \"<\": \">\",\n            \">\": \"<\",\n            \"<=\": \">=\",\n            \">=\": \"<=\"\n        };\n\n        /**\n        * Returns a string representation of a BinaryExpression node with its sides/operator flipped around.\n        * @param {ASTNode} node The BinaryExpression node\n        * @returns {string} A string representation of the node with the sides and operator flipped\n        */\n        function getFlippedString(node) {\n            const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n            const textBeforeOperator = sourceCode.getText().slice(sourceCode.getTokenBefore(operatorToken).range[1], operatorToken.range[0]);\n            const textAfterOperator = sourceCode.getText().slice(operatorToken.range[1], sourceCode.getTokenAfter(operatorToken).range[0]);\n            const leftText = sourceCode.getText().slice(node.range[0], sourceCode.getTokenBefore(operatorToken).range[1]);\n            const rightText = sourceCode.getText().slice(sourceCode.getTokenAfter(operatorToken).range[0], node.range[1]);\n\n            return rightText + textBeforeOperator + OPERATOR_FLIP_MAP[operatorToken.value] + textAfterOperator + leftText;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            BinaryExpression(node) {\n                const expectedLiteral = always ? node.left : node.right;\n                const expectedNonLiteral = always ? node.right : node.left;\n\n                // If `expectedLiteral` is not a literal, and `expectedNonLiteral` is a literal, raise an error.\n                if (\n                    (expectedNonLiteral.type === \"Literal\" || looksLikeLiteral(expectedNonLiteral)) &&\n                    !(expectedLiteral.type === \"Literal\" || looksLikeLiteral(expectedLiteral)) &&\n                    !(!isEqualityOperator(node.operator) && onlyEquality) &&\n                    isComparisonOperator(node.operator) &&\n                    !(exceptRange && isRangeTest(context.getAncestors().pop()))\n                ) {\n                    context.report({\n                        node,\n                        message: \"Expected literal to be on the {{expectedSide}} side of {{operator}}.\",\n                        data: {\n                            operator: node.operator,\n                            expectedSide: always ? \"left\" : \"right\"\n                        },\n                        fix: fixer => fixer.replaceText(node, getFlippedString(node))\n                    });\n                }\n\n            }\n        };\n\n    }\n};\n"};